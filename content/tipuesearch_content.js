var tipuesearch = {"pages": [{'title': 'welcome', 'text': '\n \n \n \n \n The user manual is included in the downloadable CoppeliaSim packages \n CoppeliaSim User Manual\n \n \n Version 4.3 \n \n \n The robotics simulator CoppeliaSim, with integrated development environment, is based on a distributed control architecture: each object/model can be individually controlled via an embedded script, a plugin,  ROS / ROS2 nodes, remote API clients, or a custom solution. This makes CoppeliaSim very versatile and ideal for multi-robot applications. Controllers can be written in C/C++, Python, Java, Lua, Matlab or Octave. \n Following are just a few of CoppeliaSim\'s applications: \n Simulation of factory automation systems \n Remote monitoring \n Hardware control \n Fast prototyping and verification \n Safety monitoring \n Fast algorithm development \n Robotics related education \n Product presentation \n \nCoppeliaSim can be used as a stand-alone application or can easily be embedded into a main client application: its small footprint and elaborate API makes CoppeliaSim an ideal candidate to embed into higher-level applications. The Lua or Python script interpreter makes CoppeliaSim an extremely versatile application, leaving the freedom to the user to combine the low/high-level functionalities to obtain new high-level functionalities.\n \n \nA good way to get a quick start with CoppeliaSim is to have a look at the  tutorial section  first.\n \n \nRefer also to CoppeliaSim\'s overview description in other languages:  English ,  Deutsch  (German) ,  Français  (French) ,  Italiano  (Italian) ,  Español  (Spanish) ,  Türkçe  (Turkish) ,  Português  (Portugues) ,  日本語  (Japanese) ,  한국어  (Korean) ,  简体中文(simplified Chinese) ,  繁体中文(traditional Chinese) . \n \n \n \n \n \n coppeliaSimFeatures \n \n \n \n \n \n \n \n 5 Programming Approaches \n \n Powerful APIs, 7 languages \n \n Remote API \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Simulator and simulations are fully customizable, with 5 programming approaches that are mutually compatible and that can even work hand-in-hand. 6 supported programming languages.   \n \n \n Regular API : Python, Lua and C/C++ \n Remote API : C/C++, Python, Java, JavaScript, Matlab & Octave \n ROS interfaces : publishers, subscribers & service calls. Support all standard messages, extendable. \n \n \n \n \n Control a simulation or the simulator itself remotely (e.g. from a real robot or another PC) \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Dynamics/Physics \n \n Inverse/Forward Kinematics \n \n Dynamic Particles \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n 4 physics engines (Bullet Physics, ODE, Vortex Studio and Newton Dynamics) for fast and customizable dynamics calculations, to simulate real-world physics and object interactions (collision response, grasping, etc.) \n \n Inverse/forward kinematics calculations for any type of mechanism (branched, closed, redundant, containing nested loops, etc.). An embeddable version of the IK/FK algorithms is available (i.e. can run on your robot). \n \n CoppeliaSim supports customizable particles that can be used to simulate air or water jets, jet engines, propellers, etc. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Collision Detection \n \n Minimum Distance Calculation \n \n Cross-Platform & Portable \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Fast interference checking between any mesh, OC tree, point cloud, or collection of those. \n \n \n Fast and exact minimum distance calculation between any mesh (convex, concave, open, closed), OC tree, point cloud, or collection of those. \n \n CoppeliaSim is cross-platform, and allows the creation of portable, scalable and easy maintainable content: a single portable file can contain a fully functional model (or scene), including control code. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Proximity Sensor Simulation \n \n Vision Sensor Simulation \n \n Building Block Concept \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Powerful and realistic proximity sensor simulation (exact min. distance calculation within a customizable detection volume). Much more continuous operation than with discrete ray sensors. Operates on meshes, OC trees and point clouds \n \n \n Simulation of vision sensors with many possibilities for image processing, fully customizable and extendable (e.g. via plugin) \n \n \n Anything - from sensors or actuators, to whole robotic systems - can be built within CoppeliaSim by combining basic objects and linking various functionality via embedded scripts. Every scene object can have its own embedded script! \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Path/Motion Planning \n \n Data Recording and Visualization \n \n Custom User Interfaces \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Path planning / motion planning is supported in a very flexible way via the  OMPL library  wrapped in a plugin for CoppeliaSim \n \n A large variety of recordable data streams (including user-defined) can display time-graphs, or can be combined with each other to form x/y-graphs, or 3D curves \n \n Unlimited number of fully customizable user interface elements \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Integrated Edit Modes \n \n Easy Data Import/Export \n \n RRS Interface & Motion Library \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Special mesh edit modes are supported  (including a semi-automatic primitive shape extraction method, convex decomposition, mesh decimation, etc.) \n \n \n Following file formats are supported (also when called through the API): URDF, COLLADA, DXF, 3DS, OBJ, STL (ASCII & binary) \n \n \n The  RRS-1  interface specifications are fully implemented, and the  Reflexxes  Motion Library and  Ruckig Online Trajectory Generator  are fully supported. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Full-Featured Scene Hierarchy \n \n Convenient Model Browser \n \n Full Interaction \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n The scene composition is intuitively visualized in a scene hierarchy view, indicating object aliases, types, associated control scripts, loop closures, selection and visibility states, warnings, etc. \n \n The integrated model browser supports drag-and-drop operations (also during simulation!) for convenient scene composition. The available model library, updated at each release, can be easily extended by the user \n \n \n Full interaction also during simulations: models, together with their associated behavior (i.e. embedded scripts) can be shifted, rotated, copy/pasted, scaled, erased, etc. without having to adjust any code \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Free Educational License \n \n Free Player Version \n \n Many More features \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n Educational entities (hobbyists, students, teachers, professors, schools and Universities) can use CoppeliaSim Edu for free. The source code of all elements is available. Refer to the  licensing page  for details \n \n A free CoppeliaSim Player version is available, and allows running and interacting with CoppeliaSim simulations \n \n \n e.g. three.js browser-based viewer, multilevel undo/redo, movie recorder, simulation of paint or welding seams, OC trees, point clouds, exhaustive documentation, etc. \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \xa0 \n versionInfo \n \n \n \n \n \nCoppeliaSim version history\n \n \nCoppeliaSim versions are indicated as follows:\n \n \nVersion X.Y.Z (rev. W) \n \nWhere:\n \n \nX identifies a special release (once every couple of years)\nY identifies a major release\nZ identifies a minor release\nW identifies a revision number (0 is usually for a beta version, 1 for a first regular release) \n \n \nVersion history:\n \n \n CoppeliaSim V4.4.0 (not yet released)\n \n Fixed several bugs. Thanks to Pranav A. Bhounsule, Amirhossein Afkhami Ardekani, Roman Horshkov, Volker Kühn, Artem Shishkin and Davide Scorza for noticing them or helping to resolve them \n sim.ruckigPos ,  sim.ruckigVel ,  sim.moveToConfig  and  sim.moveToPose  can now also be used for non-symmetric velocity/acceleration profiles, via the  sim.ruckig_minvel  and  sim.ruckig_minaccel  flags \n The  ZeroMQ remote API  is now supported in following languages: Python, c++, Matlab, Octave, Lua and Java \n Capsule primitives are now also supported \n Kinematic joints can now also be directly driven via  sim.setJointTargetPosition  and  sim.setJointTargetVelocity , using maximum velocity, acceleration and jerk constraints, for a specific motion profile \n Dynamic joints now have distinct and more clearly defined  control modes :  free ,  force/torque ,  velocity ,  position ,  spring  and  custom . \n Added  sim.broadcastMsg , which allows to easily broadcast a message to all scripts \n Added a point sampler add-on, that allows to extract 3D poisitions and normal vectors from the mouse cursor \n Added a scene demonstrating texture modification to simulate a vehicle\'s trace: scenes/mobileRobotVisualTraces.ttt \n Added a model of the ABB YuMi:  Models/robots/non-mobile/ABB YuMi.ttm \n Added a model of the Mirobot:  Models/robots/non-mobile/Mirobot.ttm \n Added a model of a generic tray:  Models/equipment/generic tray.ttm \n Added a model of a generic external wall:  Models/infrastructure/walls/external wall.ttm \n \n \n \n CoppeliaSim V4.3.0 (January 27th 2022)\n \n Fixed several bugs. Thanks to Nathan Kocherhans, René Simon, Yongdong Wang, Andrés Faíña, Eric Rohmer, Davide Scorza, Jovan Sumarac, Luigi Ascione, Cameron Kabacinski, Rui Li, Patrick Grüner, Andrés Faíña, Michal Mareš, Kat Styles Wood, David Paulius and Alex Wuqi Zhang for noticing them or helping to resolve them. \n Python is now also supported next to Lua, as a programming language for  CoppeliaSim scripts . Both operate in almost the same fashion,  except for small differences . See also the example scenes  scenes/simplePythonExample.ttt ,  scenes/controlTypeExamples/controlledViaScript.ttt  and  scenes/trajectoryAndMotion/ruckigOnlineTrajectoryGeneratorExample-pythonAndLua.ttt \n Objects are now identified via a path and an  alias , instead of a unique object name, as was the case in previous versions: this allows for a safer and more flexible  object access , by specifying absolute or relative paths, e.g.  sim.getObject ("./descendentObject"). This also means that object aliases (i.e. formerly  names ), do not need to be unique anymore. See also  sim.getObjectAlias  and  sim.setObjectAlias . \n Added a plugin wrapping the  Ruckig Online Trajectory Generation library , courtesy of Lars Berscheid. It acts as a drop-in replacement for the  Reflexxes Motion Library  type 4, and thus also offers the jerk limitation functionality. Functionality is available via  sim.ruckigPos ,  sim.ruckigVel ,  sim.ruckigStep  and  sim.ruckigRemove . \n Added a  WebSocket interface plugin . \n Added a  remote API based on ZeroMQ , currently however only fully implemented in  Python and C++. Compared to the legacy remote API, it is very easy to use, lightweight, and  supports the exact same API functions that are availabe via  scripts : this includes all  regular API functions  (i.e. sim.* -type functions), but also all API functions provided by  plugins  (e.g. simOMPL.*, simUI.*, simIK.*, etc.)  \n Added several new callback functions:  sysCall_event  and  sysCall_ext . sysCall_event in particular allows to keep track of most changes happening in a CoppeliaSim scene, and allows to easily implement external renderers, etc. See also next item. \n Added a  web-browser based front-end . \n Added  sim.registerScriptFuncHook , which allows to set up function hooks to be executed before or after a specific function, namely also (system)  callback functions . \n Object\'s  renderable  flags are now ignored by  vision sensors : instead, vision sensors will render object in the same way as do  cameras , by only taking into account their visibility state: this ends some confusion, but can lead in some situations to a different behaviour and result. Flexibility is however still guaranteed, with the ability to use a  collection  as renderable entity, which can override object\'s visibility states. \n Added an  add-on  that allows to record animations from any selected object/model:  Animation capture \n Added  sim.generateTextShape  and an add-on that allows to generate and edit 3D text:  3D text generator . The add-on is courtesy of  Mechatronics Ninja \n Added an add-on that can import floor-plan images to 3D shapes:  Floor plan importer . \n Added an add-on that allows to quickly check for self-collisions, collisions with the environment, or collisions between two entities:  Collision check . \n Added an add-on that allows to quickly measure distances between an entity and the environment, or between two entities:  Distance check . \n Added an URDF export add-on:  URDF exporter . \n Added a model of the Franka Emika gripper, courtesy of Alexander\xa0Oliva \n Added  sim.moduleEntry  that allows to handle menu entries in the  Modules  tab. When selected, the corresponding script will have its  sysCall_moduleEntry  callback function triggered. \n Added  sim.getShapeBB  and  sim.setShapeBB  to be able to scale shapes more conveniently \n Added the possibility to transform/distort  vision sensor  images via a function using pixel remapping:  simVision.distort . See also the related demo scene in  scenes/vision/imageProcessingDemo2.ttt \n Added an example model of a Stewart platform:  Models/robots/non-mobile/Stewart platform.ttm \n Added an example scene of IK and obstacle avoidance:  Scenes/kinematics/obstacleAvoidanceAndIk.ttt \n Added an example scene of a mobile robot doing path planning:  Scenes/pathPlanning/mobileRobotPathPlanning.ttt \n Added an scene that illustrate\'s the relationship of  CoppeliaSim\'s Euler angles convention (alpha-beta-gamma)  and the yaw-pitch-roll Euler angles convention:  Scenes/eulerAngles.ttt \n Added an example scene illustrating IK movement via the  remote API :  scenes/messaging/ikMovementViaRemoteApi.ttt . Related Python scripts can be found in  programming/zmqRemoteApi/clients/python/  and in  programming/remoteApiBindings/python/python/ \n Added a simple button-click action tool:  Models/tools/button action tool.ttm \n Added a  Qt QML plugin . \n Added an  IGL plugin , for boolean operations on shapes. \n Added a  subprocess plugin , for launching and handling subprocesses. \n \n \n \n CoppeliaSim V4.2.0 (April 6th 2021)\n \n Fixed several bugs. Thanks to Adrian Schoisengeier, Mathias Thor, Francisco Marin, Nikita Aigner, Charles Han, Shai Levy, Bobovsky Zdenko, Salvatore Sessa, Jakob Ambsdorf, Hayato Amaike, and Kevin Thomas for noticing them or helping to resolve them. \n All script types  now support  threaded or non-threaded operation . Threaded operation is handled via coroutines that are preemptively interrupted by CoppeliaSim. Except for its code, there is no difference anymore between a threaded and non-threaded script. Old threaded child scripts are still supported for backward compatibility, but CoppeliaSim will try to automatically convert them. If this is not desired, adjust value  keepOldThreadedScripts  in  system/usrset.txt . \n Switched from Lua 5.1 to Lua 5.3. Backward compatibility should normally be maintained, except maybe for old Lua modules you might be using. If this is the case, update those module to their Lua 5.3 counterparts. Read also about the  language incompatibilities introduced in Lua 5.2 , and the  language incompatibilities introduced in Lua 5.3 . Additional backward compatibility code can be communicated to us and added to  lua/sim.lua. \n The  ROS2 interface  is now also supported on Windows. \n Since this release, static IK groups (i.e. created via the GUI) are deprecated in favor of  dynamically created IK groups , which offer much more flexibility. Read more about the  kinematics functionality here . \n Added the convenience functions  simIK.addIkElementFromScene ,  simIK.applyIkEnvironmentToScene ,  simIK.applySceneToIkEnvironment , allowing to quickly generate an IK element from a kinematic chain in the scene, and to perform/apply calculations to it. All scenes have been adjusted to use above convenience functions. As simple example can be seen in  scenes/kinematics/simpleIkGroupWithSimpleIkElement-undamped.ttt \n Added  simIK.duplicateEnvironment : useful when operating on an IK environment while leaving the original environment unchanged. Also added  simIK.save . \n Kinematic example scenes in folder  kinematics  have been reworked and simplified. \n Added  simIK.generatePath  and a related demo scene:  scenes/kinematics/ikPathGeneration.ttt \n Rewrote the  inverse kinematics tutorial . \n Rewrote and reorganized large parts of the user manual. \n Since this release, static collections (i.e. created via the GUI) are deprecated in favor of dynamically created collections, with  new API functions . This results in much more flexibility. Read more about  collections here . \n Since this release, static collision objects (i.e. created via the GUI) are deprecated in favor of  sim.checkCollision . Read more about  collision detection here . \n Since this release, static distance objects (i.e. created via the GUI) are deprecated in favor of  sim.checkDistance . Read more about  distance calculation here . \n Since this release, graph streams and curves created via the GUI are deprecated in favor of streams/curves created and manipulated via  new API functions . This allows a much more flexible and precise control of graphs. Read more about  graphs here . \n Since this release, path objects are implemented in a generic manner, via a pseudo path objects. This allows much more flexibility. Read more about  paths here , and have a look at the simple example scene  scenes/movingAlongAPath.ttt . \n Added a  CoppeliaSim linear algebra library . \n Added a  ZeroMQ interface plugin . \n Added new conveyor models, allowing to easily create conveyor systems of any size/shape. See models in  Models/equipment/conveyors . \n sim.getShapeMassAndInertia  and  sim.setShapeMassAndInertia  are deprecated, and replaced by  sim.getShapeMass ,  sim.setShapeMass ,  sim.getShapeInertia  and  sim.setShapeInertia . \n Added a new demo scene illustrating smooth movement profiles in forward and inverse kinematics mode:  kinematics/smoothMovementsInFkAndIk.ttt \n Updated the  OMPL plugin  to use the OMPL library version 1.5.0 \n Added  simIK.getAlternateConfigs  and  sim.getAlternateConfigs , to be used in conjunction with  simIK.getConfigForTipPose , when dealing with manipulators that have joint ranges larger than 360 degrees, to generate alternative configurations. \n Added several  path-related API functions , including  sim.generateTimeOptimalTrajectory  that allows to generate time optimal trajectories (i.e. trajectories that respect velocity and acceleration constraints), based on the  TOPP-RA library . A demo scene related to that can be found in  scenes/trajectoryAndMotion/pathToTrajectory.ttt . \n Added a SVG widget for the  CustomUI  plugin. Content can be loaded from file, from XML string, or embedded in the UI XML. \n sim.rmlMoveToJointPositions  and  sim.rmlMoveToPosition  are deprecated in favor of  sim.moveToConfig  and  sim.moveToPose , which feature a callback mechanism for maximum flexibility. \n Added following API functions:  sim.isDynamicallyEnabled ,  sim.getJointDependency ,  sim.changeEntityColor  and  sim.restoreEntityColor . \n Following Docker image is available for running CoppeliaSim in a container:  docker-image-coppeliasim \n The default scene will now pause simulation when a script error is raised. \n Added an additional  dynamics configuration mode  that performs smaller dynamics steps and/or does more calculation iterations. Went from [ very accurate ,  accurate (default) ,  fast ,  very fast ,  custom ] to: [ very accurate ,  accurate ,  balanced (default), fast ,  very fast ,  custom ]. \n The Windows installer/uninstaller can now silently operate by invoking it with following command-line arguments:  /silent /hide /[silent]=true \n \n \n \n CoppeliaSim V4.1.0 (July 21st 2020)\n \n Fixed several bugs. Thanks to Jakub Turaj, Rieky Barady, Jian Ye, Jaime Boal, Mathias Thor, Pável Axel Mc Campos Peña, Filipe Rocha, Patrick Gruener, Thomas Wilmotte, Lorenzo Romanini, Pablo Bustos, Sonny Tarbouriech, Johan Relefors, Adrian Schoisengeier, Arturs Paugurs, Wei Wei, David Page, Ayush Patel, Aleksander Sil and Cameron Kabacinski for noticing them or helping to resolve them. \n Ubuntu20.04 support \n Switched to Qt5.15.0 and VC2019 on Windows. \n CoppeliaSim\'s kinematics functionality  (i.e. forward and inverse kinematics) is  now also available via Lua scripting : this means that instead of creating and handling kinematics tasks via the GUI, one can also entirely create and handle them programmatically in a very flexible manner. Two example scenes illustrate this:  scenes/kinematics/8-computingJointAnglesForRandomPoses.ttt  and  scenes/kinematics/9-programmaticallySettingUpIk.ttt \n CoppeliaSim\'s  collision detection  and  minimum distance calculation  functionality on  shapes ,  OC-Trees  and  point-clouds  is  now also available via Lua scripting : you can now also perform the same kind of calculations without the need of creating any scene object or modifying the scene content. This is illustrated in following example scene:  scenes/sceneObjectIndependentGeometricCalculationExample.ttt \n ROS2 Interface  plugin for ROS2 Foxy Fitzroy, supports topics, services, actions, params, TF2 broadcast and image transport. \n GLTF plugin can export static scene and animations in the GLTF 2.0 format. The functionality is available via the add-on menu, or via  related API functions . \n URL Drop plugin allows loading scene from remote locations via drag and drop (e.g. drop an URL from a browser\'s window). \n The verbosity level (console, status bar and simple dialogs) can now be adjusted from the  command line  with the  -v  , - w  and  -x  arguments. To output messages, plugins should now use  simAddLog  and scripts  sim.addLog . \n An optional Lua script string may be executed via the  command line  with the -c argument. \n Added an example scene illustrating simple motor controllers:  scenes/motorControllerExamples.ttt \n Added an example scene illustrating how to apply inverse kinematics to dynamically enabled models/manipulators:  scenes/kinematics/10-applyingIkToDynamicallyEnabledModels.ttt \n Added an example scene illustrating simple usage of the Reflexxes Motion Library:  scenes/reflexxesMotionLibraryExamples.ttt \n Added  sim.setJointTargetForce  and  sim.getJointTargetForce .  sim.setJointForce  is now deprecated. \n Added  sim.yawPitchRollToAlphaBetaGamma  and  sim.alphaBetaGammaToYawPitchRoll , to convert between those two different  Euler angle representations . \n The true headless CoppeliaSim library is also shipped (i.e.  coppeliaSimLibHeadless.dll  or similar). This is in addition to the headless mode supported via the  -h   command line  option, which simply suppresses all GUI elements of the regular CoppeliaSim library. \n Fixed a few shape export problems (i.e. normals and/or textures) \n A  Simulink-CoppeliaSim communication plugin  is now available, courtesy of Diego Daniel Santiago. \n Many  CoppeliaSim video tutorials  courtesy of Leopoldo Armesto. \n \n \n \n CoppeliaSim V4.0.0 (November 26th 2019)\n \n We discontinued  development of V-REP. Instead, we focus our efforts on CoppeliaSim. CoppeliaSim is 100% compatible with V-REP (i.e. it is a fork of the V-REP project). It runs faster and has more features than V-REP. Of course will Coppelia Robotics handle V-REP support and licenses in a perfectly interchangeable manner with CoppeliaSim support and licenses. \n Fixed several bugs. Thanks to Mark Hartenstein, Stephen James, Simon Birrell, Sahil Sharma, Adrian Schoisengeier, Rémi Lux, Kilian Freitag, Maël Hörz and Eric Rohmer for noticing them or helping to resolve them. \n Completely rewrote the calculation routines handling collision detections, minimum distance calculations, proximity sensor simulations, OC trees and point clouds. A significant speed increase could be achieved. The routines are now grouped in the  geometric plugin . The core of the geometric plugin are the  Coppelia geometric routines , available for stand-alone applications. \n You can now import and export  XML files . \n You can now from within the  script editor  open the API documentation for the function/constant under the mouse pointer, via the context menu. \n Switched to Qt5.12.5 on all 3 platforms. \n Added support for ROS 2 via  ROS2Interface . See the  compiledRosPlugins  folder, and the  ROS2 Interface source code . Have also a look at  ROS 2 API  and the  ROS 2 tutorial . \n Vision sensor filters are no longer supported. They are replaced by  vision callback functions , which allow for a much more flexible operation. Old scenes are automatically updated. A demo scene illustrating the new way to handle image processing was added:  imageProcessingDemo.ttt . \n Added  trigger callback functions  for vision sensors, proximity sensors, and force/torque sensors. \n Added  user config callback functions , which allow implementing custom behaviour upon double-clicking user parameter icons. \n Added an  add-on  for exporting scene content as  glTF  data: simAddOnGLTFExporter.lua \n The  OpenGL3 renderer  can now also be selected as renderer for  cameras , during simulation. \n Added the model of the Franka Emik Panda robot, courtesy of Alexander Oliva, Marco Cognetti and Claudio Gaz. \n CoppeliaSim simulations can be exported to Blender via Boris Bogaerts\'  CoppeliaSim-Blender-Tools . \n RLBench  is an ambitious large-scale benchmark and learning environment designed to facilitate research in a number of vision-guided manipulation research areas, including: reinforcement learning, imitation learning, multi-task learning, geometric computer vision, and in particular, few-shot learning. RLBench, built around  PyRep  and CoppeliaSim, is created by Stephen James. \n Added a model of the  Niryo One robot . \n \n \n \n V-REP V3.6.2 (June 26th 2019)\n \n Fixed several bugs. Thanks to Jacob Smith, Mohsen Moradi Dalvand, Simon Birrell, Mathias Thor, Jedrzej Orbik and Liu Dong for noticing them or helping to resolve them. \n PyRep , built on top of V-REP and courtesy of Stephen James (Imperial College London), is a Python toolkit for robot learning research. Compared to the remote  client approach, it displays great speed improvements since remote procedure calls or synchronization are not required. This makes PyRep the perfect solution for learning algorithms in the areas of reinforcement learning, imitation learning, state estimation, mapping, and computer vision. \n V-REP now also offers shadows support with  vision sensors , when rendering via the  OpenGL3  renderer plugin , courtesy of Stephen James (Imperial College London). See also the updated  rendererDemo.ttt  scene. \n The sandbox script  is now loaded from  system/sndbxscpt.txt  at start-up, and can contain similar callback functions as  add-ons . \n Named  command-line  arguments are now supported via the  -G  option. Those can be queried (e.g. by plugins) via  sim.getNamedStringParam . \n \n \n \n V-REP V3.6.1 (March 15th 2019)\n \n Fixed several bugs. Thanks to Julian Mayer and Boris Bogaerts for noticing them or helping to resolve them. \n Switched to Qt5.12.1 on all 3 platforms \n Added API functions  simApplyTexture ,  sim.setJointDependency  and  sim.getStackTraceback . \n The shape import/export functionality is now handled by a V-REP Plugin ( simExtAssimp ), based on the  Assimp library . See  here  for the new API functions. \n URDF and SDF files are now loaded with textures (if present) \n \n \n \n V-REP V3.6.0 (February 15th 2019)\n \n Fixed several bugs. Thanks to Leon Masopust, Michael Tong, Zhengxing Yang, Lenka Pitonakova, Thomas Gurriet, Hervé Frezza-Buet, Justus Rijke, Stefan Müller, Julien Lechalupe, Tristan Gahler, Robert Peck, William Jones, Benjamin Erdemann, Ulrich Viereck, Joachim Haensel and Justus Rijke for noticing them or helping to resolve them. \n Script execution/calling order  has been adjusted, for a more consistent and overall logical behaviour. This may have an impact on how a simulation runs in certain situations. \n Dynamics callback functions  have been implemented and are supported in  child scripts  and  customization scripts . \n Added a system callback function for  customization scripts  and  add-ons  that allows, during simulation, to control the execution of the  main script : sysCall_beforeMainScript. This is useful to easily implement step-by-step simulation, or to easily synchronize the simulation with an external application. \n Added a simple  script debug functionality  that allows to monitor function calls and watching variables. \n The Lua commander now has dynamic variable completion, history, explicitely prints any variable, etc. Type  help()  for details. \n Added following API function:  sim.getPersistentDataTags . \n The Open Mesh plugin for V-REP now uses the latest OpenMesh library (V6.3) on all 3 platforms \n Added a  MessagePack  module for Lua:  lua-MessagePack , courtesy of Francois Perrad. \n Added a  MessagePack  encoder/decoder for C/C++:  msgpack-c , courtesy of Takatoshi Kondo and several others. \n Added a  MessagePack  encoder/decoder for Matlab:  matlab-msgpack , courtesy of Bastian Bechtold. \n Added a  MessagePack  encoder/decoder for Java:  msgpack-java , courtesy of Sadayuki Furuhashi and several others. \n Added a  CBOR  encoder/decoder for Lua:  Lua-CBOR , courtesy of Kim Alvefur. \n Added  sim.getRandom ,  math.random2  and  math.randomseed2  in order to provide individual random number generators for each script ( math.random  and  math.randomseed  share the same generator, independent of which script is calling) \n The  script editor  functionality is now provided via a plugin:  simExtCodeEditor . It allows to easily search/replace, do/undo, jump to specific functions, restart a script, offers non-modal customization script edition, etc. Code included via the  require  directive can automatically be opened and modified via the popup menu. You can temporarily revert to the old script editor functionality by adjusting variable  useOldCodeEditor  in file  system/usrset.txt . \n Added  sim.textEditorOpen ,  sim.textEditorClose ,  sim.textEditorShow  and  sim.textEditorGetInfo \n A VR interface for V-REP was developed by Boris Bogaerts. It can visualize any V-REP scene in steamVR (openVR) compatible VR devices and return user manipulations to V-REP. Installer files are available  here  (no compilation required, windows only). Instructions on how to use the interface are provided  here . \n A ROS-enabled e-puck, courtesy of Andrei Florea and Catalin Buiu, was added to the model library. More details can be found  here . \n \n \n \n V-REP V3.5.0 (February 6th 2018)\n \n Fixed several bugs. Thanks to Steffen Hemer, Fangyi Zhang, virgile Daugé, Riccardo Spica, Filipe Rocha, Jacob Huesman, Matthew Veres, Robert Lang and Florian Golemo for noticing them or helping to resolve them. \n Switched to Qt 5.9.0 LTS on all platforms. \n From within a script,  print()  now prints to the status bar, instead of the console. This can be reverted with  print=printToConsole .  printf () is now also supported. Both,  print  and printf will now also print the content of tables. \n Added a Lua commander plugin (read-eval-print loop), that adds a text input to the V-REP status bar, which allows entering and executing Lua code on the fly, like in a terminal. The code can be run in the  sandbox script , or any other active script in V-REP \n Moved all the source code items related to V-REP to  github . \n Switched to a cleaner way of calling script code, by using predefined functions (e.g.  sysCall_init ,  sysCall_actuation , etc. Scripts should now  contain nothing else than functions anymore. The old way of calling scripts is however still supported for the sake of backward compatibility (but make sure not to mix both methods). \n New  joint callback functions  have been implemented and are supported in  child scripts  and  customization scripts . The old joint control callback script functionality should not be used anymore and is not accessible anymore via the GUI, but is still operational (you can  temporarily make it accessible again via  enableOldJointCallbackScriptEdition  in  system/usrset.txt ) \n A new  contact  callback function  has been implemented and is supported in  child scripts  and  customization script . The old contact callback script functionality should not be used anymore and is not accessible anymore via the GUI, but is still operational (you can  temporarily make it accessible again via  enableOldCustomContactHandlingEdition  in  system/usrset.txt ) \n New widgets and API functions were added to the  custom UI . \n Updated the content of v-repNotepad++.zip, which contains all V-REP-related calltips and syntax highlighting keywords for Notepad++. \n Added  sim.getShapeViz , that allows to retrieve a shape\'s mesh and texture information \n Added a tool that allows to step through a simulation by triggering each individual simulation step. Can also be used in replacement of the remote API or ROS synchronous mode. The tool is located in  Models/tools/simulation stepper tool.ttm . \n Added a vision sensor model that extracts 3D positions from blob detections:  Models/components/sensors/Blob to 3D position.ttm . \n Added a  plugin  that wraps the  LibICP  (Library for Iterative Closest Point Matching, by Andreas Geiger) \n Added a  plugin  that wraps the  OpenCV  library, offering basic image processing and drawing functionality \n Broke compatibility of the  simExtSurfaceReconstruction_reconstruct  API function, which was replaced with  simSurfRec.reconstruct_scale_space . \n Added support for shared memory communication in the  legacy emote API . The code is courtesy of Benjamin Navarro. By specifying a negative port number, shared memory will be used instead of socket communication. \n Added following API functions:  sim.executeScriptString ,  sim.getApiFunc ,  sim.getApiInfo ,  sim.setModuleInfo  and  sim.getModuleInfo . \n A  Lanelet  plugin for V-REP was developed by Cándido Otero, available  here . \n Modern Robotics: Mechanics, Planning, and Control , a new textbook by Prof. Kevin M. Lynch and Prof. Frank C. Park is available for free download  here , and also available for purchase as hardback copy. Several V-REP examples and scenes are available  here . \n \n \n \n V-REP V3.4.0 (April 6th 2017)\n \n Fixed several bugs. Thanks to Sven Schweigler, Nicola Battilani, Mark Edmonds, Benno Timmermann, Cándido Otero Moreira, Graeme Neff Wilson, Justin Yim, Allen Zhu, Leo Koppel, Ravi Prakash Joshi, Sina Radmard, Sai Vemprala, James Barger, Gonzalo Casas, Metehan Doyran, Arif Rahman and Jason Cachrane for noticing them or helping to resolve them. \n For the Windows version of V-REP, switched to Qt 5.6.2, MSVC2015 and 64bit. Make sure to desinstall previous V-REP versions explicitely in folders  program files (x86)/V-REP3/V-REP_PRO ,  program files (x86)/V-REP3/V-REP_PRO_EDU  and  program files (x86)/V-REP3/V-REP_PLAYER : execute  V-REP_*_Setup_*.exe  in those folders. Then remove folder  program files (x86)/V-REP3 . Prior to that you should backup an existing license key. \n The  Vortex plugin  is now based in the free version of the Vortex engine:  Vortex Studio . The user will however have to download/install Vortex Studio, and  register with CM Labs , in order to enable the vortex plugin for V-REP. \n The Vortex plugin now has the multithreading option turned off by default, since this provides better stability and faster simulation speeds for typical V-REP scenes. This can however still be turned on in the  dynamics engines general properties . \n Reworked the  position dialog  and the  orientation dialog . \n Added various API functions:  sim.transformBuffer . \n Added a reconfigurable model of the Ragnar robot:  Models/robots/non-mobile/ragnar.brm \n Added a new  command line option  allowing to disable specific GUI items. \n Material properties (used by the physics engines) are not shared among shapes anymore, since this lead to confusions and apparently strange behaviours, and  material pollution . Now, every shape has its own set of material properties. Material properties can be copied from another shape, or set to a predefined type via  sim.setShapeMaterial . \n Custom UIs  can now display plots, be modal, etc. A few bugs have also been fixed. \n 2D visualization of newly added  graph objects  is now based on the  custom UI  plot functionality. \n Added following API functions to the  ROS Interface :  simROS.getTime ,  simROS.hasParam ,  simROS.searchParam ,  simROS.deleteParam ,  simROS.getParamBool ,  simROS.setParamBool ,  simROS.getParamInt ,  simROS.setParamInt ,  simROS.getParamDouble ,  simROS.setParamDouble ,  simROS.getParamString ,  simROS.setParamString .  \n Added an improved version of the playback tool:  Models/tools/playback tool.ttm : it operates faster, requires less memory, and uses the  custom UI plugin . \n Added a tool for viewing custom data blocks attached to objects or a scene:  Models/tools/custom data block reader.ttm . \n Added an API function, based on the  CGAL library , that allows to extract a shape from a point cloud:  simSurfRec.reconstruct_scale_space . A model using that function is available here:  Models/tools/surface reconstruction.ttm \n Added a model allowing to import a point cloud from a  *.xyz  file format:  Models/tools/point cloud importer.ttm \n Added an option to record the desktop, including overlapping dialogs, instead of only the simulation window in the  video recorder . \n The Reflexxes Motion Library type 4 plugin (RML4 plugin) is no longer distributed. Instead, a RML2 plugin is distributed. This means that jerk limitation is no longer supported. The former RML4 plugin is however still functional (i.e.  simExtRML4.dll / libsimExtRML4.so / libsimExtRML4.dylib ): simply replace or place it alongside the RML2 plugin in the V-REP main folder. \n The OpenGl-based custom UI edition capability was removed, since that functionality is not as flexible and elegant as the  Qt-based custom UIs . OpenGl-based custom UIs will however still be functional, and you can enable edition capability again with variable  enableOpenGlBasedCustomUiEditor  in file  system/usrset.txt . \n Added a simulation model of the UR3 robot:  Models/robots/non-mobile/UR3.ttm . \n CoppeliaSim Edu / V-REP PRO EDU can now read scene and model files from  XReality . CoppeliaSim Pro / V-REP PRO can now read/write scene and model files from/for  XReality . \n Added following two API functions:  sim.setReferencedHandles  and  sim.getReferencedHandles . \n Added a model of  Marty the Robot  (in  Models/robots/mobile/  ), courtesy of  Sandy Enoch  of  Robotical Ltd.  and  Alejandro Bordallo .  Marty  is designed to work with the official ROS Marty stack. \n A swarm controller for the teleoperation of robot swarms in a V-REP based simulation environment, courtesy of the robotics and control systems laboratory of the Sapientia Hungarian University of Transylvania, is available  here . \n Added a  JSON  module for Lua:  dkjson , courtesy of David Heiko Kolf. \n \n \n \n V-REP V3.3.2 (August 29th 2016)\n \n Fixed several bugs. Thanks to Hao Wang, Robert Lang, Riccardo Spica, Matias Nitsche, Sven Knüppel, Ndivhuwo Makondo, Yu Zhang, Paul Santiago Tumbaco Casa, DeKita G. Moon, Rodrigo Moreno Garcia, Federico Ferri and Arjun Narayanan for noticing them or helping to resolve them. \n Improved the point cloud functionality. You can now specify a minimum distance tolerance which is used to avoid duplicate points. The tolerance can be specified in the  point cloud properties dialog , or via  sim.insertPointsIntoPointCloud  or  sim.insertObjectIntoPointCloud . \n Added a simulation model of the Sawyer robot:  models/robots/non-mobile/Sawyer.ttm . The original CAD data is courtesy of Rethink Robotics. \n Added an infinite floor model, that allows to mimic an infinite floor:  Models/infrastructure/floors/infiniteFloor.ttm . \n Added the paths  <currentScenePath>  and  <V-REPInstallationPath/lua>  to the Lua path variable of all scripts. \n Improved the  custom UI plugin : widgets can now be enabled/disabled, and event messages supressed when setting a widget value. An  editing finished  event can now also be generated for edit boxes. \n Added a G-code interpreter that can be found in  lua/gcode.lua . A demo scene was also added:  Scenes/gCode.ttt . \n Added several new API functions:  sim.openTextEditor ,  sim.packTable  and  sim.unpackTable . \n Added a first version of a  SDF format importer plugin , courtesy of Federico Ferri. \n An SDL2 library plugin, courtesy of Tobias Benz, is available  here . \n \n \n \n V-REP V3.3.1 (May 17th 2016)\n \n Fixed several bugs. Thanks to Ahmed Yacine, Korolyov Alexei, Graeme Neff Wilson, Daniel Angelov, Scott Hissam, Mohammed Talha and Mark Fink for noticing them or helping to resolve them. \n Added a new ROS plugin ( ROS Interface ), which supports most standard ROS messages, and which naturally duplicated the ROS C/C++ API. We highly recommend to use this new ROS interface, rather than the previous one (RosPlugin). Both however can run side-by-side. The scene  controlTypeExamples.ttt  was adjusted and now includes an additional robot, which is controlled via the new  ROS Interface . A new scene was created that also illustrates the new  ROS Interface :  rosInterfaceTopicPublisherAndSubscriber.ttt .\n Added a new object type:  OC trees . They represent a spatial partitioning based of voxels and can be used for various purposes (e.g. simplified shape representation, occupancy grid/space, etc.). OC trees are  collidable ,  measurable  and  detectable . New API function related to OC trees are listed  here . \n Added a new object type:  point clouds . They represent points stored inside of an OC tree-like data structure and can be used for various purposes (e.g. point storage and manipulation, etc.). Point clouds are  collidable ,  measurable  and  detectable . New API function related to point clouds are listed  here . \n Added a new scene ( collisionDetectionDemo.ttt ), which illustrates V-REP\'s collision detection capabilities on dummies, shapes, OC trees and point clouds. \n Added a new scene ( minimumDistanceCalculationDemo.ttt ), which illustrates V-REP\'s minimum distance calculation capabilities on dummies, shapes, OC trees and point clouds. \n Added a new scene ( proximitySensorDemo2.ttt ), which illustrates V-REP\'s proximity sensor capabilities on dummies, shapes, OC trees and point clouds. \n Added two new scenes:  octreeGenerationDemo.ttt  and  navigationWithinAPointCloud.ttt . \n Added a new OMPL plugin function, that allows to specify several goal states for a given task:  simOMPL.addGoalState . Following demo scenes now use this new functionality:  motionPlanningDemo1.ttt ,  motionPlanningServerDemo.ttt  and  motionPlanningAndGraspingDemo.ttt . \n Added a new type of custom user interface, based on a plugin and Qt:  Qt-based custom UIs . A demo scene can be found at  scenes/customUI-QtBased.ttt . \n Added a menu item that allows to compute the inflated convex hull of a shape. This is useful in order to generate simplified collision object that are slightly bigger than their original. The menu item is located at [Menu bar --> Add --> Inflated convex hull of selection...] \n Added  stack functions  that allow to hold almost any type of data or data structure. This is useful for flexible communication between plugins and scripts. Following new API functions now use stacks:  simCallScriptFunctionEx  and  simRegisterScriptCallbackFunction . \n Added  setter and getter API function for the physics engine properties . \n Added a newer version of the Bullet engine (i.e. V2.83). The new version offers now 4 different solver types:  sequential impulse ,  NNCG ,  Dantzig , and  projected Gauss-Seidel . All physics engine\'s plugins have been reworked. \n Added two additional spherical vision sensors: they now allow to retrieve spherical RGB images, spherical depth buffers, or spherical RGB images and depth buffers:  Models/components/sensors/spherical vision sensor RGB.ttm ,  Models/components/sensors/spherical vision sensor depth.ttm ,  Models/components/sensors/spherical vision sensor RGB + depth.ttm . \n Reworked the Velodyne sensors, which are now using the new point cloud object. This means that sensor points can now be  collidable ,  measurable  and  detectable . \n Added three new API functions:  sim.loadImage ,  sim.getScaledImage  and  sim.transformImage . \n Added a model, allowing to start, pause, stop or step a synchronous simulation, from a ROS node. The model is based on the new  ROS Interface  and is located in  Models/tools/rosInterfaceHelperTool.ttm \n An IMU ROS plugin, courtesy of Bartolomeo Della Corte, is available  here . \n \n \n \n V-REP V3.3.0 (February 19th 2016)\n \n Fixed several bugs. Thanks to Federico Ferri, Tiago Malheiro, Raimund Krenmueller, Ahmed Yacine, Matthias Ploner, Indranil Sur, Sung Kyun Kim, Andrew Hundt, Rik Timmers, Matthew Veres and Graeme Neff Wilson for noticing them or helping to resolve them. \n Added  a first version of a plugin that wraps OMPL , the  Open Motion Planning Library . The plugin is courtesy of Federico Ferri. The source code of the plugin is located  here . Following demo scenes are now using the OMPL plugin functionality:  motionPlanningDemo1.ttt ,  motionPlanningAndGraspingDemo.ttt ,  3DoFHolonomicPathPlanning.ttt  and  6DoFHolonomicPathPlanning.ttt ,  motionPlanningServerDemo.ttt . \n Added a new ROS service, ROS publisher type, and ROS subscriber type: simRosCallScriptFunction, simros_strmcmd_receive_data_from_script_function and simros_strmcmd_send_data_to_script_function. These are very useful when a  regular API  function is not immediately available in the RosPlugin, or when a succession of complex commands need to be executed locally. Have a look at the demo scene  rosTopicPublisherAndSubscriber2.ttt , which illustrates the new functionality. \n Improved and corrected the  sim.callScriptFunction  API function. \n sim.loadModule  and  sim.unloadModule  can now also be used from a script, in order to dynamically load/unload a plugin. Certain restrictions apply: in particular, if the plugin registered custom lua functions via simRegisterCustomLuaFunction without specifying the function name as  functionName@pluginName , a crash might occure during the dynamic plugin unload operation. \n Added an API function that allows to compute the Jacobian of an IK group. \n The V-REP source code can now be compiled for headless operation, without any Qt dependency. In that case however, the vision sensors will only generate an image content when the rendering is handled via a plugin (e.g. POV-Ray or and external renderer). \n Added following new API functions:  sim.computeMassAndInertia  and  sim.getExtensionString . \n Added a model of the uArm with gripper and inverse kinematic routine:  Models/robots/non-mobile/uarm with gripper.ttm \n A constrained optimization IK plugin for V-REP, courtesy of Andrew Hundt, is available  here . Installation instructions for Linux / OSX are available  here . \n \n \n \n V-REP V3.2.3 (November 24th 2015)\n \n Fixed several bugs. Thanks to Karol Mocniak, Ana Lucia, Ricardo Azambuja, Diego Daniel Santiago, Graeme Neff Wilson, Anto Ronson and Minson Lee for noticing them or helping to resolve them. \n Added a simulation model of the ABB IRB 4600-40/2.55 robot, courtesy of ABB. The model is located at  Models/robots/non-mobile/ABB IRB 4600-40-255.ttm \n Added a scene illustrating workspace visualization:  scenes/workspace.ttt \n Added several new API functions:  sim.getQHull ,  sim.getDecimatedMesh . \n Added two simple  add-ons  illustrating scene content export/import: minimalisticExporter and minimalisticImporter. \n Improved the convex hull calculation routines. \n Added several convenience functions to morph shapes into their convex hull repesentation, to decimate shapes, and to extract a shape\'s inside. The functions can be accessed with [Menu bar --> Edit --> ...]. \n Added a new  tutorial on building clean and efficient simulation models . This tutorial is a must for everyone who wishes to create his/her own models. \n Simplified the  BubbleRob tutorial . \n Added a section about  joint controllers  and how to implement them within V-REP, or inside of an external application (e.g. a  remote API  client, or a ROS node). \n Added a model of the P-Arm robot, and two of its grippers. The CAD data is courtesy of  F&P Robotics . The models can be found at  models/robots/non-mobile/P-Arm.ttm ,  models/components/grippers/P-Grip-straight.ttm  and  models/components/grippers/P-Grip-right-angle.ttm . \n Added several simple example scenes that illustrate how to use the  kinematics module . The scenes can be found in  scenes/kinematics . \n Updated the webcam plugin for V-REP, using the newest  ESCAPI library . A model using that plugin can be found in  Models/other/webcam.ttm . The source code of the plugin can be found  here . \n Added a simulation model of the Velodyne VPL-16. The model can be found in  Models/components/sensors/velodyne VPL-16.ttm . \n Added a new API function that allows to call a script function from a plugin or another embedded script:  sim.callScriptFunction . \n \n \n \n V-REP V3.2.2 (September 5th 2015)\n \n Fixed several bugs. Thanks to Kshitij Tiwari, Victor Gomez, Martin Pecka, Parker Owan, Raimund krenmüller, Robert Lang, Muhammad Umer Huzaifa, Marshall Floyd, Inkyu Sa, Augusto Gandia, Raimund Krenmüller, Tobias Groll, Wu Xiaojun for noticing them or helping to resolve them. \n Switched to Qt 5.5.0 for the Windows, the MacOS and the Linux versions. \n Reworked many dialogs by adapting the floating-point number display, the unit display, and removing some deprecated/rarely used items. The user interface units are now fixed to degrees, meters, seconds, kilograms, Newtons, etc. to avoid confusions. \n Added an  edit mode for compound shapes . This allows to edit the visual parameters of a compound shape without having to ungroup it. \n Added a possibility to automatically compute the mass and inertia tensor for convex shapes in the  shape dynamic properties . The algorithm is courtesy of Chris Hecker. \n Added a plugin able to render ray-traced images (via vision sensors or via cameras). This will allow to perform more realistic image-based control. The plugin is based on  POV-Ray  and allows rendering shadows (also soft) and focal blur. The ray-tracer plugin is courtesy of Andreu Vidal. The source can be found  here . \n Added a plugin for support of the  Newton Dynamics engine . The plugin is currently a BETA version, and will be improved for next release. The plugin is courtesy of Julio Jerez and Alain Suero. \n Added a plugin that performs the rendering instead of a vision sensor or a camera. The plugin is meant as an example, and its source can be found  here . \n Added a scene that demonstrates the various rendering modes available in V-REP:  scenes/rendererDemo.ttt . \n Modified the way how V-REP interacts with the physics plugin: it is now possible to compile the Bullet, ODE, Vortex or Newton plugins separately. This will greatly simplify adding additional physics engines. \n Modified the legacy remote API Python bindings, including the Python example programs. They should work fine on Python 2.x, Python 3.x and IronPython. \n The  OpenRTM-aist  is now supported thanks to Yuki Suga. Installation instructions are given  here . \n Moved the Qhull functionality out of V-REP\'s main library, into a plugin ( simExtQhull ). The source code can be found  here . \n Moved the convex decomposition functionality out of V-REP\'s main library, into a plugin ( simExtConvexDecompose ). The source code can be found  here . \n The convex decomposition plugin now also offers the V-HACD algorithm (next to the HACD algorithm). Both are courtesy of Khaled Mamou. \n Added a model of a ball balancing robot:  Models/robots/mobile/ball robot.ttm . \n Added a model of the uarm:  Models/robots/non-mobile/uarm.ttm . The CAD data is courtesy of  EVOL . \n Added a model of the RG2 gripper:  Models/components/grippers/RG2.ttm . The CAD data is courtesy of  On Robot ApS . \n Added a demo scene illustrating a grasping task with the UR5 robot and RG2 gripper:  Scenes/ur5WithRg2Grasping.ttt . \n Added a model of a tracked vehicle, courtesy of Qi Wang:  Models/vehicles/tracked vehicle.ttm . \n Updated the screenshot tool in order to be also able to render ray-traced screenshots ( Models/tools/high-res screenshot tool.ttm ). \n The NAO robot can now be controlled via Python and python NAOqi SDK. The project is available  here , and is courtesy of Pierre Jacquot and Gurvan Le Bleis. \n A Xbox 360 controller plugin is available for V-REP  here . The plugin is courtesy of Nicola Di Pol. \n Added a shared memory communication plugin for V-REP, courtesy of Diego Daniel Santiago. The files, including a Simulink example, are located in  programming/sharedMemoryCommunicationPlugin . \n \n \n \n V-REP V3.2.1 (May 4th 2015)\n \n Fixed several bugs. Thanks to Jan Dentler, Robert Lang, Raimund Krenmüller, Cedric Pradalier, Reza Mahjourian, Anuraj Rajendraprakash, Sébastien Granges, Ángel Luis Jiménez García, Leander Hille, Pierre Rouanet, Ulrich Schwesinger, Kenichi Hara, Federico Ferri, Martin Pecka and Nicola Piccinelli for noticing them or helping to resolve them. \n Added 2 classes ( CLuaFunctionData  and  CLuaFunctionDataItem ) that greatly simplify passing arguments to/from custom Lua function created in plugins. The two classes are located in  programming/common  and  programming/include  folders. \n Completely rewrote the Khepera3, the MTB, and the BubbleRob plugins: they have been greatly simplified. \n V-REP now supports the  RRS-1 specifications  via a plugin ( simExtRRS1 ). It allows to connect and interact with all RCS modules and robots that supports the RRS-1 specifications. For an example have a look at the demo file  scenes/RRS-1 demo.ttt . \n Rewrote the  plugin tutorial , which has become much simpler. \n Rewrote the  robot language integration tutorial , which has become much simpler. \n The CHAI3D plugin (for interfacing a haptic device) has been completely rewritten and greatly improved, courtesy of Sébastien Granges. Visit  www.chai3d.org  or  www.forcedimension.com  for the source code of that plugin. In case it is not yet available on those websites, please contact us. \n Added a demon scene that illustrates navigation of a mobile robot via a haptic device ( Scenes/hapticRobot.ttm ). The device will let the user  feel  the obstacles. \n Added an interface plugin to the  OpenMesh  library. The plugin source code is located  here . \n Added a tool model that allows to simplify high-poly shapes:  Models/tools/mesh decimation tool.ttm . The tool relies on the new OpenMesh plugin for V-REP. \n Added a tool model that allows to separate the inside/outside parts of shapes:  Models/tools/mesh inside outside separation tool.ttm . \n Added a demo scene ( Scenes/headlessModeDebug.ttt ) that illustrates how to launch a headless instance of V-REP, connect to it, and stream back the view of the scene. \n Added a model that allows to extract Denavit-Hartenberg parameters in a kinematic chain ( Models/tools/Denavit Hartenberg parameter extractor.ttm ). \n Added a model that allows to create joints in poses defined by Denavit-Hartenberg parameters ( Models/tools/Denavit Hartenberg joint creator.ttm ). \n Added an API function that allows saving images:  sim.saveImage \n Added a model, courtesy of Ulrich Schwesinger, allowing to take high-resolution screenshots of the scene:  Models/tools/high-res screenshot tool . \n Added a model that allows to modify shape colors that are named:  Models/tools/color change tool from color names.ttm . \n Added a model that allows to find the intersection between a plane and a ray:  Models/tools/plane ray intersection finder tool.ttm . \n An example of  Snap!  controlled line follower in V-REP is available  here , courtesy of Ilya Nemihin. \n A small Python programm that allows transferring a  MeshLab  inertia tensor to V-REP is available  here , courtesy of Michael Michalik. \n \n \n V-REP V3.2.0 (February 3rd 2015)\n \n Fixed several bugs. Thanks to Reza Mahjourian, Ben Allan,  Soner Ulun, Robert Lang, Guenter Schreiber, Sven Knüppel, Eva Alves Costa, Lucian Cucu, Sigurd Villumsen, Andrea Censi, Pierre Rouanet, Leander Hille, Christoph Hügle, William Harrison, Robert Lang and Scott Drew Pendleton for noticing them or helping to resolve them. \n Switched to Ubuntu 14.04.1 LTS for Linux versions of V-REP. \n The precompiled ROS items are now specifically meant for ROS Indigo. If you use a different version, make sure to recompile them. \n Switched to Qt 5.4.0 for Linux versions of V-REP. \n Improved the visual appearance of 3D objects by adjusting the way meshes are rendered. This can lead to small differences in color/lighting with previous V-REP releases. You may have to adjust the  ambient light  manually. \n Added backtrace information output, for easier debugging of script code. \n Script colors can now individually be adjusted. See the file  system/usrset.txt . \n Objects can now be selectively  seen  from a given  camera  or  vision sensor . This can be adjusted in the  object common properties . \n High resolution displays (such as  Retina display ) are now fully supported, and should be automatically detected. You can force a different behaviour by adjusting the value of  highResDisplay  in the file  system/usrset.txt .\n Added a model of the Velodyne HDL-64E S2 Lidar:  Models/components/sensors/velodyne HDL-64E S2.ttm . \n Added a model that allows interaction with a haptic device ( Models/other/interface to haptic device.ttm ), courtesy of  Force dimension , Francois Conti ( CHAI3D ) and Julien Tharin. The related plugin project files are located  here . \n Added a model of a customizable office building:  Models/infrastructure/urban/customizable building.ttm . \n Added a model of a paint bomb:  Models/components/modifiers/paint bomb.ttm . \n Added a model that allows to quickly adjust the color of shapes or entire models:  Models/tools/quick shape color tool.ttm . \n Added a model that allows to quickly adjust all the lights in a scene:  Models/tools/quick light adjust tool.ttm . \n A V-REP ROS bridge is available  here , courtesy of Riccardo Spica and Giovanni Claudio. \n Pioneer 3D-X controlled via a visual servoing law  (courtesy of Riccardo Spica and Giovanni Claudio) \n A first backend to integrate ros_control loop in V-REP is available  here , courtesy of Antoine Rennuit. \n Added following new API functions:  sim.switchThread  (now also available from the C API),  sim.packUInt8Table ,  sim.unpackUInt8Table ,  sim.packUInt16Table  and  sim.unpackUInt16Table . \n Added a model that allows to measure the distance between two clicked points in the scene:  models/tools/point-point distance tool.ttm . \n Added a model that allows to measure the normal vector of a clicked surface in the scene:  models/tools/normal vector measurement tool.ttm . \n \n \n V-REP V3.1.3 (October 1st 2014)\n \n Fixed several bugs. Thanks to Renaud Detry, Daniel Lechner, Ulrich Schwesinger, Sven Knüppel, Steve Nguyen, Jonas Sperling, James Besancon, Andrew Vardy, Rodrigo Moreno Garcia, Thomas Estier, Matthias Imle, Daniel Kuhner, José Rosado, Eric Rohmer and Soner Ulun for noticing them or helping to resolve them. \n Improved the embedded  script editor  with following new features: highlighting of all occurrences of selected word, source folding/unfolding, simple word search via the <ctrl+f> key. \n External script editors can now be customized with the data in file  v-rep_notepad++.zip : this allows for keyword highlighting, auto-completion and call tip display. \n Improved the shape serialization routines, effectively reducing generated file sizes, mainly if they contain duplicate geometric content.  The generated file format cannot be read by previous V-REP versions (prior to V-REP 3.1.3), so make sure to make backup copies . \n Added a new type of  embedded script :  customization scripts . They are associated with  scene objects  (same as  child scripts ) and can be used to customize a simulation scene to a great extent. The main difference with child scripts is that customization scripts are running all the time, also when simulation is not running. \n Added several models that demonstrate the new  customization script  functionality:  Models/nature/terrain bump.ttm ,  Models/nature/Terrain.ttm ,  Models/nature/Tree.ttm ,  Models/infrastructure/other/resizable concret block.ttm ,  Models/infrastructure/floors/resizable floor*.ttm ,  Models/tools/playback tool.ttm ,  Models/tools/isometric scaling tool.ttm ,  Models/tools/name change tool.ttm ,  Models/tools/custom data viewer tool.ttm ,  Models/equipment/conveyor belts/customizable conveyor belt.ttm ,  Models/furniture/tables/customizable table.ttm . \n Modified  the way  child scripts  are handled in order to make them operate in a more coherent manner: \n   child scripts  execution is now automatically cascaded (i.e. no need to explicitely call simHandleChildScript anymore). \n  child scripts are now executed in the  actuation  phase as well as in the  sensing  phase of a given simulation step: there is no distinction anymore with what previously used to be  sensing child scripts . \n  script compatibility with previous file versions is guaranteed by  1)  automatic child script code modification (clearly marked as such),  2)  automatic  main script  replacement. This covers 99% of all situations, but it can happen that this automatic modification partly fails (e.g. when the main script was customized, or when explicitely executing a specific child script (previously marked as  explicit handling )). In that case,  contact us  for assistance. \n Improved the rendering speed. If compatibility issues arise, please  contact us , and try to disable  VBO operation   here . \n Improved the start-up time of certain simulation scenes, by adding a broad mode for collision detection, minimum distance calculation and proximity sensor detection: Oriented Bounding Box (i.e. OBB) data structures are now only computed on-the-fly and only when absolutely necessary. This can be visualized via [Menu bar --> Help --> Debug --> Visualize prepared OBB calculation structures]. \n Added 3 new API functions:  sim.copyPasteObjects ,  sim.scaleObjects  and  sim.removeModel . simCopyPasteSelectedObjects, simScaleSelectedObjects and simDeleteSelectedObjects are declared deprecated. \n Added project files for custom ROS plugins for V-REP (i.e. in order to support specific ROS messages of a specific robot).  \n Added a model of the Robotnik Summit XL robot, courtesy of Roberto Guzman:  Models/robots/mobile/Robotnik_Summit_XL_140701.ttm \n Improved the undo/redo functionality that now operates in a more consistent manner. Camera movements are not considered as undo points anymore. This behaviour can be adjusted via the user settings file  system/usrset.txt . \n The API functions  sim.readCustomDataBlock  and  sim.writeCustomDataBlock  can now also be used to attach custom data to scripts. At the same time you can now also specify whether the data should be saved during a  scene or model save operation. \n The vision sensor code has been optimized and vision sensors now run faster. They now can also operate in a different mode, in order to simulate the temperature of objects for instance, or in order to detect object handles. \n Added several new API functions:  sim.getObjectsInTree ,  sim.scaleObject  (i.e. non-isometric scaling),  sim.getShapeTextureId ,  sim.setShapeTexture ,  sim.getCollectionObjects ,  sim.handleChildScripts  and  sim.reorientShapeBoundingBox . \n Added a  SLAM demo based on ROS , courtesy of Leopoldo Armesto. \n Added a link to a  tutorial on teaching robotics with a simulator , courtesy of Prof. Renaud Detry. \n Added a link to a  Python quadrotor simulator , courtesy of B. Acharya, F. Gisa, and S. D. Levy. \n Added a link to the  TAPIR implementation of the Adaptive Belief Tree (ABT) algorithm , courtesy of Hanna Kurniawati, Dimitri Klimenko, Joshua Mun Song and Vinay Yadav. \n The middle mouse button can now be deactivated in order to not react to a press action. This can be done in the user settings file in  system/usrset.txt . \n Added an interface model to the Arduino Esplora, located in  Models/other/Arduina Esplora.ttm . The model is courtesy of Eric Rohmer. \n Added a function that allows to  link two dynamic joints  (i.e. a force/torque applied to one will be transmitted to the other one, and vice-versa). This allows to simulate complex gear mechanisms, without the need to simulate the gear contacts. This feature is currently only supported via the  Vortex plugin . \n Added a demo scene that illustrates how to simulate gear mechanisms with Vortex:  scenes/gearMechanism.ttt . \n Changed the camera navigation method: camera rotations are now performed with the middle mouse button, instead of the right mouse button (which was, to many, confusing and not practical). The right mouse button is now exclusively reserved for pop-up menus. The previous navigation method can still be enabled via the variables  navigationBackwardCompatibility  and  middleMouseButtonSwitchesModes  in the  system/usrset.txt  file, but this is not recommended since this option will probably disappear in future. \n Added a play back tool, that allows you to manually step through a simulation. The model file is located in  Models/tools/playback tool.ttm . \n \n \n V-REP V3.1.2 (June 17th 2014)\n \n Fixed several bugs. Thanks to Matt Derry, Daniel Morberg, Andreas Kuhner,  Danilo Vasconcellos Vargas,  Spencer Krause,  Daniel Kuhner, Luigi Ferri,  Filip Jares,  Michaela Richter,  Matthias Schindler and Ulrich Schwesinger for noticing them or helping to resolve them. \n Fixed a bug of the PID joint controller: in older V-REP versions, the I and D parameters had to be wrongly scaled in order to obtain the correct behaviour. The controller was now fixed and parameters are automatically scaled to a correct value when loading older file versions. Custom joint callback controllers will have to be adjusted manually if they make use of the I or D parameters. \n The  joint dynamics properties  have been reorganized in order to facilitate the creation of spring-damper systems, by allowing to directly specify the spring constant  K  and its damping coefficient  C . \n Matlab versions previous to 2008a might be supported via the files located  here , courtesy of Gerold Huber. \n The RosPlugin was catkinized, courtesy of Arne Hitzmann and Sergi Foix. \n V-REP now also supports 3D OpenGL stereo mode (for dedicated hardware, i.e. specific stereo-enabled graphic cards with corresponding monitor/device). To enable it, set a value different from 0 for   stereoDist  in file  system/usrset.txt . The console should indicate at start-up if the mode was successfully enabled. Make sure to correctly configure your graphic card (i.e. 3D OpenGL stereo & correct stereo display mode). \n Added a simulation model of the Baxter robot, including its vacuum cup and gripper tools:  models/robots/non-mobile/Baxter.ttm ,  models/components/grippers/Baxter vacuum cup.ttm  and  models/components/grippers/Baxter gripper.ttm . The original CAD data is courtesy of Rethink Robotics. \n Added a simulation model of the Phantom X Pincher:  models/robots/non-mobilePhantomXPincher.ttm . The original CAD data is courtesy of Trossen Robotics. \n Added models of a generic revolute motor, a generic revolute servo (with and without backslash), a generic revolute spring-damper, and a generic prismatic motor. They are located in the  models/components/actuators/  folder. \n Improved the OBJ file format importer. \n Switched to an updated Vortex library (V6.1.2) that offers an improved contact generation. \n Added a simulation model that allows visualizing the center of mass of a dynamic model:  models/other/center of mass visualizer.ttm . \n Added a new API function to retrieve geometric information about shapes:  sim.getShapeGeomInfo . \n Added a new API function that helps to make a motion planning transition from one configuration to another, by following a predefined Cartesian space path. This is useful for redundant manipulators, but also for safely driving  non-redundant manipulators via IK through a singular configuration: simGetMpConfigTransition. \n simRMLPosition and simRMLVelocity are declared deprecated and are replaced by following API functions:  sim.ruckigPos ,  sim.ruckigVel ,  sim.ruckigStep  and  sim.ruckigRemove . \n Added a simulation model of the Adept Quattro 650HS parallel manipulator, courtesy of Preben Hjornet:  models/robots/non-mobile/Adept Quattro 650HS.ttm . The original CAD data is courtesy of Adept Technology. \n Added a plugin that implements shared memory communication, courtesy of Diego Daniel Santiago. The source code, currently only running on Windows, is located  here . \n \n \n V-REP V3.1.1 (March 27th 2014)\n \n Fixed several bugs. Thanks to Stéphane Magnenat, Ulrich Schwesinger, Philipp Krüsi,  Pascal Gohl, Klaus Raizer, Paulo Gurgel,  Marco Bellaccini, Gianpaolo Gonnelli, Felix Herrmann,  Edgar Virga,   Josep Tormo Costa,  Gaël Ecorchard, Renaud Detry, Marc Durvaux, Robert Lang and Alexander Rietzler for noticing them or helping to resolve them. \n Added  simulation models of the new KUKA LBR IIWA robots:  models/robots/non-mobile/KUKA LBR4 iiwa 7 R800.ttm  and  models/robots/non-mobile/KUKA LBR4 iiwa 14 R820.ttm \n Added a simulation model of the Pioneer P3DX robot, courtesy of Eric Rohmer and Joost a.k.a. J-m@n:  models/robots/mobile/pioneer p3dx.ttm \n Added a simulation model of the Jaco manipulator, courtesy of Eric Rohmer and Kinova Robotics for the CAD data:  models/robots/non-mobile/Jaco arm.ttm  and  models/components/grippers/Jaco hand.ttm . \n Added a simulation model of the Mico manipulator, courtesy of Eric Rohmer and Kinova Robotics for the CAD data:  models/robots/non-mobile/Mico arm.ttm  and  models/components/grippers/Mico hand.ttm . \n Added preliminary simulation models of the UR5 and UR10 robots, courtesy of Universal Robots for the CAD data:  models/robots/non-mobile/UR5.ttm  and  models/robots/non-mobile/UR10.ttm . \n The simulation model of the Kuka LBR4+ was updated by Massimo Cefalo, in order to beahve more like the real one (adjusted masses and inertias). \n Added new API functions to control the material of a shape: simGetMaterialId, simGetShapeMaterial and  sim.setShapeMaterial . \n Added new API functions to create and modify textures:  sim.getTextureId ,  sim.readTexture ,  sim.writeTexture ,  sim.createTexture . \n Added new API functions related to motion planning: simSimplifyMpPath and simFindIkPath. \n Completed the documentation of the motion planning functionality. \n Added new API functions that allow to easily store custom data inside of scene objects, or inside of a scene file:  sim.writeCustomDataBlock  and  sim.readCustomDataBlock . \n Added a new simulation scene that illustrates motion planning and grasping:  scenes/motionPlanningAndGraspingDemo.ttt . \n Added a new plugin ( simExtVision ) in charge of various tasks. Currently, it exports 2 custom Lua function to handle spherical vision sensors and anaglyph stereo cameras. The plugin source code is located  here . \n Added a simulation model of a spherical camera, which features a 360x180 view of the scene:  models/components/sensors/spherical vision sensor.ttm . \n Added a simulation model of an anaglyph stereo camera, which generates anaglyphic images (e.g. red-cyan coded images):  models/components/sensors/anaglyph stereo vision.ttm . \n \n \n V-REP V3.1.0 (January 20th 2014)\n \n Switched to Qt5.2.0  for the Mac and Linux releases, which solved a few open glitches/bugs. The Windows release is still running under Qt5.1.1. \n Fixed several bugs. Thanks to Matthias Schindler,  Renaud Detry and Ulrich Schwesinger for noticing them. \n Added a scene that illustrates the new ghost recorder functionality:  ghostDemo.ttt .\n Added two models that illustrate the new ghost recorder functionality:  Models/other/ghostRecorder.ttm  and  Models/other/ghostTracer.ttm \n Added a file-menu item that allows easily loading recently opened scene files. \n simLockInterface is declared deprecated and has no effect anymore. \n Added a model of a basket:  Models/infrastructure/other/largeBasket.ttm . \n Added a  Debug  menu item in the  Help  menu. This allows displaying various debug information to the console or a file, or running the simulator in special modes. \n Added a laserscan and odometry publisher to the RosPlugin, together with a laser scanner model prepared for ROS: models/components/sensors/Hokuyo_URG_04LX_UG01_ROS.ttm. The code modification and the model are both courtesy of George Moustris. \n Added following  regular API  functions:  sim.quitSimulator . \n Added the option to run V-REP headless (without any graphical user interface (i.e. in the command line only)), as well as other  command line options . The graphics libraries are still needed. A binary that doesn\'t rely of graphics libraries is planned. \n Added a bridge to  OpenCV  via a plugin, courtesy of Marco Bellaccini. The files are located  here . \n Added a first version of a Labview interface for the legacy remote API, courtesy of Peter Mačička. \n \n \n V-REP V3.0.5 (October 27th 2013)\n \n Switched to Qt5.1.1. Many changes and refactorings were made, and are still ongoing.  \n Added optional support for  high fidelity physics with the  Vortex Studio engine . Thanks to Martin Courchesne and  SimWat  for their plugin implementation. The plugin will gradually be improved in order to support simulation requirements in various fields (fluids, particles, etc.). \n Added a motion planning functionality, that allows to plan movement sequences of kinematic chains, in a clutered environment. The documentation on this is unfortunately not yet very exhaustive, make sure to refer to the motion planning dialog and the related API functions.  \n Added 3 scenes to illustrate the new motion planning functionality:  motionPlanningDemo1.ttt ,  motionPlanningDemo2.ttt  and  motionPlanningDemo3.ttt .  \n Added a simulation model of the SICK TiM310 laser scanner:  models/components/sensors/SICK TiM310 Fast.ttm \n Fixed several minor bugs. Thanks to Billy Newman, Ruediger Dehmel, Renaud Detry, Roband and Hendrik Wiese for noticing them, and even providing patches. \n Added a simulation model of a generic GPS sensor:  models/components/sensors/GPS.ttm \n Following texture file formats are now supported: JPEG, PNG, TGA, BMP, TIFF & GIF. Thanks to Sean Barrett for his image loading routines (used for GIF and TGA). \n Adjusted all default light intensities and default object colors (ambient component only) in order to be more compatible with other CAD applications. Older scenes and models will automatically adjust for that during a load operation (i.e. light intensities will be scaled by 0.675, colors by 1.5). If you do not wish for this automatic adjustment, turn variable  correctColorsAndLights  to false in  system/usrset.txt . \n Added a ROS publisher for  vision sensor  depth data as RGBD point cloud, courtesy of Cedric Pradalier. \n Added a  possibility to create negative volumes  (i.e. holes) in pure shapes, for efficient dynamic simulation of tubes or pipes for instance. \n Fixed a bug affecting the  regular API  function  sim.getObjectVelocity . \n Added more predefined  page configurations . \n Added a gamepad interface to the RosPlugin. The code is courtesy of Roberto Marino. \n Added a model of a buggy with suspension and differential:  models/vehicles/manta with differential.ttm . The model is courtesy of Qi Wang. \n Added a  full screen mode . \n \n V-REP V3.0.4 (July 8th 2013) \n Fixed several minor bugs. Thanks to Brian Yeomans,  Kiyoshi Irie, Ulrich Schwesinger,  David Butterworth and Xinyu Zhang. \n Added the possibility for  vision sensors  to ignore their RGB or depth information. When used, this allows to accelerate vision sensor operation. Refer to the  vision sensor properties . \n Added two new vision sensor filters. The first allows to extract coordinates from a vision sensor depth map. This allows to create fast laser scanner models, such as  models/components/sensors/Hokuyo URG 04LX UG01_Fast.ttm  or  models/components/sensors/3D laser scanner Fast.ttm . The second added vision sensor filter allows to track individual pixel changes, such as in the model  models/components/sensors/DVS128.ttm , courtesy of  IniLabs . \n Added a new demo scene:  fabricationBlocks.ttt \n Added several fabrication/transformation block models, that can be combined with each other to simulate complex fabrication processes (see the demo scene  fabricationBlocks.ttt ). The new models are located in  models/examples/block factory . \n Added a new model:  models/components/sensors/push button.ttm \n Added a new gripper model courtesy of  ROBOTIQ :  models/components/grippers/ROBOTIQ 85.ttm \n Added a simulation model of the SICK S300 laser scanner:  models/components/sensors/SICK S300 Fast.ttm \n Added a simulation model of the KUKA Omnirob robot:  models/robots/mobile/KUKA Omnirob.ttm \n Added a simulation model of the KUKA LBR4+ robot:  models/robots/non-mobile/KUKA LBR4+.ttm \n Added a simulation model of the Kilobot, together with its controller model:  models/robots/mobile/Kilobot.ttm  and  models/robots/mobile/Kilobot_Controller.ttm . The models are courtesy of K-Team. \n Added new wall models, in 3 different heights: 240cm, 80cm and 20cm. They are located in  models/infrastructure/walls \n Removed the annoying watermark appearing when recording a movie ( Simulated with V-REP ) \n \n V-REP V3.0.3 (April 29th 2013) \n Fixed a bug created in release 3.0.2: pure shapes would see their  Bullet custom collision margin scalings  set to a non-default value automatically. Thanks to Geerten Doornenbal and others for reporting this. \n Fixed several minor bugs. Thanks to Qi Wang, Giordano and Karl Robillard.\n\n Added also following new  regular API  functions:  sim.getJointMode ,  sim.getJointTargetPosition  and  sim.getJointTargetVelocity . \n Added 3 new  object parameter IDs  (3020-3022) that allow setting the initial rotational velocity of a dynamically enabled  shape . \n Added a  toolbar button  that facilitates object/model re-instanciation: this allows modifying in a same way an unlimited number of same robots. \n Added a  tutorial about a line following robot , courtesy of Eric Rohmer. \n Added two new API functions: simEnableWorkThreads and simWaitForWorkThreads. They allow to execute sensing operations concurrently (i.e. in parallel), taking advantage of several processor cores. By default the functionality is turned off. It can be turned on via the  user settings dialog , the variable  workThreadCount  in file  system/usrset.txt , or programmatically via  sim.setInt32Param (sim.intparam_work_thread_count,coreCount). Refer also to the default  main script , that was slightly modified to accomodate for that. \n Added a new model:  models/other/timing info.ttm . It allows to quickly have an overview of the time spent in the various calculations. \n Added a new model:  models/other/joint recorder.ttm . It allows to record the joint movements of a model, then to play them back. \n Added a new model:  models/robots/mobile/NAO.ttm . The model is courtesy of Marco Cognetti, the mesh  and movement data is courtesy of Aldebaran. The model is a first example model of NAO, an improved version should follow in next release. \n Added following new RosPlugin services/publishers: simRosGetAndClearStringSignal and simRosCreateDummy. \n \n V-REP V3.0.2 (March 14th 2013) \n Corrected a bug related to convex shapes \n Improved the  URDF importer  (scaling is now taken into account and rpy mix-up  (different rotation multiplication order) was also fixed). Thanks to Barrett Ames and Luca Marchionni for pointing that out. \n Added a new  regular API  function:  sim.getObjectVelocity  (slightly different from the already existing  sim.getVelocity  function). \n Added a new RosPlugin service: simrosAppendStringSignal. This allows to easily send data that is automatically buffered on V-REP. \n Added some testing / adjustment mechanisms to improve rendering performance on certain graphic cards / platform combinations. Thanks to Cedric Pradalier for intensive testing. Refer to the system/usrset.txt file. \n Corrected various bugs. Thanks to Arnaud Leleve, Geerten Doornenbal, Pouya Mohammadi, Nikolaus Wittenstein, Ayberk Ozgur. \n Replaced the old convex hull calculation routines with the  Qhull  routines, courtesy of Brad Barber. \n Added a few new  shortcut keys . \n Added an example Ackermann steering vehicle: models/examples/simple Ackermann steering.ttm \n Added two transceiver models: models/components/sensors/transceiver.ttm and models/components/sensors/directionalTransceiver.ttm \n Added several mechanisms allowing to execute sensing operations concurrently (i.e. in parallel), taking advantage of several processor cores. By default the functionality is turned off, since still in development phase. It can be turned on via the variable  workThreadCount  in file  system/usrset.txt , or programmatically via  sim.setInt32Param ( sim.intparam_work_thread_count ,coreCount). Refer also to the default  main script , that was slightly modified to accomodate for that. \n \n V-REP V3.0.1 (January 20th 2013) \n Convex shapes  are now also directly supported in V-REP. We however still recommend using only pure shapes for dynamic simulations. \n Added a  convex decomposition function  (routines courtesy of Khaled Mamou) \n Added one new  regular API  function:  sim.convexDecompose . \n The  URDF importer  is now in an advanced beta stage. \n \n V-REP V3.0.0 (January 10th 2013) \n V-REP is now  open source ! All source code of V-REP or any related item can be downloaded, modified and compiled. Make sure to read the  licensing conditions . \n V-REP comes now is several flavours: \n  V-REP PRO EDU (educational version. No limitation and Free). Can be used by hobbyists, students, teachers, professors, schools and Universities. Make sure to read the  licensing conditions . \n  V-REP PRO (commercial version) \n  V-REP PLAYER (free player version) \n Collada importer/exporter plugin \n URDF importer plugin , courtesy of Ignacio Tartavull \n Added 4 new  regular API  functions:  sim.createForceSensor ,  sim.createProximitySensor ,  sim.createVisionSensor  and  sim.importShape . \n Added a  quick textures  button to the  shape properties : it allows for instance to quickly apply a "dirt" texture to several shapes, in order to make them appear more realistic. \n New demo scene: proximitySensorDemo.ttt \n \n V-REP V2.6.8 (December 2nd 2012) \n Add-ons  are now supported: they can run in the background, or be called as a function, when needed \n Added  sim.createDummy . \n Textured shapes can now also be grouped \n The bounding box of  pure compound shapes  can now also be reoriented \n The  shape dynamics properties  dialog allows now specifying non-diagonal inertia matrices relative to a specific reference frame.\n Shape grouping will now correctly compute the combined inertia matrix for the group. \n Added 2 new  regular API  functions:  sim.groupShapes  and  sim.ungroupShape . \n Added more than 80 new functions, only available from the C/C++ interface, that extend functionality and allow faster data access. \n Serialization version is now 16. Earlier files can still be loaded, but V-REP versions 2.6.7 and earlier cannot load this new fileformat. \n \n V-REP V2.6.7 (September 20th 2012) \n Added a new ROS service, and ROS subscriber type: simRosSetJointState and simros_strmcmd_set_joint_state. They allow to set several joints\' states at the same time. \n Added following ROS publisher/subscriber types (courtesy of Cedric Pradalier): simros_strmcmd_get_range_finder_data, simros_strmcmd_get_transform, simros_strmcmd_get_twist_status, simros_strmcmd_get_vision_sensor_info, and simros_strmcmd_set_twist_command. \n Converted the simExtMTB plugin to a Qt project. Source files are located  here . Refer to the  section on plugins  for details how to compile this plugin. The plugin binary is in the main directory. \n Converted the mtbServer application to a cross-platform project. Source files are located  here . The executable binary is in the main directory. \n Added a project that demonstrates the  Coppelia kinematics routines  functionality. \n An external editor for V-REP\'s embedded scripts can now be used. Refer to the  user settings . \n Additional texture mapping methods have been implemented: cylinder-, sphere-, or box-mapping. Refer to the  texture dialog  for details. \n The linux version of V-REP comes now in 32 or 64 bit. \n Added 2 new functions to handle object/joint motion from a threaded script: sim.rmlMoveToPosition and sim.rmlMoveToJointPositions \n \n V-REP V2.6.6 (August 20th 2012) \n The RosPlugin is now fully operational and offers 100 services, 30 publisher types and 25 subscriber types. The plugin is fully open source and can easily be adapted to various projects if needed. Have a look at the  ROS tutorial  for a quick start. \n Integrated the  Reflexxes Motion Library  type IV via a plugin. Have a look at the related demo scene: "reflexxesMotionLibraryType4Demo.ttt" \n Added 4 new API functions:  sim.getObjectQuaternion ,  sim.setObjectQuaternion ,  sim.buildMatrixQ  and  sim.getQuaternionFromMatrix  (internally V-REP used quaternions since always, but only  Euler angles  could be accessed) \n Added an option to colorize items in the scene hierarchy, for quicker identification \n New scene: "reflexxesMotionLibraryType4Demo.ttt" \n New model: "kinect - closest point calculation.ttm" \n Added a new tutorial:  ROS tutorial . \n \n V-REP V2.6.5 (July 7th 2012) \n Fixed a few bugs related to the Linux/Mac version of the legacy remote API \n Added a new  toolbar button  to handle object assembling/disassembling. The way two objects assemble via this toolbar button can be adjusted in the  object common properties   (Assembling button) \n Added a first interface to ROS. This version is temporary and will be updated in next release \n \n V-REP V2.6.4 (May 23rd 2012) \n Serial port functions:  sim.serialOpen ,  sim.serialClose ,  sim.serialSend ,  sim.serialRead  and  sim.serialCheck . \n The serial port functionality is now also operational on the Mac and Linux platforms \n Fixed a bug where icons would not appear on systems with an old or non-accelerated graphic card \n Added a new integer parameter:   sim.intparam_scene_unique_id \n Added a new event callback message:   sim_message_eventcallback_mainscriptabouttobecalled \n \n V-REP V2.6.3 (April 10th 2012) \n First release that is also available on the Linux platform (Ubuntu is preferred). The Mac and Linux versions are however still flagged as early beta releases \n Added a new  status bar \n Reworked the  coordinates and transformation dialog , as well as the  method of moving object/items \n Modified the way objects/items get selected when no key combination is used: objects get selected at mouse button release if the mouse didn\'t move. This makes it more convenient to navigate with the camera without always losing the object selection state \n Added a checker background in the OpenGl-based custom UI edit mode \n Added a new video compression library used by V-REP\'s  video recorder , based on the  FFmpeg library . Click  here  for related credits \n The player version of V-REP has now been enabled to display the  user settings dialog , and the  layer selection dialog .  Scripts  can now also be edited from within the player version of V-REP \n \n V-REP V2.6.2 (March 18th 2012) \n Since this release, the concept of "simulator instances"  has been abandonned for the concept of "scenes". Functionality basically stays same, but now matches the standard approach. An unlimited number of  scenes  can now be opened, also in the player version of V-REP \n Tree elements in the  scene hierarchy  can now be drag-and-dropped onto other objects for convenient parent-child relationship building (similar to [Menu bar --> Edit --> Make last selected object parent] or [Menu bar --> Edit --> Make last selected object(s) orphan]) \n All  scene hierarchy  icons have been redesigned \n All  toolbar buttons  have been redesigned \n The  scene hierarchy  now also visualizes all opened scenes, and switching between scenes is achieved with a simple click \n A new page selector was implemented, allowing to quickly visualize and select from all available  pages  of a given scene \n A new  scene selector  was implemented, allowing to quickly visualize and select from all available opened scenes \n The  model browser  has been reworked and now uses 24-bit colors for displaying  model  thumbnails \n OpenGl-based custom UIs can now be saved and loaded separately, in a similar way as models are loaded /saved \n Added 3 new API functions:  simCloseScene , simLoadUI and simSaveUI \n \n V-REP V2.6.1 (February 28th 2012) \n First release that is also available on the Mac platform. The Mac release is however still a Beta release where several items are not yet fully supported. \n Added an auto-save functionality. It can be turned on/off in the  user settings dialog . \n Fixed a bug in which V-REP would crash after an undo operation in certain conditions. \n Color-coded objects in the  dynamic content visualization mode . \n Added a parameter to the user settings file (system/usrset.txt) that allows to adjust the GUI font size: guiFontSize_Win \n Added a new integer parameter to detect the platform V-REP is running on:  sim.intparam_platform \n New model: "spring-damper.ttm" \n New model: "motorbike.ttm" \n \n V-REP V2.6.0 (January 27th 2012) \n This release too underwent heavy internal changes in preparation for support of other platforms (Mac and Linux). Please inform us as soon as possible in case of unexpected behaviour with this release. Thanks! \n All dialogs and user interfaces have been completely rewritten/redesigned/reorganized. They now all rely on the  Qt framework \n The application main loop (i.e. the default  main client application ) has been simplified and prepared for separate GUI thread functionality. The rendering of the scene is now handled internally. Following functions were added:  simRunSimulator ,  simGetMainWindow ,  sim.loadModule ,  sim.unloadModule . Following functions were removed: simLaunchSimulator, simEndSimulator, simRenderScene, simHandleWindowMessages, simGetInstanceIndex, simGetVisibleInstanceIndex, simSwitchToInstance, simEmptyScene, simRegisterModuleName and simRegisterEventCallback. \n Added following values:  sim_message_eventcallback_guipass ,  sim_message_simulation_start_resume_request ,  sim_message_simulation_pause_request ,  sim_message_simulation_stop_request ,  sim.intparam_qt_version ,  sim.floatparam_rand . Following value is now also writable:  sim.boolparam_console_visible \n Adjusted/adapted all V-REP plugins: since this release,  plugins  should dynamically bind to the V-REP library. The task is simplified with two files distributed with V-REP: "simLib.h" and "simLib.cpp". This reduces compatibility problems linked to working with various compilers. Old plugins should be slightly modified: it is recommended to adjust old plugins in a similar way as was done for the "BubbleRob" plugin project, located in the "c_examples" directory of V-REP\'s installation directory. If you are having difficulties adjusting your plugin code, please contact us for assistance. \n Fixed a bug linked to the click-and-select functionality. \n Added several pre-configured simulation settings (e.g. physics engine settings or simulation time step settings). The user can conveniently modify them in the  toolbar . \n Added an option for turning dialogs semi-transparent when they loose focus. \n Added a toolbar button to quickly visualize a scene\'s dynamic content (enabled during simulation only) \n Added a plugin that allows to interface joysticks: simExtJoystick.dll. Like with almost all V-REP plugins, the source code can be requested if not already distributed with V-REP. \n \n V-REP V2.5.12 (December 6th 2011) \n This release too underwent heavy internal changes in preparation for support of other platforms (Mac and Linux). Please inform us as soon as possible in case of unexpected behaviour with this release. Thanks! \n Improved the undo/redo functionality: undo points are now set 10-20 times faster as in previous releases, which greatly improves scene edition with large scenes. \n The undo/redo functionality can now also be accessed via the ctrl-z and ctrl-y keys \n Changed the splash screen and the about dialog \n Since this release, it is not possible anymore to run several simulations in parallel (in different instances). This limitation greatly simplifies programming of  plugins . Most old plugins should still be working, but some might need some simple adjustments. *Refer to the section below for quick instructions of modifications required. \n simGetInstanceIndex, simGetVisibleInstanceIndex and simSwitchToInstance are declared deprecated and should not be used anymore. \n Simplified and improved the plugin  event messages \n Removed following event callback messages: sim_message_object_added_or_removed, sim.message_object_selection_changed, sim.message_scene_loaded, sim_message_menu_item_selected, sim_message_eventcallback_objectscaled, sim_message_eventcallback_objectabouttobeerased, sim_message_eventcallback_objecterased and sim_message_eventcallback_objectcreated. The same functionality can be obtained with the improved  sim_message_eventcallback_instancepass event callback message . This results in faster loading operation for large scenes, and simplifies programming of  plugins . *Refer to the section below for quick instructions of modifications required. \n Renamed rendering sensors. They are now called  vision sensors , and all  related API functions , API constants or references have been renamed. The old API functions and constants are kept operational for backward compatibility. \n Added an option to allow for local lights (i.e. lights activated only with flagged cameras). Refer to the  light dialog , the  camera dialog  and the  vision sensor properties . \n Added a new toolbar button to automatically adjust the main view to the scene, or selected objects \n Added a new API function:  sim.cameraFitToView  (click  here  for a simulation that illustrates what kind of camera movement can be achieved with that function) \n Added a new API function:  sim.isHandle . \n Added following API functions:  sim.persistentDataWrite  and  sim.persistentDataRead . \n Added a new item in the  object common properties  ("ignored for view-fitting") \n New model: "auto fitting camera.ttm" \n Removed scene: "youBotDemo.ttt" \n \n *Most old plugins will not need any modification. It is however recommended to adjust the plugin\'s "simMessage" function in a similar way as was done for the "BubbleRob" plugin project, located in the "c_examples" directory of V-REP\'s installation directory. If you are having difficulties adjusting your plugin code, please contact us for assistance. \n \n V-REP V2.5.11 (November 13th 2011) \n This is a bug fixing release. In version 2.5.10, when opening dialogs, V-REP could crash or freeze. This was fixed \n \n V-REP V2.5.10 (October 21st 2011) \n This release underwent heavy internal changes in preparation for support of other platforms (Mac and Linux). Please inform us as soon as possible in case of unexpected behaviour with this release. Thanks! \n Removed the object common property  visible . This option was a little bit confusing, and now  objects  can still be made invisible by moving them into a hidden  layer \n Removed the object common property  wireframe \n Added a  wireframe  option in the  shape properties \n Removed the shape tracing option in order to simplify the  shape properties . Shape tracing can still be achieved with appropriate function calls (e.g. see the "tracer" model) \n simResetTracing and simHandleTracing  API functions  were declared deprecated \n The  shape properties  were further simplified by encapsulating the shape calculation structure parameters in a separate dialog \n Added new  object parameter IDs \n Following  API functions  are now also available from the Lua side: simAddSceneCustomData, simGetSceneCustomData, simAddObjectCustomData and simGetObjectCustomData \n New model: "laser pointer.ttm" \n New model: "tracer.ttm" \n New model: "custom data viewer.ttm" \n New model: "reference frame.ttm" \n New model: "Accelerometer.ttm" \n New model: "GyroSensor.ttm" \n \n V-REP V2.5.9 (September 3rd 2011) \n Added support for skyboxes \n Added an option to hide all edges in a specific  view  (view popup menu) \n Added an option to display thin or thick edges in a specific  view  (view popup menu) \n Added an option to hide the  information and status text  when  recording a movie \n Added two entries in the configuration file ("usrset.txt") that allow to specify the desired resolution for a  movie recording . ("movieRecordingResolutionX" and "movieRecordingResolutionY") \n Added a light concrete texture to all floors \n New model: "5mX5m metallic floor.ttm" \n New model: "5mX5m concrete floor.ttm" \n New model: "kinect.ttm" (there is already a kinect model for interfacing with the real device. This model is just a simulated device) \n New model: "blue sky skybox.ttm" \n New model: "felt pen.ttm" \n New model: "ant hexapod.ttm" \n \n V-REP V2.5.8 (July 20th 2011) \n Improved the  sim.addParticleObject  function to also support linear and quadratic drag parameters \n New API functions:  sim.getArrayParam  and  sim.setArrayParam \n Temporarily removed following commands to facilitate a move towards other platforms: simAttachCustomMenu, simRemoveCustomMenu, simCreateCustomToolbar, simSetCustomToolbarState, simRemoveCustomToolbar, simGetWindowMessage, simProcessWindowMessage \n Removed the "SimpleCustomClientApplication" project files \n Added more fog parameters \n Added new  int parameters : sim.intparam_infotext_style and sim.intparam_settings \n Added new  array parameters : sim.arrayparam_gravity, sim.arrayparam_fog, sim.arrayparam_fog_color, sim.arrayparam_background_color1, sim.arrayparam_background_color2 and sim.arrayparam_ambient_light \n Added new  bool parameters : sim.boolparam_display_enabled, sim.boolparam_infotext_visible, sim.boolparam_statustext_open and sim.boolparam_fog_enabled \n Added new  object parameter IDs \n Added a new  vision sensor  filter component: blob detection \n New  joints  added to the  scene  are in dynamic mode by default since this release \n Added two entries in the configuration file ("usrset.txt") that allows to correct display problems with specific graphic cards / systems: "renderingSurfaceVShift" and "renderingSurfaceVResize" \n New scene: "blobDetectionWithPickAndPlace.ttt" \n New scene: "youBotAndHanoiTower.ttt \n New model: "fast simulation mode.ttm" \n New model: "water surface.ttm" \n New model: "ABB IRB 360.ttm" \n New model: "Blob detection camera.ttm" \n Removed scene: "camFollower.ttt" \n Removed scene: "deltaFKDecomposed.ttt" \n Removed scene: "lineTracer-nonThreaded.ttt" \n Removed scene: "parallelManipulator1.ttt" \n Removed scene: "parallelManipulator2.ttt" \n Removed scene: "pickAndPlace.ttt" \n Removed scene: "mobileRobotDr20.ttt" \n Removed scene: "transmission.ttt" \n \n V-REP V2.5.7 (June 25th 2011) \n Since this release,  models  do not required to have a  dummy  object as base object anymore (any  object  can be "model base" now). This tremendously improves the way models can be combined, with much less effort (e.g. just select a gripper, then a robot, and click [Menu bar --> Edit --> Make Last Selected Object Parent]: the resulting model is fully operational) \n Reworked almost all models to take advantage of the improved model combination possibility (see here above) \n Reworked, actualized and improved the  "robot language interpreter integration" tutorial \n Added an application and project files that allow retrieving data from the kinect device (\'kinectServer\') \n New tutorial:  "External controller tutorial" \n New scene: "robotLanguageControl.ttt" \n Removed model: "MTA robot.ttm" \n New model: "MTB robot.ttm" \n New model: "suction pad.ttm" \n New model: "lumibot.ttm" \n New model: "Standing Bill.ttm" \n New model: "kinect.ttm" \n \n V-REP V2.5.6 (June 14th 2011) \n  Extended the functionality of the  functions related to signals . Signals can now be local (to a given simulator instance) or global  \n  Textures can now also be applied using texture coordinate information loaded during an  import  operation \n Added a new integer parameter:  sim.intparam_visible_layers \n Added a new bool parameter:  sim.boolparam_shape_textures_are_visible \n New scene: "controlTypeExamples.ttt" \n Bug correction (crash with spherical joints, and joints involved in loop closure with the  ODE  engine) \n \n V-REP V2.5.5 (June 3rd 2011) \n New API commands to build transformation interpolations:  sim.getRotationAxis  and  sim.rotateAroundAxis \n \n New API command to launch executables:  sim.launchExecutable \n \n New API command to read the force/torque along/about a joint\'s z-axis: simJointGetForce \n  New model: "signal monitor.ttm" \n \n  When simulation stops, then the initial parenting will try to be restored \n \n Added a new integer parameter:  sim.intparam_dynamic_engine \n Added a new recordable data stream for graphs: "Joints: force or torque" \n Number of active lights not limited to 8 anymore (provided that the GPU also supports more than 8 lights) \n Folders now also appear and are clickable in the lower part of the model browser window \n \n V-REP V2.5.4 (April 22nd 2011) \n  Completely reworked user manual, running in web-browser now. Fixed all broken links. \n \nNew V-REP plugin "simExtWii.dll" that exports 4 new commands to interact with a wiimote device: simWii.start, simWii.stop, simWii.set and simWii.get \n \nMultiple simultaneous script edition is now suppored  \n \nNew API command to apply non-central forces:  sim.addForce \n \nNew API command to temporarily forbid thread switches:  sim.setThreadAutomaticSwitch \n \n2 API commands were removed: simGetInEditionScript and simCloseEditionScript  \n \nNew data stream type: simulation pass execution time  \n \nSwitched to the most recent Bullet engine V2.78beta (rev2338)  \n \nNew model: "Working Bill.ttm"  \n \nSeveral new models of panes for industrial manufacturing cells  \n \nNew model: "5mX5m wooden floor.ttm"  \n \nNew model: "Sitting Bill.ttm"  \n \nRemoved scene "hovercraft.ttt"  \n \nRemoved scene "trackedRobots.ttt"  \n \nNew scene: "inverseKinematicsOf144DoFManipulator.ttt"  \n \n V-REP V2.5.3 (March 20th 2011) \n \nExtended the functionality of the  sim.unpackInt32Table  and  sim.unpackFloatTable  functions  \n \nExtended the functionality of the  sim.adjustView  function  \n New API command to control the show state of an auxiliary console window:  sim.auxiliaryConsoleShow \n \n \nNew API commands to set and retrieve various values linked to objects (will be extended on a regular basis):  sim.getObjectInt32Param ,  sim.setObjectInt32Param ,  sim.getObjectFloatParam ,  sim.setObjectFloatParam ,  sim.getObjectStringParam  and  sim.setObjectStringParam \n \nNew API command to adjust the number of displayed frames during simulation:  simSetSimulationPassesPerRenderingPass \n \nNew V-REP plugin "simExtCam.dll" (using "escape.dll") that exports 4 new commands to acquire webcam images: simCam.start, simCam.stop, simCam.info and simCam.grab \n \nNew model: "plugin enumerator.ttm"  \n \nNew model: "Mesa SR4000.ttm"  \n \nNew model: "Snake.ttm"  \n \nNew model: "Walking Bill.ttm"  \n \nNew model: "wiimote.ttm" (the associated required plugin will be shipped in next release) \n \nNew model: "Barrett Hand.ttm"  \n \nNew model: "K-Junior.ttm"  \n \nNew model: "webcam.ttm"  \n \nCorrected a bug where sim.handleModule would generate an additional unexpected event (sim_message_eventcallback_modulehandle)  \n \nModel names in the model browser are now displayed on 2 lines if required  \n \nNew models: conveyor belt models were added that perform more efficiently  \n \nUpdated the conveyor belt tutorial with an alternative modeling method that performs more efficiently  \n \nRemoved scene "mapBuilding.ttt"  \n \nNew scene "environmentMapping.ttt"  \n \nNew scene "BarrettHandPickAndPlace.ttt"  \n \nAdded a mechanism to adjust the Bullet collision margin overall, or on an object-basis  \n \n V-REP V2.5.2 (February 22nd 2011) \n \nHeightfields are now supported and can be imported from *.tga, *.csv or *.txt files  \n \nNew API command to create heightfields: sim.createHeightfieldShape  \n \nNew API commands to handle views and floating views: sim.floatingViewAdd, sim.floatingViewRemove and sim.adjustView  \n \nNew model: 10m x 10m terrain.ttm  \n \nUpdated the quadricopter model by adding a floor and a front camera  \n \nUpdated the helicopter model by adding a front camera  \n \n V-REP V2.5.1 (February 10th 2011) \n \nCorrected bug in API function sim.getObjectOrientation (when relativeTo argument was not -1, results were wrong)  \n \nNew model: ABB IRB 140.ttm  \n \nNew model: Omnidirectional Platform.ttm  \n \nNew model: 1.0 x 0.2 conveyor.ttm  \n \nNew model: Quadricopter.ttm  \n \nNew model: helicopter.ttm  \n \nExtended the functionality of following 2 API functions: sim.getScriptSimulationParameter & sim.setScriptSimulationParameter (a parameter can now be a string containing any byte value) \n \nChanged the default value of last argument of API function simMoveToJointPositions. Default is now 1.  \n \nNew tutorial "Conveyor belt/caterpillar"  \n \nCorrected a bug in the propeller.ttm and Air jet.ttm models  \n \n V-REP V2.5.0 (January 16th 2011) \n \nNew API commands to import/export meshes: sim.importMesh and sim.exportMesh  \n \nNew API commands to create shapes and to extract the mesh of a shape: sim.createMeshShape, sim.createPureShape and sim.getShapeMesh  \n \nNew API command to create joints: sim.createJoint  \n \nAPI commands simGetShapeVertex and simGetShapeTriangle are declared deprecated  \n \nScene hierarchy now always contains a double-clickable "World" object. This replaces the environment toolbar button which was removed \n \nNew API constant: sim.boolparam_scene_and_model_load_messages  \n \nNew API constants: sim_message_eventcallback_bannerclicked & sim.message_bannerclicked \n \nNew API constants for banner support  \n \nNew model: object locator.ttm  \n \nUpdated the default main client application vrep.exe, and the example main client application project  \n \nExtended the lifetime of license keys (key version x.y.z now works for all V-REP versions up to x.y+1.z-1)  \n \n V-REP V2.4.15 (December 20th 2010) \n \nNew API command to set the maximum force/torque a joint can exert: sim.setJointForce  \n \nNew API commands to create and handle auxiliary console windows: sim.auxiliaryConsoleOpen, sim.auxiliaryConsolePrint, sim.auxiliaryConsoleClose  \n \nThe Lua extension library LuaSocket is included in the distribution  \n \nCorrected a small bug that would affect the icons appearance on some graphic cards  \n \nNew scene: socketAndTubeCommunicationExample.ttt  \n \n V-REP V2.4.14 (December 11th 2010) \n \nRemoved an OpenGL instruction that caused opengl driver crashes on some graphic cards (including VMWare\'s openGL driver "vmwogl32.dll") \n \n V-REP V2.4.13 (December 8th 2010) \n \nWarning message appears now when a scene was not saved (when leaving or discarding a scene)  \n \nImproved and corrected the BubbleRob tutorial  \n \nNew dongle drivers  \n \nNew API commands to handle particles: sim.addParticleObject, sim.removeParticleObject and sim.addParticleObjectItem  \n \nNew API command to retrieve information on contacts: sim.getContactInfo  \n \nNew model: contact display.ttm  \n \nNew model: AirJet.ttm  \n \nNew model: Propeller.ttm  \n \nNew model: Fire.ttm  \n \nNew model: smoke.ttm  \n \nNew model: Wheel.ttm  \n \nNew model: Caster wheel.ttm  \n \nNew model: Omniwheel 45deg A.ttm  \n \nNew model: Omniwheel 45deg B.ttm  \n \nNew model: Hokuyo URG 04LX UG01.ttm  \n \nNew scene: hovercraft.ttt  \n \n V-REP V2.4.12 (October 30th 2010) \n \nCorrected a small bug in the sim.moveToJointPositions API command applied to joints in dynamic mode  \n \nNew API commands: sim.setShapeColor, sim.resetDynamicObject and sim.setJointMode  \n \nNew model: YouBot.ttm  \n \nNew model: e-puck.ttm  \n \nNew scene: youBotDemo.ttt  \n \nNew scene: e-puckDemo.ttt  \n \n V-REP V2.4.11 (October 13th 2010) \n \nDual physics engine support: next to the  Bullet physics library , the  Open Dynamics Engine (ODE)  is now also supported  \n \nNew model: Asti.ttm  \n \nNew Model: Robbie.ttm \n \nAll models and scenes have been checked/adjusted for dual physics engine support  \n \nNew scene: ImageProcessingExample.ttt  \n \n V-REP V2.4.10 \n \nMinor bug fixes  \n \n V-REP V2.4.9 \n \nNew API commands: sim.setObjectSpecialProperty and sim.getObjectSpecialProperty  \n \nModel visibility can now also be overridden  \n \nNew option "ignored during path planning" for the "collidable" and "measurable" property \n \nImproved path edition capabilities  \n \nBug fix in the path planning module  \n \nNew model: path following human  \n \nNew model: path planning and following human  \n \n V-REP V2.4.8 \n \nEdge following is enabled by default in the edge edit mode  \n \nNew demo scene: Katana robot with twisted cable simulation  \n \nNew demo scene: ABB Fanta can challenge  \n \nNew demo scene: practical path planning  \n \nNew API commands: sim.setExplicitHandling and sim.getExplicitHandling  \n \nImproved object manipulation and snapping to grid  \n \nAutomatic rendering order calculation for translucid shapes  \n \nNew OpenGl-based custom UI option: "display only when associated object is selected"  \n \nNew edit menu item: "Replace selected objects with a copy of last selected object"  \n \nNew model browser window with drag-and-drop functionality  \n \nNew models organized in a model library  \n \nNew option for proximity sensors: Occlusion check  \n \nNew option for ray-type proximity sensors: randomized detection  \n \nOption to override specific properties for whole models  \n \nNew API commands: sim.setModelProperty and sim.getModelProperty  \n \n V-REP V2.4.7 \n \nNew API command: sim.getStringParam  \n \nOption to create pure shapes with selected triangles in the triangle edit mode  \n \nImproved demo scene: Welding robot with flexible cable simulation  \n \nNew tutorial: Inverse kinematics  \n \nNew tutorial: Importing and preparing rigid bodies  \n \nNew tutorial: Hexapod  \n \nNew tutorial: Robot language interpreter integration  \n \n V-REP V2.4.6 \n \nVarious minor bug fixes  \n \nNew demo scene: Roller-Walker.ttt  \n \n V-REP V2.4.5 \n \nImproved sim.sendData and sim.receiveData commands  \n \nNew API command: sim.getVelocity  \n \nNew API command: sim.addForceAndTorque  \n \nNew demo scene: ACM_R5H.ttt  \n \nNew demo scene: Hexapod.ttt  \n \nBug correction in simGetPosition, simSetPosition, simGetOrientation and simSetOrientation commands  \n \nAntialiasing option for edges. Disabled by default  \n \n V-REP V2.4.4 \n \nVarious minor bug fixes  \n \n V-REP V2.4.3 \n \nTexture support for shapes and OpenGl-based custom UIs. Textures can be static or dynamic  \n \n V-REP V2.4.2 \n \nFirst public release in March 2010  \n \n \n \n \n \n licensing \n \n \n \n \n \nLicensing\n \n \nCoppeliaSim Player, CoppeliaSim Edu, CoppeliaSim Pro and other components (e.g. plugins) are licensed according to following scheme (see further below for the license texts): \n \n \n \n \n CoppeliaSim Pro license\n \n \n CoppeliaSim Pro commercial license. Contact us for details. \n \n \n \n \n CoppeliaSim Edu license\n \n \n CoppeliaSim Edu educational license: \n ------------------------------------------------------------------- \n The CoppeliaSim Edu educational license applies ONLY to  educational entities  composed by following people and institutions: \n 1. Hobbyists, students, teachers and professors \n 2. Schools and Universities \n Educational entities  do NOT include companies, research institutions, non-profit organisations, foundations, etc. \n An  educational entity  may use CoppeliaSim Edu under following conditions: \n 1. Usage should be non-commercial. \n CoppeliaSim Edu is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nIn no event will the original authors and Coppelia Robotics AG be held liable for any injuries,\ndeath, data loss, damages, loss of profits or any other loss while using or misuing this software. \n ------------------------------------------------------------------- \n \n \n \n \n Geometric/kinematics plugin commercial license\n \n \n Geometric/kinemtics plugin commercial license. Contact us for details. \n \n \n \n \n Geometric/kinematics plugin educational license\n \n \n Geometric/kinematics plugin educational license: \n ------------------------------------------------------------------- \n The Geometric/kinematics plugin educational license applies ONLY to  educational entities  composed by\nfollowing people and institutions: \n 1. Hobbyists, students, teachers and professors \n 2. Schools and Universities \n Educational entities do NOT include companies, research institutions,\nnon-profit organisations, foundations, etc. \n An  educational entitiy  may use, modify, compile and distribute the\nmodified/unmodified plugin under following conditions: \n 1. Distribution should be free of charge. \n 2. Distribution should be to  educational entities  only. \n 3. Usage should be non-commercial. \n 4. Altered source versions must be plainly marked as such and distributed along\n   with any compiled code. \n 5. When using the plugin in conjunction with CoppeliaSim, the "EDU" watermark\n   in the CoppeliaSim scene view should not be removed. \n 6. The origin of the plugin must not be misrepresented. you must not claim that\n   you wrote the original software. \n The plugin is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nIn no event will the original authors and Coppelia Robotics AG be held liable for any injuries,\ndeath, data loss, damages, loss of profits or any other loss while using or misuing this software. \n ------------------------------------------------------------------- \n \n \n \n \n \n \n acknowledgments \n \n \n \n \n \nAcknowledgments and credits\n \n \nV-REP / CoppeliaSim was developed during several years, however, without the contributions, help, support, advice, or generosity of many people, it wouldn\'t have become what it is today. I wish to thank and acknowledge the contributions in various forms of the following people, group of people or organizations:\n \n \nNobuto Matsuhira (Toshiba Corporate R&D center), for the enormous support, belief in me, and kindness he always showed me \n \nFumio Ozaki (Toshiba Corporate R&D center), for the patience, trust and freedom he gave me \n \nHoimin Jeong (Cubictek Co. Ltd), for his support and belief in me even in difficult situations \n \nThe Lua development team (PUC-Rio,  http://www.lua.org ), for the free Lua interpreter they provide.  See the license . \n \nNokia corporation, the Qt GUI Toolkit development team and all other contributors, for the  Qt GUI Toolkit  library they provide.  See the license . \n \nDigia Plc and/or its subsidiary(-ies), and all other contributors, for the  Qt Property Browser  they provide.  See the license . \n \nAntonio Escano Scuri and Mark Stroetzel Glasberg for the free WebBook framework they provide.  See the license . \n \nDiego Nehab ( http://w3.impa.br/~diego/software/luasocket/home.htmll ), for the free LuaSocket extension library.  See the license . \n \nErwin Coumans ( http://www.bulletphysics.org ), for the free  Bullet physics library  he provides.  See the license . \n \nRussel L. Smith ( http://www.ode.org ), for the free physics library he provides.  See the license . \n Daniel Fiser for his collision routines (libccd, used with  ODE ).  See the license . \n Pierre Terdiman for his collision routines (OPCODE, used with  ODE ). \n Francisco Leon Najera for his collision routines (GIMPACT, used with  Bullet ).  See the license . \n The people and community behind the  Open Motion Planning Library (OMPL) .  See the license . \n Khaled Mamou, for the excellent convex decomposition routines he provides (HACD and V-HACD).  See the license . \n Brad Barber, for the efficient Qhull routines he provides.  See the license . \n François Conti, for the CHAI3D library he provides.  See the license . \n \nThe Scintilla development team ( http://www.scintilla.org ), for the free source code editing component they provide. Since CoppeliaSim 2.6.0, the Scintilla library is used via  commercial QScintilla .  \n Lee Thomason, for his nice and compact tinyxml routines.  See the license . \n \nMarcus Geelnard for the Basic Compression Library he provides ( http://bcl.comli.eu/home-en.htmll ).  See the license . \n \nToni Ronkko for the Dirent interface for Microsoft Visual Studio he provides ( https://github.com/tronkko/dirent ).  See the license . \n Martin Courchesne and  SimWat  for the initial  Vortex plugin  for CoppeliaSim they provided. \n CM Labs  for the free version of their Vortex physics engine ( Vortex Studio ), used in CoppeliaSim\'s Vortex plugin. \n Sean Barrett for his image loading routines he provides. \n \nJari Komppa for the  ESCAPI library  that is wrapped in the webcam plugin for CoppeliaSim (Credit is given when the plugin is used) \n Julio Jerez and Alain Suero, for the  Newton plugin  for CoppeliaSim they provide.  See the license . \n René Nyffenegger, for the base64 source code he provides.  See the license . \n \nThe programming community on  http://www.gamedev.net  and  http://www.codeproject.com  for the many invaluable advices, tips and code snippets \n The developers of the  FFmpeg library  and Andrew Voznytsa who wrote a library for CoppeliaSim that offers video compression functionality based on FFmpeg.  See the FFmpeg license . \n The Computer Graphics Group at RWTH Aachen, who developed the  OpenMesh  library. The library is used in the CoppeliaSim plugin  simExtOpenMesh .  See the OpenMesh license . \n The team behind the  Assimp library . The library is used in the CoppeliaSim plugin  simExtAssimp .  See the Assimp license . \n Torsten Kroeger and  Reflexxes GmbH , for providing their  Reflexxes Motion Library type II  as a CoppeliaSim plugin.  See the RML Type II license . \n Lars Berscheid, for providing his  Ruckig Online Trajectory Generator  as a CoppeliaSim plugin.  See the Ruckig license . \n Chris Hecker for his mass properties calculation algorithm.  See the related license . \n \nChristian Dippel, my cousin, who helped me in many ways (CAD models, flyer preparation, etc.) \n Michele Guarnieri, Paulo Debenest and Naho Guarnieri from Hibot, who are not only my partners in Business, but also friends. \n \nLyall Randell  who not only gave me permission to use his CAD models, but also created additional ones especially for CoppeliaSim. \n \nEric Rohmer who is a thorough CoppeliaSim tester and an "idea machine". He is also the creator of several models and plugins for CoppeliaSim (e.g. simExtWii or simExtJoystick) \n Svetlin Penkov for creating a first ROS plugin, and for being always available for ROS-related questions. \n Ignacio Tartavull for creating a first URDF plugin, and for being extremely helpful at the right time. \n Maciej Szymanski, Ibrahim Abd Elkader, Mahendra Koteshwar and Asanka Wickramasinghe for various tasks in relation with CoppeliaSim porting and legacy remote API bindings \n Julien Tharin for various tasks in relation with CoppeliaSim porting \n Preben Hjornet for creating precise simulation models of extremely complex robots \n \n"gl.tter" for the WiiYourself! wiimote code ( http://gl.tter.org )  wrapped in the wiiMote plugin for CoppeliaSim (Credit is given when the plugin is used). \n Alex Doumanoglou for writing the Collada importer/exporter plugin. \n Cedric Pradalier for extending the RosPlugin with useful publisher/subscriber types. \n Andreas Geiger, for the  LIBICP  he provides.  See the license . \n Hung Pham, Quang Cuong Pham and others, for the  TOPP-RA  library they provide.  See the license . \n Diego Daniel Santiago for writing a shared memory communication plugin, and the  plugin for Simulink-CoppeliaSim communication . \n The developers of the POV-Ray raytracer, Persistence of Vision Raytracer Pty. Ltd. POV-Ray uses the  GNU AFFERO GENERAL PUBLIC LICENSE , a copy of which is included in the software package. \n The developers of the  CGAL library , which is used by the  simExtSurfRec  plugin.  See the license . \n The developers of  LIBIGL , which is wrapped in the IGL plugin.  See the license . \n The developers of  ZeroMQ , which is wrapped in several CoppeliaSim plugins, and used in several external applications.  See the license . \n The developers of  WebSocket++ , which is wrapped in the WS plugin.  See the license . \n The developers of  three.js , which is user by CoppeliaSim\'s external viewer.  See the license . \n All the developers behind the  OpenCV  library, which is used by the  simExtIM  plugin.  See the license . \n David Heiko Kolf, for  his JSON module for Lua .  See the license . \n Francois Perrad, for  his MessagePack module for Lua .  See the license . \n Takatoshi Kondo and several other contributors, for  their MessagePack code for C/C++ .  See the license . \n Bastian Bechtold, for  his MessagePack code for Matlab .  See the license . \n The people behind the  MessagePack code for Java .  See the license . \n Kim Alvefur, for  his CBOR code for Lua .  See the license . \n Sean Conner, for  his CBOR library for Lua .  See the license . \n Federico Ferri, for creating a whole series of plugins for CoppeliaSim. \n Stephen James (Imperial College London) for his  PyRep toolkit for robot learning research , and his  OpenGL3  renderer plugin . \n Emanuel Eichhammer, for his  QCustomPlot  used in the  custom UI plugin .  See the license . \n Benjamin Navarro, for his code in the legacy remote API, which enables shared memory communication instead of socket communication. \n Following people for noticing bugs, reporting problems, suggesting solutions or new ideas, providing patches, code improvements, or simply helping out: Guillermo Presti, Matthias Fueller, Paul Fudal, Matthieu Lapeyre, Alberto Fanjul, Laurens Philippo, Vadim Liventsev, Kirill Makukhin, Patrick Bouffard, Pouya Mohammadi, Luca Marchionni, Barrett Ames, Arnaud Leleve, Geerten Doornenbal, Nikolaus Wittenstein, Ayberk Ozgur, Qi Wang, Giordano, Karl Robillard, Brian Yeomans, Kiyoshi Irie, Ulrich Schwesinger, Peter Mačička, Inkyu Sa, David Butterworth, Marco Cognetti, Xinyu Zhang, Jaqueline Gallardo, Serkan ÇİÇEK, Taehoon Koo, He Tao, Yusuke Ishizawa, Billy Newman, Rüdiger Dehmel, Roberto Marino, Renaud Detry, Roband, Hendrik Wiese, Matthias Schindler, George Moustris, Marco Bellaccini, Klaus Raizer, Paulo Gurgel, Stéphane Magnenat, Philipp Krüsi, Pascal Gohl, Gianpaolo Gonnelli, Felix Herrmann, Edgar Virga, Josep Tormo Costa, Gaël Ecorchard, Massimo Cefalo, Robert Lang, Marc Durvaux, Alexander Rietzler, Matt Derry, Arne Hitzmann, Sergi Foix, Daniel Morberg, Andreas Kuhner, Gerold Huber, Danilo Vasconcellos Vargas, Spencer Krause, Daniel Kuhner, Filip Jares, Luigi Ferri, Michaela Richter, Daniel Lechner, Sven Knüppel, Steve Nguyen, Jonas Sperling, Roberto Guzman, James Besancon, Andrew Vardy, Bipeen Acharya, Fred Gisa, Simon D. Levy, Leopoldo Armesto, Rodrigo Moreno Garcia, Hanna Kurniawati, Dimitri Klimenko, Joshua Mun Song,  Vinay Yadav, Thomas Estier, Matthias Imle, Rosé Rosado, Soner Ulun, Reza Mahjourian, Ben Allan, Riccardo Spica,  Giovanni Claudio, Guenter Schreiber, Antoine Rennuit, Francois Conti, Sébastien Granges, Patrick Helmer, Eva Alves Costa, Lucian Cucu, Sigurd Villumsen, Andrea Censi, Pierre Rouanet, Leander Hille, Christoph Hügle, William Harrison, Scott Drew Pendleton, Jan Dentler, Raimund Krenmüller, Anuraj Rajendraprakash, Ilya Nemihin, Ángel Luis Jiménez García, Leander Hille, Pierre Rouanet, Kenichi Hara, Ilya Nemihin, Federico Ferri, Michael Michalik, Martin Pecka, Nicola Piccinelli, Kshitij Tiwari, Victor Gomez, Parker Owan, Yuki Suga, Muhammad Umer Huzaifa, Marshall Floyd, Augusto Gandia, Pierre Jacquot, Gurvan Le Bleis, Andreu Vidal, Nicola Di Pol, Tobias Groll, Wu Xiaojun, Karol Mocniak, Ana Lucia, Ricardo Azambuja, Anto Ronson, Graeme Neff Wilson, Minson Lee, Tiago Malheiro, Andrew Hundt, Ahmed Yacine, Matthias Ploner, Indranil Sur, Sung Kyun Kim, Rik Timmers, Matthew Veres, Korolyov Alexei, Daniel Angelov, Mohammed Talha, Bartolomeo Della Corte, Scott Hissam, Mark Fink, Hao Wang, Matias Nitsche, Ndivhuwo Makondo, Yu Zhang, DeKita G. Moon, Paul Santiago Tumbaco Casa, Tobias Benz, Rodrigo Moreno Garcia, Arjun Narayanan, Sven Schweigler, Nicola Battilani, Mark Edmonds,  Benno Timmermann, Cándido Otero Moreira, Justin Yim, Allen Zhu, Leo Koppel, Ravi Prakash Joshi, Sina Radmard, Sai Vemprala, Waleed El-Badry, James Barger, Gonzalo Casas, Metehan Doyran, Arif Rahman, Jason Cachrane, Steffen Hemer, Fangyi Zhang, Filipe Rocha, virgile Daugé, Riccardo Spica, Florian Golemo, Kevin M. Lynch, Frank C. Park, Jacob Huesman, Matthew Veres, Cándido Otero, Leon Masopust, Michael Tong, Zhengxing Yang, Thomas Gurriet, Lenka Pitonakova, Hervé Frezza-Buet, Justus Rijke, Stefan Müller, Julien Lechalupe, Tristan Gahler, Robert Peck, William Jones, Benjamin Erdemann, Boris Bogaerts, Ulrich Viereck, Amdrei Florea, Catalin Buiu, Joachim Haensel, Julian Mayer, Jacob Smith, Mohsen Moradi Dalvand, Simon Birrell, Mathias Thor, Jedrzej Orbik, Liu Dong, Mark Hartenstein, Alexander Oliva, Claudio Gaz, Simon Birrell, Sahil Sharma, Adrian Schoisengeier, Rémi Lux, Kilian Freitag, Maël Hörz, Jakub Turaj, Rieky Barady, Jian Ye, Jaime Boal, Pável Axel Mc Campos Peña, Patrick Gruener, Thomas Wilmotte, Lorenzo Romanini, Johan Relefors, Pablo Bustos, Sonny Tarbouriech, Aleksander Sil, Arturs Paugurs, Wei Wei, David Page, Leopoldo Armesto, Ayush Patel, Cameron Kabacinski, Francisco Marin, Kevin Thomas, Nikita Aigner, Charles Han, Shai Levy, Bobovsky Zdenko, Salvatore Sessa, Jakob Ambsdorf, Hayato Amaike, Nathan Kocherhans, Alex Wuqi Zhang, René Simon, Yongdong Wang, Andrés Faíña, Davide Scorza, Jovan Sumarac, Alexander\xa0Oliva, Luigi Ascione, Rui Li, Patrick Grüner, Andrés Faíña, Michal Mareš, Kat Styles Wood, David Paulius, Pranav A. Bhounsule, Davide Scorza, Amirhossein Afkhami Ardekani, Roman Horshkov, Volker Kühn, Artem Shishkin... We know we forgot many many people, also significant ones... please let us know! \n \nI also wish to thank following people for the inspiration they provided in various fields through their publications, books or other means:\n \n \nJ. J. Kuffner Jr., S.M. LaValle, L. Sciavicco, B. Siciliano, S. Gottschalk, M. C. Lin, D. Manocha, T. Akenin-Moeller \n \nFinally I am really grateful to all the people and organizations who/that were kind enough to let me use their created CAD designs and models:\n \n \nABB. There is however no link between ABB and Coppelia Robotics \n \nKUKA Laboratories GmbH \n SICK AG \n \nHibot  \n \nK-Team  \n \nCubictek  \n Neuronics \n Aldebaran \n IniLabs \n Robotiq \n Kinova Robotics \n Universal Robots \n Rethink Robotics \n Trossen Robotics \n Adept Technology \n Force Dimension \n On Robot ApS \n EVOL \n \nBejade Choy, Farkas Gergo, Barry van de Laar, Lucia Teglas, Casper Christensen, Andrew Alexander, Kazuyuki Shigeto, Joost a.k.a. J-m@n, Bjorn Kilen, Andrés San Millán Rodriguez, Mey Lean Kronemann, Marco Cognetti, Tesuno Tokisin. \n Large portions of CoppeliaSim source code is copyrighted by Coppelia Robotics AG and Robot Nordic ApS. For details see  Coppelia Robotic\'s source code repositories . See also  this licensing overview page . \n \n \nMarc Andreas Freese, founder and CEO, Coppelia Robotics AG\n \n \n License of the Lua script interpreter \n \n License for Lua 5.0 and later versions \n Copyright © 1994-2008 Lua.org, PUC-Rio. \n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n \n \n License of the WebBook framework \n \n Copyright 1994-2009 Tecgraf / PUC-Rio. \n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:  \n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n \n \n License of the LuaSocket extension library \n \n License for LuaSocket 2.0.2 \n Copyright © 2004-2007 Diego Nehab. All rights reserved. \n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n \n \n License of the Bullet Physics Library \n \n Bullet Continuous Collision Detection and Physics Library \n Copyright (c) 2003-2006 Erwin Coumans http://continuousphysics.com/Bullet/ \n This software is provided \'as-is\', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software. Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: \n 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. \n 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. \n 3. This notice may not be removed or altered from any source distribution. \n \n \n License of the Open Dynamics Engine \n \n Open Dynamics Engine \n Copyright (c) 2001-2004, Russell L. Smith. \n All rights reserved. \n Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \n Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. \n Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. \n Neither the names of ODE\'s copyright owner nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n \n \n License of the Libccd routines \n \n  * Copyright (c)2010 Daniel Fiser <danfis at danfis dot cz> \n* \n* \n*  This file is part of libccd. \n* \n*  Distributed under the OSI-approved BSD License (the "License"); \n*  see accompanying file BDS-LICENSE for details or see \n*  <http://www.opensource.org/licenses/bsd-license.php>. \n* \n*  This software is distributed WITHOUT ANY WARRANTY; without even the \n*  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. \n*  See the License for more information. \n \n \n License of the GIMPACT routines \n \n Copyright (c) 2006 Francisco Leon Najera. C.C. 80087371. \n  email: projectileman at yahoo dot com \n  This library is free software; you can redistribute it and/or \n  modify it under the terms of EITHER: \n  (1) The GNU Lesser General Public License as published by the Free \n  Software Foundation; either version 2.1 of the License, or (at \n  your option) any later version. The text of the GNU Lesser \n  General Public License is included with this library in the \n  file GIMPACT-LICENSE-LGPL.TXT. \n  (2) The BSD-style license that is included with this library in \n  the file GIMPACT-LICENSE-BSD.TXT. \n  (3) The zlib/libpng license that is included with this library in \n  the file GIMPACT-LICENSE-ZLIB.TXT. \n  This library is distributed in the hope that it will be useful, \n  but WITHOUT ANY WARRANTY; without even the implied warranty of \n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the files \n  GIMPACT-LICENSE-LGPL.TXT, GIMPACT-LICENSE-ZLIB.TXT and GIMPACT-LICENSE-BSD.TXT for more details. \n \n \n License of the convex decomposition routines \n \n \nCopyright (c) 2011 Khaled Mamou (kmamou at gmail dot com) \nAll rights reserved. \n \nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \n \n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. \n \n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. \n \n3. The names of the contributors may not be used to endorse or promote products derived from this software without specific prior written permission. \n \nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n \n \n \n License of the Qhull routines \n \n Qhull, Copyright (c) 1993-2012 \n                  \n                            C.B. Barber  \n                           Arlington, MA  \n    \n                               and \n  \n       The National Science and Technology Research Center for  \n        Computation and Visualization of Geometric Structures  \n                        (The Geometry Center)  \n                       University of Minnesota \n  \n                       email: qhull at qhull dot org \n  \nThis software includes Qhull from C.B. Barber and The Geometry Center.    \nQhull is copyrighted as noted above.  Qhull is free software and may   \nbe obtained via http from www.qhull.org.  It may be freely copied, modified,   \nand redistributed under the following conditions: \n  \n1. All copyright notices must remain intact in all files. \n  \n2. A copy of this text file must be distributed along with any copies   \n   of Qhull that you redistribute; this includes copies that you have   \n   modified, or copies of programs or other software products that   \n   include Qhull. \n  \n3. If you modify Qhull, you must include a notice giving the  \n   name of the person performing the modification, the date of  \n   modification, and the reason for such modification. \n  \n4. When distributing modified versions of Qhull, or other software   \n   products that include Qhull, you must provide notice that the original   \n   source code may be obtained as noted above. \n  \n5. There is no warranty or other guarantee of fitness for Qhull, it is   \n   provided solely "as is".  Bug reports or fixes may be sent to   \n   qhull_bug at qhull dot org; the authors may or may not act on them as   \n   they desire. \n \n \n License of the tinyxml routines \n \n Original code by Lee Thomason (www.grinninglizard.com) \n This software is provided \'as-is\', without any express or implied \n  warranty. In no event will the authors be held liable for any \n  damages arising from the use of this software. \n Permission is granted to anyone to use this software for any \n  purpose, including commercial applications, and to alter it and \n  redistribute it freely, subject to the following restrictions: \n 1. The origin of this software must not be misrepresented; you must \n  not claim that you wrote the original software. If you use this \n  software in a product, an acknowledgment in the product documentation \n  would be appreciated but is not required. \n 2. Altered source versions must be plainly marked as such, and \n  must not be misrepresented as being the original software. \n 3. This notice may not be removed or altered from any source \n  distribution. \n \n \n License of the FFmpeg library \n CoppeliaSim is linking dynamically to a library that itself links to the unmodified FFmpeg library files. The unmodified FFmpeg library, source and binaries (as distributed with CoppeliaSim), is available for download from  here \n \n FFmpeg is licensed under the  GNU Lesser  General Public License (LGPL) version 2.1  or later. However, FFmpeg  incorporates several optional parts and optimizations that are covered by the  GNU General  Public License (GPL) version 2  or later.  If those parts get used the GPL applies to all of FFmpeg.  \n \n \n \n License of the OpenMesh library \n \n OpenMesh makes use of the  LGPL v3  with the following exception: \n\nAs a special exception to the GNU Lesser General Public License, you may use any file of this software library without restriction. Specifically, if other files instantiate templates or use macros or inline functions from this file, or you compile this file and link it with other files to produce an executable, this file does not by itself cause the resulting executable to be covered by the GNU Lesser General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU Lesser General Public License. \n \n \n License of the Assimp library \n \n Assimp makes use of a 3-clauses BSD license: \n Copyright (C) 2006-2015 assimp team, All rights reserved. \n \n  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \n Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. \n Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. \n Neither the name of the assimp team nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n \n \n License of the Qt GUI Toolkit library \n CoppeliaSim is linking dynamically to the unmodified Qt library. \n \n The Qt GUI Toolkit is Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). \nContact: Nokia Corporation (qt-info at nokia dot com) \n Qt is available under the LGPL version 2.1 (GNU Lesser General Public License version 2.1). \n \n \n License of the Qt Property Browser \n \n Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). Contact: http://www.qt-project.org/legal \n This file is part of the Qt Solutions component. You may use this file under the terms of the BSD license as follows: \n "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. \n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. \n * Neither the name of Digia Plc and its Subsidiary(-ies) nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE." \n \n \n License of the Basic Compression Library \n \n Copyright © 2003-2006 Marcus Geelnard \n This software is provided \'as-is\', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software. \n Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: \n 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required. \n 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. \n 3. This notice may not be removed or altered from any source distribution. \n \n \n License of the CHAI3D Library \n \n Software License Agreement (BSD License) \nCopyright (c) 2003-2014, CHAI3D. \n(www.chai3d.org) \n All rights reserved. \n Redistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions \nare met: \n * Redistributions of source code must retain the above copyright \nnotice, this list of conditions and the following disclaimer. \n * Redistributions in binary form must reproduce the above \ncopyright notice, this list of conditions and the following \ndisclaimer in the documentation and/or other materials provided \nwith the distribution. \n * Neither the name of CHAI3D nor the names of its contributors may \nbe used to endorse or promote products derived from this software \nwithout specific prior written permission. \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\nCOPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\nBUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\nANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE. \n \n \n License of the mass properties calculation algorithm \n \n This code computes volume integrals needed for determining mass properties of polyhedral bodies. \n For more information, see the accompanying README file, and the paper \n Brian Mirtich, "Fast and Accurate Computation of Polyhedral Mass Properties," journal of graphics tools, volume 1, number 1, 1996. \n This source code is public domain, and may be used in any way, shape or form, free of charge. \n Copyright 1995 by Brian Mirtich \n mirtich at cs dot berkeley dot edu \nhttp://www.cs.berkeley.edu/~mirtich \n \n \n License of Newton Dynamics \n \n Newton is licensed under the liberal zlib open source license, with little if any practical difference between them. \n Copyright (c) <2003-2011> \n This software is provided \'as-is\', without any express or implied warranty. In no event will the authors be held liable for any damages arising from the use of this software. \n Permission is granted to anyone to use this software for any purpose, including commercial applications, and to alter it and redistribute it freely, subject to the following restrictions: \n 1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be\nappreciated but is not required. \n 2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software. \n 3. This notice may not be removed or altered from any source distribution. \n Julio Jerez and Alain Suero \n \n \n License of the Dirent interface \n \n Dirent interface for Microsoft Visual Studio \n Version 1.21 \n Copyright (C) 2006-2012 Toni Ronkko \n This file is part of dirent.  Dirent may be freely distributed under the MIT license. For all details and documentation, see https://github.com/tronkko/dirent \n \n \n License of the CGAL library \n (the unmodified CGAL shared library is used by the simExtSurfRec plugin) \n \n Some parts of CGAL are available under the  LGPL , other parts are under the  GPL . For details see  here  and also refer to the LICENSE file from the CGAL source code distribution. \n \n \n License of Libigl \n \n Libigl is primarily licensed under MPL2. For details see  here . \n \n \n License of ZeroMQ \n \n ZeroMQ Free Software Licenses \n The libzmq library is licensed under the\xa0 GNU Lesser General Public License \xa0V3 plus a static linking exception. \n -  You get the full source code . You can examine the code, modify it, and share your modified code under the terms of the LGPL. \n -  Static linking exception . The copyright holders give you permission to link this library with independent modules to produce an executable, regardless of the license terms of these independent modules, and to copy and distribute the resulting executable under terms of your choice, provided that you also meet, for each linked independent module, the terms and conditions of the license of that module. An independent module is a module which is not derived from or based on this library. If you modify this library, you must extend this exception to your version of the library. \n \n \n License of WebSocket++ \n \n Copyright (c) 2014, Peter Thorson. All rights reserved. \n Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \n * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. \n * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. \n * Neither the name of the WebSocket++ Project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL PETER THORSON BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n Detailed related to the bundled libraries can be found  here \n \n \n License of three.js \n \n The MIT License \n Copyright © 2010-2022 three.js authors \n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n \n \n License of the dkjson module for Lua \n \n Copyright (C) 2010-2014 David Heiko Kolf \n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n \n \n License of the MessagePack module for Lua \n \n Copyright (c) 2012-2018 Francois Perrad \n This library is licensed under the terms of the MIT/X11 license, like Lua itself: \n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: \n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n \n \n License of the MessagePack code for C/C++ \n \n Boost Software License - Version 1.0 - August 17th, 2003 \n Permission is hereby granted, free of charge, to any person or organization\nobtaining a copy of the software and accompanying documentation covered by\nthis license (the "Software") to use, reproduce, display, distribute,\nexecute, and transmit the Software, and to prepare derivative works of the\nSoftware, and to permit third-parties to whom the Software is furnished to\ndo so, all subject to the following: \n The copyright notices in the Software and this entire statement, including\nthe above license grant, this restriction and the following disclaimer,\nmust be included in all copies of the Software, in whole or in part, and\nall derivative works of the Software, unless such copies or derivative\nworks are solely in the form of machine-executable object code generated by\na source language processor. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\nSHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\nFOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE. \n \n \n License of the MessagePack code for Matlab \n \n Copyright (c) 2014 Bastian Bechtold \n All rights reserved. \n Redistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet: \n 1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer. \n 2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the\n   distribution. \n 3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission. \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nHOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n \n \n License of the MessagePack code for Java \n \n Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at \n http://www.apache.org/licenses/LICENSE-2.0 \n Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. \n \n \n License of Lua-CBOR \n \n Copyright (c) 2014-2015 Kim Alvefur \n Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: \n The above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. \n \n \n License of org.conman.cbor \n \n The library is licensed under  LGPL V3.0 \n \n \n License of QCustomPlot \n Coppelia Robotics AG uses a commercial license of QCustomPlot \n \n QCustomPlot is licensed under the  GNU General Public License (GPL) . See also   GPL.txt  located in the project files of the  custom UI plugin  ( simExtUI ). \n \n \n License of LibICP \n \n Copyright 2011. All rights reserved. Institute of Measurement and Control Systems Karlsruhe Institute of Technology, Germany \n Authors:  Andreas Geiger \n libicp is free software; you can redistribute it and/or modify it under the \nterms of the GNU General Public License as published by the Free Software \nFoundation; either version 3 of the License, or any later version. \n libicp is distributed in the hope that it will be useful, but WITHOUT ANY \nWARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A \nPARTICULAR PURPOSE. See the GNU General Public License for more details. \n You should have received a copy of the GNU General Public License along with \nlibicp; if not, write to the Free Software Foundation, Inc., 51 Franklin \nStreet, Fifth Floor, Boston, MA 02110-1301, USA \n \n \n License of base64 source code \n \n base64.cpp and base64.h base64 encoding and decoding with C++. Version: 1.01.00 \n Copyright (C) 2004-2017 René Nyffenegger \n This source code is provided \'as-is\', without any express or implied \nwarranty. In no event will the author be held liable for any damages \narising from the use of this software. \n Permission is granted to anyone to use this software for any purpose, \nincluding commercial applications, and to alter it and redistribute it \nfreely, subject to the following restrictions: \n 1. The origin of this source code must not be misrepresented; you must not \n  claim that you wrote the original source code. If you use this source code \n  in a product, an acknowledgment in the product documentation would be \n  appreciated but is not required. \n\n2. Altered source versions must be plainly marked as such, and must not be \n  misrepresented as being the original source code. \n\n3. This notice may not be removed or altered from any source distribution. \n René Nyffenegger rene.nyffenegger@adp-gmbh.ch \n \n \n License of OpenCV \n \n License Agreement For Open Source Computer Vision Library (3-clause BSD License) \n Redistribution and use in source and binary forms, with or without \nmodification, are permitted provided that the following conditions are met: \n 1. Redistributions of source code must retain the above copyright notice, \n   this list of conditions and the following disclaimer. \n 2. Redistributions in binary form must reproduce the above copyright notice, \n   this list of conditions and the following disclaimer in the documentation \n   and/or other materials provided with the distribution. \n 3. Neither the names of the copyright holders nor the names of the contributors \n   may be used to endorse or promote products derived from this software without \n   specific prior written permission. \n This software is provided by the copyright holders and contributors "as is" and \nany express or implied warranties, including, but not limited to, the implied \nwarranties of merchantability and fitness for a particular purpose are disclaimed. \nIn no event shall copyright holders or contributors be liable for any direct, \nindirect, incidental, special, exemplary, or consequential damages (including, \nbut not limited to, procurement of substitute goods or services; loss of use, data, \nor profits; or business interruption) however caused and on any theory of liability, \nwhether in contract, strict liability, or tort (including negligence or otherwise) \narising in any way out of the use of this software, even if advised of the \npossibility of such damage. \n \n \n License of the Open Motion Planning Library \n \n BSD License \n Copyright (c) 2010–2018, Rice University. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \n Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the Rice University nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. \n \n \n License of the Reflexxes Motion Library (RML) Type II \n \n The Reflexxes Motion Library Type II is licensed under  LGPL V3.0 \n \n \n License of the Ruckig Online Trajectory Generation library \n \n MIT License \n Copyright (c) 2021 Lars Berscheid \n Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions: \n The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. \n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n \n \n License of the TOPP-RA library \n \n The TOPP-RA library is licensed under the MIT License: \n Copyright (c) 2017 Hung Pham \n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the "Software"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:   \n The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software. \n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE. \n \n \n \n \n \n \n overviewTranslations \n \n \n \n \n \n English\n \n CoppeliaSim  is the Swiss army knife among robotics simulators: \n Cross platform (Windows, MacOSX, Linux) \n 6 programming approaches  ( embedded scripts ,  plugins ,  add-ons ,  ROS nodes , or  remote API  clients) \n 6 programming languages ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab , and  Octave ) \n more than  400 different API functions \n 4 physics engines  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n Full kinematics solver  (IK and FK for ANY mechanisms) \n Mesh, OC tree and point cloud interference detection \n Mesh, OC tree and point cloud minimum distance calculation \n Path / motion planning  (holonomic in 2-6 dimensions, non-holonomic for car-like vehicles, and motion planning for kinematic chains) \n Vision sensors  with built-in image processing (fully extendable) \n Realistic  proximity sensors  (minimum distance calculation within a detection volume) \n Built-in  custom user interfaces \n Fully integrated  Reflexxes Motion Library ,  Ruckig Online Trajectory Generator  and  RRS-1 interface specifications \n \n<li><a href="mills.html">Surface cutting simulation</a></li>\n \n Data recording and visualisation  (time graphs, X/Y graph or 3D curves) \n Integrated  shape edit modes \n Dynamic particles for water-/air-jet simulation \n Model browser  with drag-and-drop functionality (also during simulation) \n Multi-level undo/redo,  movie recorder , simulation of paint dispensing,  exhaustive documentation , etc. \n robot, robotics, simulator, simulation, kinematics, dynamics, path planning, minimum distance calculation, collision detection, vision sensor, image processing, proximity sensor, paint dispensing. \n \n \n \n \n Deutsch \n \n \n CoppeliaSim  ist das Schweizer Taschenmesser unter den Roboter-Simulatoren: Sie   werden keinen Simulator mit mehr Funktionalität oder   umfangreicheren\xa0APIs finden: \n Plattformübergreifend (Windows, MacOS, Linux) \n 6 Programmieransätze  ( eingebettete Skripte ,  Plugins ,  Add-ons ,  ROS Knoten , oder  Remote API  Clients) \n 6 Programmiersprachen ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab , und  Octave ) \n Mehr als  400 verschiedene API-Funktionen \n 4 Physik engines  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n Kinematik-Lösungsmodul \n Kollisionserkennung zwischen meshes, OC trees und point clouds \n Mesh, OC tree und point cloud basierte Bestimmung der kleinsten Entfernung \n Bahnplanung  (holonomisch in 2-6 Dimensionen,  nicht-holonomisch, und für kinematische Ketten) \n Optische Sensoren  mit integrierter Bildverarbeitung (erweiterbar) \n Realistische  Entfernungssensoren \n Angepasste Benutzeroberflächen \n Voll integrierte  Reflexxes Motion Library ,  Ruckig Online Trajectory Generator  und  RRS-1 interface specifications \n \n<li><a href="mills.html">Meshbasierte Schneidesimulation</a></li>\n \n Datenerfassung und Visualisierung  (Zeit-Diagramme, X/Y-Grafik oder 3D-Kurven) \n Integrierter  Mesh-Editiermodus \n Dynamische Partikel für Wasser- oder Luftströmungssimulation \n Modell-Browser  mit Drag-and-Drop-Funktionalität (auch während der Simulation) \n Mehrstufige Undo/Redo-Funktion,  Filmaufnahmefunktion , Farbspritzsimulation,  ausführliche Dokumentation , usw. \n roboter, robotik, simulator, simulation, kinematik, dynamik, bahnplanung, kleinste entfernung bestimmung, kollisionserkennung, optischer sensor, bildverarbeitung, entfernungssensoren, farbspritz. \n \n \n \n \n \n Français \n \n \n CoppeliaSim  est le couteau suisse parmi les simulateurs de robots: vous ne trouverez pas un simulateur avec plus de fonctions ou une API plus élaborée: \n Disponible sur Windows, MacOSX et Linux \n 6 modes de programmation  ( scripts intégrés ,  plugins ,  add-ons ,  nœuds ROS , ou clients " Remote API" ) \n 6 langages de programmation ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab , et  Octave ) \n Plus de  400 différentes fonctions API \n 4 moteurs physiques  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n Solveur de cinématique directe et inverse \n Détection de collisions entre meshes, OC trees et point clouds \n Module de calcul de distances minimales entre meshes, OC trees et point clouds \n Module de planification de mouvement  (holonome en 2-6 dimensions, non-holonome pour des véhicules types voiture, et planification de mouvement pour chaines cinématiques) \n Capteur de vision  avec traitement d\'image intégré (entièrement extensible) \n Capteur de proximité \n Interfaces utilisateur personnalisées \n Librairies " Reflexxes Motion Library ", " Ruckig Online Trajectory Generator " et " RRS-1 interface specifications " intégrées \n \n<li><a href="mills.html">Simulation de coupe de mesh</a></li>\n \n Enregistrement et visualisation de données de simulation  (graphes temporels, X/Y, ou courbes 3D) \n Editeur de mesh  intégré \n Particules dynamiques pour la simulation de jets d\'eau ou d\'air \n Model-browser  avec fonctionnalité drag-and-drop (également pendant la simulation) \n Fonctionalité undo/redo,  enregistreur vidéo , simulation de pulvérisation de peinture,  documentation exhaustive , etc. \n robot, robotique, simulateur, simulation, cinématique, dynamique, planification de mouvement, calcul de distance minimale, détection de collision, capteur de vision, traitement d\'image, capteur de proximité, pulvérisation de peinture. \n \n \n \n \n \n Italiano \n \n \n CoppeliaSim  è il coltellino svizzero tra i simulatori di robot: non troverete   un simulatore con più funzioni, più caratteristiche, o API così elaborate: \n Multipiattaforma (Windows, MacOS, Linux) \n 6 differenti approcci di programmazione  ( script incorporati ,  plugin ,  add-on ,  nodi ROS , o client  API remote ) \n 6 linguaggi di programmazione ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab  e  Octave ) \n Più di  400 diverse funzioni API \n 4 Motori di fisica  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n Risolutore completo di cinematica  (cinematica inversa e diretta per   qualsiasi meccanismo) \n Rilevamento delle interferenze (meshes, OC trees e point clouds) \n Calcolo della distanza minima tra mesh, OC tree et point cloud \n Pianificazione del percorso  (olonomico in 2-6 dimensioni, non   olonomico per veicoli simili ad auto) \n Sensori di visione  con elaborazione delle immagini incorporata   (completamente estensibile) \n Sensori di prossimità  realistici (calcolo della distanza minima all\'interno di un volume di rilevamento) \n Interfacce utente personalizzate incorporate \n Librerie di Movimento Reflexxes ,  Ruckig Online Trajectory Generator  e  RRS-1 interface specifications  completamente integrate  \n \n<li><a href="mills.html">Simulazione di taglio delle superfici </a></li>\n \n Visualizzazione e salvataggio di dati  (grafici in funzione del tempo,   grafici X/Y o curve 3D) \n Editor di forme integrato \n Particelle dinamiche per la simulazione di acqua o getti d\'aria  \n \n Browser di modelli  con funzionalità di drag-and-drop (utilizzabile   anche durante le simulazioni) \n undo/redo a più livelli,  registratore di video , simulatore di   vernice,  documentazione esaustiva , ecc   \n robot, robotica, simulatore, simulazione, cinematica, dinamica,   pianificazione del moto, calcolo della distanza minima, controllo di   collisione, sensore di visione, elaborazione delle immagini, sensori di   prossimità, simulazione di erogazione della vernice. \n \n \n \n \n \n Español \n \n \n CoppeliaSim  es la navaja suiza entre  los simuladores de robots: usted no encontrará un simulador con más funciones, recursos  o APIs más elaborados: \n Multiplataforma (Windows, MacOS, Linux) \n 6 enfoques de  programación   ( scripts incrustados ,  plugins ,  add-ons ,  nodos ROS , o  APIs de clientes remotos ) \n 6 lenguajes de  programación  ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab  o  Octave ) \n Más de  400 funciones diferentes  de API \n 4 motores físicos  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n Cálculo completo de la  cinemática \n Detección de interferencia  u obstáculo (meshes, OC trees, point clouds) \n Cálculo de la  distancia mínima entre Meshes, OC trees, point clouds \n Planeación de  trayectoria  (holonómica en 2-6  dimensiones, no holonómica para vehículos tipo automóvil) \n Sensores de visión  con procesamiento de  imagen integrado  (totalmente extensible) \n Sensores de  proximidad  real \n Interfaces de usuario  integradas y personalizadas \n Reflexxes Motion  Library ,  Ruckig Online Trajectory Generator  y  RRS-1 interface specifications  totalmente integrado \n \n<li><a href="mills.html">Simulación de corte  superficial</a></li>\n \n Registro de datos y  visualización  (gráficos de tiempo,  gráfico X / Y o curvas 3D) \n Modos de edición de  forma  integrados \n Partículas dinámicss  para la simulación de  jet  de agua o  aire \n Navegador de modelos  con función de  arrastrar y soltar ( drag and drop ) (incluso  durante la simulación) \n Función multiniveles  deshacer /rehacer (undo/redo),  función de grabación  o registro de video , simulación de pintura,  documentación  exhaustiva , etc. \n robot, robótica, simulador, simulación, cinemática, dinámica, planificación o planeación de la trayectoria, cálculo de la distancia, detección de colisiones, sensores de visión, procesamiento de imágenes, sensores de proximidad, simulación de pintura. \n \n \n \n \n \n Türkçe \n \n \n CoppeliaSim , robot simülatörleri arasında tam bir "İsviçre çakısı"dır; daha fazla fonksiyon içeren, daha özellikli ve bu kadar çok özel API içeren bir simülatör daha bulamazsınız: \n Çapraz platform (Windows, MacOS, Linux) \n 6 programlama yaklaşımı  ( gömülü script\'ler ,  plugin\'ler ,  add-on\'lar ,  ROS node\'lar ,  uzak API ) \n 6 programlama dili ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab  ve  Octave ) \n 400\'den fazla farklı API fonksiyonu \n 4 fizik motoru  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n Tam kinematik çözücü  (Herhangi bir mekanizma için Ters Kinematik ve İleri Kinematik) \n Sayısal ağlar arası girişim tespiti (meshes, OC trees and point clouds) \n Sayısal ağlar arası en kısa mesafe tespiti (meshes, OC trees and point clouds) \n Güzergah planlama  (2-6 boyutta holonomik, taşıt benzeri yapılar için holonomik olmayan) \n Entegre görüntü işleme özelliğine sahip (tamamen genişletilebilir)  görüntü sensörleri \n Gerçekçi  mesafe sensörleri  (algılama hacmi içerisinde en kısa mesafe hesaplaması) \n Entegre  özelleştirilmiş kullanıcı arayüzleri \n Tamamen entegre  Reflexxes Hareket Kütüphanesi +  Ruckig Online Trajectory Generator  +  RRS-1 interface specifications \n \n<li><a href="mills.html">Yüzey işleme simülasyonu</a></li>\n \n Veri kaydetme ve görselleştirme  (zaman grafiği, X/Y grafiği veya 3B eğriler) \n Entegre  şekil düzenleme modları \n Su ve hava jeti simülasyonları için dinamik partiküller \n Sürükle-bırak fonksiyonuna sahip Model Listeleyici  (simülasyon esnasinda da aktif) \n Çoklu geri al/yinele,  video kaydedici , boyama simülasyonu,  detaylı dokümantasyon , vb. \n CoppeliaSim Türkiye distribütörü:  Tura Mühendislik \n robot, robotik, simülatör, simülasyon, kinematik, dinamik, güzergah planlama, en kısa mesafe hesaplaması, çakışma tespiti, görüntü sensörü, görüntü işleme, mesafe sensörü, sprey boya simülasyonu. \n \n \n \n \n \n Português \n \n \n CoppeliaSim  é o canivete suíço entre os simuladores de robôs: você não vai encontrar um simulador com mais funções, recursos ou APIs mais elaborados: \n Plataforma Híbrida (Windows, MacOS, Linux) \n 6 abordagens de programação  ( scripts embutidos ,  plugins ,  add-ons ,  nós ROS , ou  APIs de clientes remotos ) \n 6 linguagens de programação ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab  e  Octave ) \n Mais de  400 diferentes funções de API \n 4 motores de física  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n Cálculo completo de cinemática \n Deteção de interferência (meshes, OC trees, point clouds) \n Cálculo de distância mínima (meshes, OC trees, point clouds) \n Planejamento de trajetória  (holonômica em 2-6 dimensões, não holonômica para veículos como carros) \n Sensores de visão  com processamento de imagem embutido (totalmente extensível) \n Sensores de proximidade  realísticos \n Interfaces de usuário personalizadas \n Reflexxes Motion Library ,  Ruckig Online Trajectory Generator  e  RRS-1 interface specifications  totalmente integrada \n \n<li><a href="mills.html">Simulação de corte de superfície</a></li>\n \n Gravação de dados e visualização  (gráficos de tempo, gráficos X / Y ou curvas 3D) \n Modos de edição de formas  integrados \n Partículas dinâmicas para simulação de jatos de água ou ar \n Navegador de modelos  com funcionalidade drag-and-drop (também durante a simulação) \n Função undo / redo em níveis múltiplos,  gravador de animações , simulação de pintura,  documentação extensiva , etc. \n robô, robótica, simulador, simulação, cinemática, dinâmica, planejamento de trajetória, cálculo de distância mínima, deteção de colisão, sensor de visão, processamento de image. \n \n \n \n \n \n 日本語 \n \n \n CoppeliaSim は他に類を見ない多くの機能と特長、精巧なAPIを備えたアーミーナイフのようなロボットシミュレータです。 \n 複数のOSに対応するクロスプラットフォーム \n 6つのプログラム手法  ( 組込みスクリプト 、プラグイン 、 アドオン 、 ROSノード 、 リモートAPI クライアント) \n 7つのプログラム言語 ( C/C++ 、 Python 、 Java 、 Matlab 、 Octave ) \n 400以上のAPI関数 \n 4つの物理演算エンジン  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n 双方のキネマティクスソルバ （様々なメカニズムのIKとFK） \n メッシュ, OC tree, point cloud－干渉検出 \n メッシュ, OC tree, point cloud－最短距離計算 \n パスプランニング  (2～6次元ホロノミック、自動車のような非ホロノミック) \n 画像処理機能を搭載したビジョンセンサー （フルカスタマイズ可能） \n 現実に即した近接センサー （検知範囲内での最短距離計算） \n エディターを含むカスタム可能なユーザーインターフェースを搭載 \n Reflexxes Motion Library  +  Ruckig Online Trajectory Generator  +  RRS-1 interface specifications  をフルサポート \n \n<li><a href="mills.html">表面切削シミュレーション</a></li>\n \n データ保存・可視化 （時間グラフ、XYグラフ、3Dカーブ） \n shapeエディットモード搭載 \n ウォーター/エアージェットの動的粒子シミュレーション \n ドラッグ＆ドロップ可能なモデルブラウザー （シミュレーション中も有効） \n その他、マルチレベルアンドゥ・リドゥ、 動画作成 、塗装シミュレーション、 詳細なドキュメント \n ロボット、ロボット工学、シミュレーター、シミュレーション、キネマティクス（運動学）、パスプランニング、最短距離計算、衝突検知、ビジョン（視覚/画像）センサー、画像処理、近接センサー、塗装シミュレーション \n \n \n \n \n \n 한국어 \n \n \n CoppeliaSim  은 로봇 시뮬레이터  중에서 마치 스위스 군용 나이프와 같습니다. : 다음과 같은 수 많은 기능과 특징, 그리고 정교한 API를 갖추고 있습니다: \n 크로스 플랫폼  지원 (윈도우즈, 맥OS, 리눅스) \n 6 개의 프로그래밍  방식 가능  ( 내장 스크립트 ,  플러그인 ,  부가 기능 ,  ROS 노드 ,  원격 API 클라이언트  ) \n 6 종류의 컴퓨터  프로그래밍 언어 지원 ( C/C++ ,  Python ,  Java ,  Lua ,  Matlab ,   Octave ) \n 시뮬레이션을  위한 400개 이상의 API 함수 지원 \n 4개의 물리 엔진  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n 범용 기구학  솔버 \n 메쉬 대 메쉬  간섭 감지 (meshes, OC trees and point clouds) \n 메쉬 대 메쉬  거리 계산 (meshes, OC trees and point clouds) \n 경로 생성 기능  (2-6차 홀로노믹  방식과 자동차와 기계들을 위한 비홀로노믹 방식 지원) \n 이미지 프로세싱을  내장한 비전 센서  (확장 가능) \n 실제에 가까운  근접 센서 \n 사용자 정의  유저 인터페이스와 편집기 지원 \n Reflexxes  모션 라이브러리  타입  +  Ruckig Online Trajectory Generator  +  RRS-1 interface specifications \n \n<li><a href="mills.html">서피스 절삭  모의 가공</a></li>\n \n 시뮬레이션 데이터  저장 기능과 다양한 시각적 분석  (시간선도 그래프, XY 그래프, 3차원 커브) \n 형상 편집 모드  내장 \n 물/젯-에어를 시뮬레이션할  수 있는 역학입자 \n 드래그 앤 드롭  기능을 지원하는 모델 브라우저  (시뮬레이션 도중에서도  사용 가능) \n 다중 레벨 되돌리기/다시하기,  동영상 저장 , 페인트 분사  시뮬레이션,  상세한 매뉴얼 과 기타 등등 \n 로봇, 로보틱스, 시뮬레이터, 시뮬레이션, 기구학, 역학, 경로 생성, 최소 거리 계산, 충돌 감지, 비전 센서, 영상처리, 근접센서, 페인트 분사. \n \n \n \n \n \n 简体中文\n \n \n CoppeliaSim  是机器人仿真器里的“瑞士军刀”：你不会发现一个比它拥有更多功能，特色或是更详尽应用编程接口的机器人仿真器: \n 跨平台 (Windows、MacOS、Linux) \n 六种编程方法  ( 嵌入式脚本 、 插件 、 附加组件 、 ROS节点 、 远程客户端应用编程接口 ) \n 6种编程语言 ( C/C++ 、 Python 、 Java 、 Lua 、 Matlab 、和 Octave ) \n 超过400种不同的应用编程接口函数 \n 4个物理引擎  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n Integrated ray-tracer ( POV-Ray ) \n 完整的运动学解算器  (对于任何机构的逆运动学和正运动学) \n Mesh, OC tree, point cloud-网孔干扰检测 \n Mesh, OC tree, point cloud-网孔最短距离计算 \n 路径规划  (在2到6维中的完整约束、对于车式车辆的非完整约束) \n 嵌入图像处理的视觉传感器   (完全可拓展) \n 现实的接近传感器  (在检测区域中的最短距离计算) \n 嵌入式的定制用户接口 、包括编辑器 \n 完全集成的第四类Reflexxes运动库  +  Ruckig Online Trajectory Generator  +  RRS-1 interface specifications \n \n<li><a href="mills.html">表面切削仿真</a></li>\n \n 数据记录与可视化  (时距图、X/Y图或三维曲线) \n 整合图形编辑模式 \n 支持水/气体喷射的动态颗粒仿真 \n 带有拖放功能的模型浏览器  (在仿真中依旧可行) \n 多层 取消/重做、 影像记录 、油漆的仿真、 详尽的文档等 \n 机器人、机器人学、仿真器、仿真、运动学、动力学、路径规划、最短距离计算、碰撞检测、视觉传感器、图像处理、接近传感器、油漆分散仿真. \n \n \n \n \n \n 繁体中文\n \n \n CoppeliaSim  是機器人模擬軟體中的瑞士刀,您再也找不到支援更多功能,更多特色或有更詳盡的應用程式介面的機器人模擬軟體: \n 跨平台支援(Windows, MacOSX, Linux) \n 支援六種撰寫程式的方式  ( 嵌入式腳本 、 插件 、 附加組件 、 ROS節點 、 遠端客戶端應用程式介面 ) \n 支援6種程式語言 ( C/C++ 、 Python 、 Java 、 Lua 、 Matlab 、和 Octave ) \n 400種以上的應用程式介面函數 \n 支援4種物理引擎  ( ODE ,  Bullet ,  Vortex ,  Newton ) \n 整合ray-tracer  ( POV-Ray ) \n 具備完整的運動學計算器  (支援任何機構的正運動學與逆運動學計算) \n 網格-網格干涉偵測 (meshes, OC trees and point clouds) \n 網格-網格最短距離計算 (meshes, OC trees and point clouds) \n 支援路線及運動完整規劃  (支援二~六維的完整約束,車輛類型載具的非完整約束,以及對於連鎖運動的規劃) \n 內建影像處理的視覺感測器   (完全可擴充) \n 真實的接近感測器  (偵測範圍內的最短距離計算) \n 內建含編輯器的客製化使用者介面 \n 完全整合第四類Reflexxes Motion Library ,  Ruckig Online Trajectory Generator 以及 RRS-1 介面規格 \n \n<li><a href="mills.html">模擬表面切削</a></li>\n \n 支援資料的儲存與視覺化  (time  graphs, X/Y graph or 3D curves) \n 整合形狀編輯模式 \n 支援噴水與氣體噴射的動態顆粒模擬 \n 支援拖放功能的模型瀏覽器  (模擬計算中仍可使用) \n 支援多重的取消/重做、 影像錄製 、油漆噴塗、 建立詳盡的文檔等功能 \n 機器人,機器人學,模擬器,模擬計算,運動學,動力學,路徑規劃,最短距離計算,碰撞偵測,視覺感測器,影像處理,接近感測器,油漆噴塗模擬. \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'welcome.html'}, {'title': 'userInterface', 'text': '\n \n \n \n \n User interface \n \nThe CoppeliaSim application is composed by several elements. Its main elements are:\n \n \n a console window : under Windows, when the CoppeliaSim application starts, a console window is created but directly hidden again. This default behavior of hiding the console window can be altered in the  user settings dialog . Under Linux, CoppeliaSim needs to be started from the console, which stays visible throughout the whole CoppeliaSim session. Under MacOSX, best is to start CoppeliaSim from a terminal, in order to have messages visible. The console or terminal window displays what  plugins  were loaded and whether their initialization procedure was successful. The console window is not interactive and is only used to output information. The user can directly output information to the console window with the  print  command (from within a script), or with the C  printf  or  std::cout  commands from within a plugin. In addition to that, the user can programmatically create  auxiliary console windows  to display information specific to a simulation for instance.  \n   an application window : the application window is the application\'s main window. It is used to display, edit, simulate and interact with a scene. The left and right mouse buttons, the mouse wheel as well as the keyboard have specific functions when activated in the application window. Within the application window the functions of the input devices (mouse and keyboard) may vary on context or activation location. \n \n   several dialogs : next to the application window, the user can also edit and interact with a scene by adjusting dialog settings or parameters. Each dialog groups a set of related functions, or functions that apply to a same target object. A dialog\'s content might be context sensitive (e.g. dependent on the object selection state). \n \nFollowing illustrates a typical view of the CoppeliaSim application:\n \n \n [User interface elements] \n \n \nWhen you launch the CoppeliaSim application, CoppeliaSim will initialized one default  scene . The user is free to open several scenes in parallel. Each scene shares the application window and the dialogs with the other scenes, but only the active scene content will be visible in the application window or the dialogs (only one scene is visible at a given time).  \n \nIn following section, a brief description will be given of the application window\'s elements. For details about dialogs, refer to the related pages in this reference manual.\n \n   application bar : the application bar indicates the type of license of your CoppeliaSim copy, the filename of the scene that is currently being displayed, the time used for one rendering pass (one display pass), and the simulator\'s current state (simulation state or type of the active edit mode). The application bar, as well as any surface within the application window, can also be used to drag-and-drop CoppeliaSim related files into the scene. Supported files include "*.ttt"-files (CoppeliaSim scene files) and  "*.ttm"-files (CoppeliaSim model files). \n   menu bar : the menu bar allows accessing almost all functionalities of the simulator. Most of the time, the items in the menu bar activate a dialog. The menu bar content is context-sensitive (i.e. it will depend on the current state of the simulator). Most functions in the menu bar can also alternatively be accessed through a popup menu, a double-click on an icon in the scene hierarchy view, or through a click of a toolbar button. \n   toolbars : the toolbars present functions that are often accessed (e.g. changing the navigation mode, selecting another page, etc.). Some functions in toolbar 1, and all functions in toolbar 2 can also be accessed through the menu bar or popup menu. See further down for more details. Both toolbars can be docked and undocked, but docking works only with their respective initial positions. Following figure explains each toolbar button\'s function: \n \n [Toolbar 1] \n \n \n [Toolbar 2] \n \n model browser : the model browser is visible by default, but can be toggled with its corresponding toolbar button. It displays in its upper part a CoppeliaSim model folder structure, and in its lower part, thumbnails of  models  contained in the selected folder. Thumbnails can be dragged-and-dropped into the scene to automatically load the related model. Caught thumbnails appears dark if the drop area is not supported or not appropriate. \n \n [Model browser] \n \n scene hierarchy : the scene hierarchy is visible by default, but can be toggled with its corresponding toolbar button. It displays the content of a scene (i.e. all scene objects composing a scene). Since  scene objects  are built in a hierarchy-like structure, the scene hierarchy displays a tree of this hierarchy, and individual elements can be expanded or collapsed. A double-click on an icon opens/closes a property dialog related to the clicked icon. A double-click on an object alias allows editing it. The mouse wheel as well as a drag of the scene hierarchy view\'s scrollbars allows shifting the content up/down or left/right. Control and shift selection is always supported. Objects in the scene hierarchy can be dragged and dropped onto another object, in order to create a parent-child relationship. The scene hierarchy will display a different content if the simulator is in an edit-mode state. Refer to the  shape edit modes  for more information. \n \n [Scene hierarchy] \n \n   page : each  scene  may contain up to 8 pages, each of them may contain an unlimited number of views. A page can be seen as container for views. Refer to the  pages and views section  for more details. \n   views : there can be an unlimited number of views contained in a page. A view is used to display the scene (itself containing an environment and objects), seen through a  viewable object  (e.g.  cameras ,  graphs  or  vision sensors ). \n   information text : the information text displays information related to current object/item selection and to running simulation states or parameters. The text display can be toggled with one of the two small buttons on the upper left side of a page. The other button can be used to toggle a white background, giving a better contrast depending on the background color of a scene. \n   status bar : the status bar displays information related to performed operations, commands, and also displays error messages from script interpreters. From within a  script  the user can also output strings to the status bar or console with the  sim.addLog  function. The status bar displays  only two lines by default, but it can be resized using its horizontal separation handle. \n   Lua commander : a read-eval-print loop, that adds a text input to the CoppeliaSim status bar, allowing to enter and execute Lua code on the fly, like in a terminal. The code can be run in  the sandbox script , or any other active script in CoppeliaSim. \n   custom user interfaces :  custom user interfaces  are user-defined UI surfaces that can be used to display information (text, images, etc.) or a custom dialog, allowing to interact with the user in a customized way.  \n   popup menu : popup menus are the menus that appear after a right mouse button click. To activate a popup menu, make sure the mouse doesn\'t move during the click operation, otherwise the camera rotation mode may be activated (see the  camera section  for more details). Each surface within the application window (e.g. scene hierarchy view, page, view, etc.) may trigger a different popup menu (context-sensitive). The content of popup menus may also change depending on the current simulation state or edit mode. Most popup menu function can also be accessed through the menu bar, except for the view-menu item that only appears when the popup menu is activated on a view or page. \n \n \n \n \n \n', 'tags': '', 'url': 'userInterface.html'}, {'title': 'pagesAndViews', 'text': '\n \n \n \n \n Pages and views \n \nA page in CoppeliaSim is the main viewing surface of a  scene . It is not directly a view, but can contain one, two, or as many views as needed. A view is what is used to display the image content of a specific  object  which has to be a  viewable object .  If a view is associated with a  camera object  for instance, then it can display what the camera  sees . Following figure explains the page, view and viewable object relationship: \n \n [Page, view and viewable object relationship] \n \n \nA view can have a fixed position within a page, or it can have a floating position on the page. Above page, view, and viewable object relationship is illustrated in following page configuration:  \n \n [Page configuration containing four views. One view is fixed (background view), the other three views are floating] \n \n \nEach  scene  in CoppeliaSim has eight freely configurable pages. Individual pages can be accessed (i.e. displayed) through the page selector toolbar button: \n \n [Page selector toolbar button] \n \n \nWhen a new scene is created, then each of the 8 pages will be pre-configured in a different way. A page can be removed with [Popup menu --> Remove Page]. An inexistent page (i.e. removed page) displays a dark-grey surface. A page and a default page configuration with empty views can then be created with [Popup menu --> Set-Up Page With...]. Several page configurations are available, as shown in following figure (numbers indicate view indices):\n \n \n [Available page configurations with fixed views] \n \n \nAbove page configurations allow displaying 1-8 fixed views. Each one of the light-grey surfaces corresponds to an empty view (i.e. unassociated view). At any time, a page can be removed with [Popup menu --> Remove Page]. Removing a page will also remove all views that it contains, but will not remove any of the associated objects. On top of an existing page configuration, it is possible to add an unlimited number of floating views with [Popup menu --> Add --> Floating View]. Following figure shows such an example:\n \n \n [Page configuration with four  floating views] \n \n \nFloating views can be shifted and resized, but do not allow navigation with the left or right mouse button (e.g. camera translations, camera rotations, etc.). Double-click a floating view to swap its content with the view index 0 (this operation can however be prohibited by programmatically disabling it). To remove a floating view, simply click its button at its upper right side.\n \n \nTo associate a viewable object with a view, select the object and on the view you wish to associate with it click [Popup menu --> View --> Associate view with selected camera] or [Popup menu --> View --> Associate view with selected vision sensor] (the popup menu will automatically adjust its content depending on the last selected object). When a view is created but not yet associated with a viewable object, the [Popup menu --> Add --> Camera] command will add a camera and directly associate it with the view (i.e. look through it). A given viewable object can be associated with any number of views at the same time.\n \n \nAlternatively you can also associate a view with a viewable object by activating following popup in a view: [Popup menu --> View --> View selector...]. This will open the view selector.  \n \nOnce a viewing object is associated with a view, its image content will be displayed, except for vision sensors that operate in following way: a vision sensor needs to generate its image content, and this can only happen when the appropriate API command is called. By default, the main script contains a command that will handle all vision sensors in the scene (  sim.handleVisionSensor (sim.handle_all) ). Unless a vision sensor is marked as  explicit handling  but is not explicitely handled, then its image content will be generated during simulation.  \n \nA view associated with a camera can be customized or adjusted in following ways: \n It can display the camera view in solid or  wireframe: [Popup menu --> View --> Solid rendering] \n It can display the camera view in perspective or orthographic projection mode:  [Popup menu --> View --> Perspective projection] \n It can show or hide the edges: [Popup menu --> View --> Visible edges] \n It can display edges as thick or thin lines: [Popup menu --> View --> Thick edges] \n It can turn texture display on and off: [Popup menu --> View --> Shape textures enabled] \n Its associated camera can track the last selected object: [Popup menu --> View --> Track selected object] \n \n \n \n \n \n', 'tags': '', 'url': 'pagesAndViews.html'}, {'title': 'coordinateDialog', 'text': "\n \n \n \n \n Position/orientation manipulation \n The user can modify and manipulate and object or item's position and orientation by using one of following   toolbar  buttons:\n \n \n [Manipulation toolbar buttons (position and orientation)] \n \n The first  displays the  position dialog , while the second  displays the  orientation dialog . In both cases, the user will also be able to  move the selected objects or items with the mouse . \n \n \n \n \n", 'tags': '', 'url': 'coordinateDialog.html'}, {'title': 'positionDialog', 'text': "\n \n \n \n \n Position dialog \n The position dialog becomes visible  when the object translation toolbar button is selected: \n \n [Object translation toolbar button] \n The dialog has four distinct tabs: \n \n \n Mouse Translation\n \n \n [Mouse translation tab] \n \n In this section of the dialog, translation parameters of objects manipulated with the mouse can be set. See also the page on  object movement via the mouse . \n Relative to world/own frame : indicates that a mouse drag will translate the selected object on a plane or line that is aligned with the absolute reference frame, or aligned with the object's own reference frame.  \n Translation step size : the step size used when translating the selected object with a mouse drag (see the  user settings dialog  for default step sizes). Smaller step sized can still be used during manipulation by pressing the shift-key  after  the mouse button was pressed down. \n Preferred axes: along X/ along Y/ along Z : indicates that a mouse drag allows translating the selected object along preferred  axes of the reference frame selected above. Other axes can be used during manipulation by pressing the ctrl-key  after  the mouse button was pressed down. \n \n \n \n Position\n \n \n [Position tab] \n \n In this section of the dialog, precise positioning can be achieved on objects or items. \n Relative to world/parent frame : indicates that the coordinates are relative to the absolute reference frame, or relative to the parent reference frame.\n \n X-/ Y- / Z-coordinate : position of the selected object relative to the indicated reference frame (world or parent).\n \n \n \n \n Translation\n \n \n [Translation tab] \n \n In this section of the dialog, precise object or item translation can be achieved. \n Relative to world/parent frame/own frame : indicates that the translation will be relative to the absolute reference frame, relative to the parent reference frame, or relative to the object's own reference frame.\n \n Translate  along X / Y / Z : indicates the desired translation amounts  along the x-, y- and  z-axis of the indicated reference frame (world, parent or own frame).\n \n \n \n \n Position scaling\n \n \n [Position scaling tab] \n \n In this section of the dialog, precise scaling of object or item's position can be achieved. \n Relative to world/parent frame : indicates that the position scaling will be relative to the absolute reference frame, or relative to the parent reference frame.\n \n Scale  along X / Y / Z : indicates the desired  position scaling along the x-, y- and  z-axis of the indicated reference frame (world or parent).\n \n \n \n \n \n", 'tags': '', 'url': 'positionDialog.html'}, {'title': 'orientationDialog', 'text': "\n \n \n \n \n Orientation dialog \n The orientation dialog becomes visible  when the object rotation toolbar button is selected: \n \n [Object rotation toolbar button] \n The dialog has three distinct tabs: \n \n \n Mouse Rotation\n \n \n [Mouse rotation tab] \n \n In this section of the dialog, rotation parameters of objects manipulated with the mouse can be set. See also the page on  object movement via the mouse . \n Relative to world/own frame : indicates that a mouse drag will rotate the selected object about an axis of the absolute reference frame,  or the object's own reference frame. \n Rotation step size : the step size used when rotating the selected object with a mouse drag (see the  user settings dialog  for default step sizes).  Smaller step sized can still be used during manipulation by pressing the shift-key  after  the mouse button was pressed down. \n Preferred axis: about X/ about Y/ about Z : indicates that a mouse drag allows rotating the selected object about a preferred axis of the reference frame selected above. Other axes can be used during manipulation by pressing the ctrl-key  after  the mouse button was pressed down. \n \n \n \n Orientation\n \n \n [Orientation tab] \n \n In this section of the dialog, setting a precise object orientation can be achieved. \n Relative to world/parent frame : indicates that the indicated  Euler angles  are relative to the absolute reference frame, or relative to the parent reference frame.  \n Alpha / Beta / Gamma :  Euler angles  of the selected object relative to the indicated reference frame (world or parent).  \n \n \n \n Rotation\n \n \n [Rotation tab] \n \n In this section of the dialog, precise object rotation can be achieved. \n Relative to world/parent frame/own frame : indicates that the rotation will be relative to the absolute reference frame, relative to the parent reference frame, or relative to the object's own reference frame.\n \n Rotate  around X / Y / Z : indicates the desired rotation amounts  around the x-, y- and  z-axis of the indicated reference frame (world, parent or own frame).\n \n \n \n \n \n", 'tags': '', 'url': 'orientationDialog.html'}, {'title': 'objectMovement', 'text': "\n \n \n \n \n Object movement with the mouse \n Next to modifying  object  configurations through the  coordinate and transformation dialog , objects can also directly be manipulated using the mouse: when objects (and some items) are selected, then they can be translated or rotated using following toolbar buttons: \n \n \n [Manipulation toolbar buttons (position and orientation)] \n \n By default, translation is performed in the  world's X-Y plane. It can also be performed along a different axis/plane and relative to a different reference frame for each individual object, depending on the settings in the  position dialog . A cyan overlay drawing indicates the current translation plane or axis. \n \n By default, rotation is performed around the object's own Z axis. It can also be performed around a different axis or relative to a different reference frame for each individual object, depending on the settings in the  orientation dialog . A cyan overlay drawing indicates the current rotation axis. \n \n \n [Object translation and rotation operations with the mouse: the cyan overlay drawing indicates the translation plane or rotation axis] \n Default translation and rotation step sizes (snapping) can be adjusted in the  user settings dialog , but it is recommended to keep values of 5 centimeters and 5 degrees respectively, or to set the step sizes for objects on an individual basis. Snapping can temporarily be disabled by holding down the shift-key  AFTER  the mouse button was pressed down during object manipulation. In a similar way, alternative translation or rotation axes can be temporarily activated by holding down the ctrl-key  AFTER  the mouse button was pressed down during object manipulation. \n \n The object/item translation toolbar button can also be used when the simulator is in the  vertex edit mode . \n \n \n \n \n", 'tags': '', 'url': 'objectMovement.html'}, {'title': 'positionOrientationTransformation', 'text': "\n \n \n \n \n On positions, orientations & transformations \n In CoppeliaSim there are many different ways to  get, set, or work with positions & orientations . Following nomenclature is used throughout this user manual: \n Position: three coordinates (x,y,z), representing a position in 3D space. The position can be absolute (i.e. relative to the world frame), or relative to a specific frame. \n Orientation: an orientation in 3D space, that can be specified as  Euler angles , a  quaternion , or a  rotation matrix . The orientation can be absolute (i.e. relative to the world frame), or relative to a specific frame. \n Reference frame: also referred to as simply  transformation  or  frame , it represents a position and orientation in 3D space. It can be specified as a  transformation matrix , a  pose , or as a position and orientation. A reference frame can be absolute (i.e. relative to the world frame), or relative to another reference frame. \n \n Euler angles \n  The  Euler angles  are three angles that describe a rotation, the orientation of a rigid body, or the orientation of a frame. There are twelve different conventions when talking about Euler angles. They can be grouped into  Proper Euler angles , and  Tait-Bryan angles  where the latter represents rotations about three distinct axes. In CoppeliaSim,  Tait-Bryan angles   alpha ,  beta  and  gamma  (or (a,b,g)) are used, describing a rotation composed by three elemental rotations: \n \n [Euler angles convention in CoppeliaSim] \n \n where Rz, Ry and Rx represent elemental rotations about axes Z, Y and X respectively (in that order), of the  absolute  reference frame. \n For a rigid body, or  scene object , you can obtain the same transformation if you rotate it in following order about its  own  reference frame: rotation of  alpha  about own x, followed by a rotation of  beta  about own y, followed by a rotation of  gamma  about own z. \n Yaw-Pitch-Roll  are also  Tait-Bryan angles  describing a rotation composed by three elemental rotations: \n \n [Yaw-Pitch-Roll rotations] \n \n where Rx, Ry and Rz represent elemental rotations about axes X, Y and Z respectively (in that order), of the  absolute  reference frame. \n Use following API functions to convert between  alpha-beta-gamma  angles and  yaw-pitch-roll  angles: \n sim.yawPitchRollToAlphaBetaGamma \n sim.alphaBetaGammaToYawPitchRoll \n \n Quaternions \n   Quaternions  are four values that uniquely describe a rotation, the orientation of a rigid body, or the orientation of a frame. They are superior to Euler angles in several ways (e.g. no gimbal lock), but are more difficult to understand and construct. For that reason they are never used in user interfaces, but preferred when working with orientations in code. In CoppeliaSim, quaternions are expressed as a 4-element table: (Qx,Qy,Qz,Qw). Following API functions can be used to convert between quaternions, Euler angles and matrices: \n sim.buildPose \n sim.buildMatrixQ \n \n Rotation matrices \n  A  rotation matrix  is a 3x3 matrix that describes a rotation, the orientation of a rigid body, or the orientation of a frame: \n \n [Rotation matrix in 3D space] \n \n In above matrix, unit vectors (Xx,Xy,Xz), (Yx,Yy,Yz) and (Zx,Zy,Zz) represent the reference frame's axis X, Y and Z respectively. In CoppeliaSim, rotation matrices are expressed as a 9-element table in row-major order: (Xx,Yx,Zx,Xy,Yy,Zy,Xz,Yz,Zz). See also following API functions related to rotation matrices: \n sim.buildMatrix \n sim.buildMatrixQ \n sim.getEulerAnglesfromMatrix \n sim.getQuaternionFromMatrix \n sim.getRotationAxis \n sim.rotateAroundAxis \n Transformation matrices \n  A  transformation matrix  is a 4x4 matrix that describes a frame-frame transformation in 3D space. The first 3x3 elements of the matrix represent a  rotation matrix : \n \n [Transformation matrix in 3D space] \n \n In CoppeliaSim, transformation matrices are expressed as a 12-element table in row-major order (the last row is omitted): (Xx,Yx,Zx,X,Xy,Yy,Zy,Y,Xz,Yz,Zz,Z). See also following API functions related to rotation matrices: \n sim.buildMatrix \n sim.buildMatrixQ \n sim.getEulerAnglesfromMatrix \n sim.getQuaternionFromMatrix \n sim.getRotationAxis \n sim.rotateAroundAxis \n sim.multiplyMatrices \n sim.multiplyVector \n sim.interpolateMatrices \n sim.invertMatrix \n \n Poses \n   Poses  are values that describe a frame transformation in 3D space. In CoppeliaSim, poses are expressed as a 7-element table: (X,Y,Z,Qx,Qy,Qz,Qw), i.e. a position followed by a quaternion. See also following API functions related to poses: \n sim.getQuaternionFromMatrix \n sim.multiplyMatrices \n sim.multiplyVector \n \n \n \n \n", 'tags': '', 'url': 'positionOrientationTransformation.html'}, {'title': 'settings', 'text': "\n \n \n \n \n User settings \n Some values and settings in CoppeliaSim are not dependent on a  scene  or  model , but rather dependent on the user. The user settings dialog (which partially reflects the content of file  system/usrset.txt ) can be accessed with [Menu bar --> Tools --> Settings] or by clicking following toolbar button: \n \n \n [Settings toolbar button] \n \n \n [User settings dialog] \n \n   Translation step size : the linear step size used when translating  objects  in the  object manipulation mode . It is recommended to keep a value of 5 cm. Objects can be assigned specific step sizes in the  coordinate and transformation dialog . \n   Rotation step size : the angular step size used when rotating   objects  in the  object manipulation mode . Objects can be assigned specific step sizes in the  coordinate and transformation dialog . \n   Remove identical vertices, tolerance : when selected, vertices that lay nearby other vertices will be grouped to form one single vertex (that will then be shared among surrounding triangles). This reduces the amount of memory resources needed. This parameter is affecting meshes when they are being  imported  or  shapes  when leaving the  shape edit mode . Tolerance specifies the distance threshold to consider when grouping vertices. In general, keep a low value, but different from zero: some mesh data formats (e.g. STL) assign individual vertices to each triangle, regardless whether a vertex is identical with another vertex in another triangle; this can considerably increase the amount of memory required. \n \n   Remove identical triangles : when selected, identical triangles in a mesh resource will be removed during an import operation or when a shape leaves the shape edit mode. \n   Ignore triangle winding : a triangle can have two distinct orientations (since it has two distinct faces). When this item is selected, the triangle orientation is ignored when identifying identical triangles. \n   Undo/redo enabled : enables or disables the undo/redo functionality. That functionality operates by serializing (saving) the entire scene to memory every time a change was registered. Only differences with previous undo points are memorized so as to use little memory. This is a very efficient and fail-safe undo/redo that is also supported from  plugins  or the  main client application , and that is permitted only because CoppeliaSim's serialization routines are very fast. There are however times when either the computer is really old or the scene content extremely large (e.g. very detailed cad data) where this method slows down the whole application. In that case, simply disable the undo/redo functionality. \n   Display world reference : displays a small world reference frame in the lower left hand side of a  camera  view. As everywhere in CoppeliaSim, the red, green and blue arrows correspond to the x-, y-, and z-axis respectively. \n   Display bounding boxes of selected objects : displays a white/yellow bounding box around selected objects \n   Auto-save enabled : when auto-save is enabled, each opened scene will be saved on a regular basis. In case of a crash, the auto-saved scenes can be restored. The auto-save delay can be adjusted in the file system/usrset.txt. \n   Hide console window : allows hiding or showing the  console window . By default, the console window is hidden. On Mac, this item is not available (the standard output can be viewed in the system console (Applications/Utilities/Console)). \n   Hide hierarchy during simul. : automatically hides the scene hierarchy when simulation is running. \n   Adjust OpenGL settings : opens a dialog that allows to adjust most settings related to OpenGL: \n \n \n \n OpenGL settings\n \n \n [OpenGL settings dialog] \n \n Offscreen context type : the type of the offscreen rendering contexts. Default are invisible windows. \n FBO type : the type of the frame buffer objects. Default are Qt-based FBOs on Mac, and Non-Qt-based FBOs on Windows and Linux. \n VBO operation : whether Vertex Buffer Objects are used. The  default  option uses VBOs. \n Idle fps : the number of frames per second when idle. \n \n \n \n \n", 'tags': '', 'url': 'settings.html'}, {'title': 'shortcuts', 'text': '\n \n \n \n \n Shortcuts \n When the focus is on the  scene hierarchy  or a  page , following shortcut keys are supported:  \n CTRL+A : select all \n <esc> : clear the selection \n CTRL+C : copy the selection \n CTRL+V : paste the copy buffer \n CTRL+X : cut the selection \n <delete> : delete the selection \n <backspace> : delete the selection \n CTRL+O : open a scene \n CTRL+N : open a new scene \n CTRL+S : save the scene \n CTRL+W : close a scene \n CTRL+Q : quit the application \n CTRL+<space> : start/stop the simulation \n CTRL+E : toggle between 1) normal, 2) object translation and 3) object rotation mouse mode \n CTRL+D : open the object property dialog \n CTRL+G : open the calculation module dialog \n CTRL+B : adjust the view to fit selected objects, or the whole scene if no object is selected. The focus needs to be on a view. \n CTRL+ALT+C : set focus on the Lua commander \n CTRL+L : clear status bar (when focus is on the Lua commander) \n \n \n \n \n \n', 'tags': '', 'url': 'shortcuts.html'}, {'title': 'scenesAndModels', 'text': '\n \n \n \n \n Scenes and models \n Scenes  and  models  are CoppeliaSim\'s main simulation elements. A model is a sub-element of a scene, clearly marked as model. A scene may contain any number of models. Following figure illustrates the scene-model relationship:\n \n \n [Scene and model] \n \n Both, scenes and models, may contain one or several of following elements:\n \n \n Scene objects \n \n Child scripts \n \nIn addition to above elements, a scene will also contain following elements:\n \n \n The environment \n \n The main script \n \n Pages and views \n Scenes are saved in "*.ttt"-files, and models are saved in "*.ttm"-files. Both file types can be opened by dragging them from the explorer window and dropping them into the CoppeliaSim application. They can also be opened with a double-click. \n \n \n \n \n', 'tags': '', 'url': 'scenesAndModels.html'}, {'title': 'scenes', 'text': '\n \n \n \n \n Scenes \n Compared to  models , a scene can contain exactly the same type of elements, but additionally also includes following elements, specific to scenes:\n \n \n The environment \n \n The main script \n \n Pages and views \n A scene or scene image content can be seen through a  viewable object  associated with a view, itself contained in a  page . When creating a new scene ([Menu bar --> File --> New Scene]), the default scene will contain following elements: \n \n Several  camera objects : cameras allow to  see  the scene if they are associated with a view. \n Several  light objects : without a light the scene would be hardly visible. The light is used to illuminate the scene. \n Several  views : a view is associated with a camera and displays what the camera  sees . Views are contained in pages. \n Several  pages : a page contains one or several views. \n The environment : the environment is composed by properties as ambient light, fog, background color, etc. \n The floor: the floor is made-up by  objects  grouped in a model. \n The default  main script : the default main script should allow running minimal simulations, without the need of  child scripts . A child script copied into the scene at a later stage will then also be automatically executed (called by the main script) if it is associated with a scene object. \n Scenes can be opened (loaded) with [Menu bar --> File --> Open Scene...] and saved with [Menu bar --> File --> Save Scene] or [Menu Bar --> File --> Save Scene as]. Scene files ("*.ttt"-files) also support drag and drop operations between the explorer window and the application window. Scene files can also be double-clicked, in which case they will launch the CoppeliaSim application and be opened.\n \n \n \n \n \n', 'tags': '', 'url': 'scenes.html'}, {'title': 'models', 'text': '\n \n \n \n \n Models  \n A model is a sub-element of a  scene . A model by itself cannot exist, except in a file ("*.ttm"-file type), nor can it be simulated by itself. A model has to be contained in a scene in order to be operational.\n \n Models are defined by a selection of  scene objects  built on a same hierarchy tree, where the base of the tree has to be an object flagged as  object is model base . They can be loaded with [Menu bar --> File --> Load model...]. It is however much easier and convenient to load a model with a drag-and-drop operation between the  model browser  and a  scene view . Models can be saved with [Menu bar --> File --> Save model as...], just  make sure one single object flagged as  object is model base  is selected, otherwise the  Save model as... -menu item will not be enabled. Make also sure to follow the  tutorial on how to build a clean simulation model . \n \nA model is defined in following steps:\n \n \n  attach all objects that logically belong to the model to a base object, so that the base object is the base of the model tree. \n check the  object is model base -item in the  object common properties . \n in the same dialog as above, clicking  Edit model properties , you can define special overriding properties (e.g. make the whole model invisible, non-collidable, etc.). That allows to quickly disable some properties for all objects defined in the model. \n \n  for all objects in the model, except for the base object, check the  select base of model instead -item in the  object common properties . This will protect your model: you won\'t be able to directly select individual objects in your model, and you will be able to manipulate your model almost as a single object. \n for all objects that are normally not visible, check the  Don\'t show as inside model selection -item. This will make the model bounding box appear in the right size around the model. \n think about the role of the model: will you be able to attach it to some other object? (e.g. your model is a gripper that you could attach to a manipulator wrist). Or will you be able to attach some other model to it? (e.g. your model is a manipulator that could accept a gripper model). Once the role is decided, define the model\'s  assembling behaviour . Refer also to this  dynamics design consideration . \n Now, individual objects build on the model base cannot be selected anymore in the scene (selecting them will select the base of the model instead), however they can still be individually selected by holding down the ctrl- and shift-key during selection, or by selecting them in the  scene hierarchy . In addition to that, when the base object is selected, a stippled bounding box encompassing the whole model is displayed as can be seen in following figure:\n \n \n [Scene view and corresponding scene hierarchy view. The selected dummy is flagged as  object is model base ] \n \n Notice the model tag on the left-hand side of the icon of the object flagged as model base: \n \n [Model tag] \n \n A double-click on a model tag opens the  model dialog , where model properties can be adjusted. It is also good practice to collapse a model\'s hierarchy once the model was edited in order to easily identify the number of logically grouped elements/models: \n \n \n [Scene hierarchy view displaying 5 collapsed models] \n \n Grouping several objects as a model is also important when a  child script  accesses the objects programmatically; remember that in CoppeliaSim, objects/models can be duplicated at any time, also during a simulation. In order for the duplicated child script to be able to access the correct objects (not the original objects but the duplicated objects), the child script should always be duplicated at the same time as the objects it accesses. One way to guaranty that is to create a model (as described above) and to make sure the child scripts that access objects in the model are associated with objects that are contained in the model. Best is to associate one child script (there might be secondary child scripts too) with the the base of the model. Refer to the  accessing scene objects programmatically section  for more information. \n \n In order for models to be easily combined (i.e. built on top of each other) without any additional modification, it is important to consider what role the model will be playing: will it be dynamically simulated? Will it be attached to other models, or will it accept other models attached to it? The answer to those questions will allow you to select the best object type to work as a model base.  Refer to the  section on designing dynamic simulations  for more information. \n Copy and pasting a model behaves exactly like saving the model, then loading it (using however a memory buffer instead of the disk space). Models can be copied from one scene to another like any other object. Model files ("*.ttm"-files) also support drag-and-drop operations between the explorer window and the application window. Model files can also be double-clicked, in which case they will launch the CoppeliaSim application and be loaded into a default scene. \n The properties of a model can be individually adjusted in the  model dialog . \n \n \n \n \n', 'tags': '', 'url': 'models.html'}, {'title': 'modelDialog', 'text': '\n \n \n \n \n Model dialog \n The properties of a model can be individually adjusted in the model dialog. It can be opened with a  double-click on a model icon in the  scene hierarchy : \n \n [Model icon in the scene hierarchy] \n \n \n [Model  dialog] \n Select model thumbnail : when saving a model, a dialog pops open asking for a model thumbnail (that will be displayed in the  model browser ). If however you wish to save a thumbnail of your model in a different configuration (e.g. you wish to save a model of a snake robot in straight configuration, but you want the thumbnail to visualize the snake robot in a bent configuration), then you can specify the thumbnail here. \n Override properties : here you can disable (override) specific properties for the whole model (i.e. for all objects in the model hierarchy tree). This is convenient to quickly disable a model that takes too much calculation time for instance. See also the sections on  collidable objects ,  measurable objects  and   detectable objects , and the  sim.setModelProperty API function . \n \n Model content acknowledgments/Info : information related to a model. It is always good practice to acknowledge the original author of a model, or imported mesh. When a model that contains acknowledgment information is opened, it will automatically display that information.\n \n \n \n \n \n', 'tags': '', 'url': 'modelDialog.html'}, {'title': 'environment', 'text': '\n \n \n \n \n Environment \n The environment in CoppeliaSim defines properties and parameters that are part of a  scene , but that are not  scene objects . Environment properties and parameters are not saved when a  model  is saved, but only when a scene is saved. \n \nAn environment defines following properties and parameters:\n \n \nBackground colors.\n \n \nFog parameters. Fog parameters are not directly interacting with scene objects, except with  cameras  or  vision sensors  if the corresponding option was selected.  \n \nAmbient light\n \n \nScene creation information\n \n \nAdditional settings\n \n \n \n \n \n', 'tags': '', 'url': 'environment.html'}, {'title': 'environmentPropertiesDialog', 'text': "\n \n \n \n \n Environment dialog \n The environment dialog can be accessed with [Menu bar --> Tools --> Environment] or by double-clicking following icon in the  scene hierarchy :\n \n \n [Environment icon] \n \n \n [Environment dialog] \n \n   Background (up / down) : allows adjusting the background color of a scene. The up component corresponds to the upper part of the screen (sky), the down component corresponds to the lower part of the screen. The background colors are only visible when the fog functionality is disabled.\n \n   Ambient light : allows adjusting the ambient light of a  scene . The ambient light can be seen as the minimal light of a scene, it illuminates an object in the exact same way from all directions. See the  section about lights  for more details about illumination of a scene.  \n   Adjust fog parameters : allows to adjust various fog parameters.\n \n   Maximum triangle size (absolute) : this item will not affect the visual appearance of  shapes . It will however affect the execution speed of most CoppeliaSim  calculations . When performing  minimum distance calculations  for instance, between two  entities , execution will generally be faster if both entities are composed by similar-sized triangles. The maximum triangle size value specifies how the internal representation of a  shape  is handled (i.e. how elaborate the shape's calculation structure is). Small sizes will increase the preprocessing time, but generally the simulation execution speed will be increased at the same time. This value sets the overall maximum triangle size, as an absolute value. See also next item and the  reduce triangle size -item in the  triangle edit mode .  \n   Minimum triangle size (relative) : similar to previous item, but this item helps avoiding creating too large calculation structures that might potentially take very long. This value sets the minimum triangle size, as a relative value (relative to a given object's largest dimension). \n Save operation also saves existing calculation structures : for  distance calculations ,  collision detections , etc. a data structure is computed at the beginning of a simulation (preprocessing), or the first time a  shape  is involves in such calculations, in order to speed-up calculations. Calculation of that data structure might be time consuming, so the user can chose to save it together with the  scene  or  model . However one has to be aware that the additional information that will be saved is large and will result in larger files (sometimes twice as large or more).  \n   Shape textures disabled : if selected, then all  textures  applied to shapes will be disabled.  \n   Lock scene after next scene save : select this item if you want to lock your scene from edition/modification, script content viewing and resource export. After next scene save operation, the scene will be locked. Make sure you have saved the same scene in an unlocked state if you want to be able to modify it at a later time.\n \n   Extension string : a string that describes additional environment properties, mainly used by extension plugins (see also the  sim.getExtensionString  API function). \n   Scene content acknowledgements / Info : information related to a scene. It is always good practice to acknowledge the original author of a scene,  model , or imported mesh. When a scene that contains acknowledgment information is opened, it will automatically display that information.  \n \n \n \n \n", 'tags': '', 'url': 'environmentPropertiesDialog.html'}, {'title': 'textureDialog', 'text': "\n \n \n \n \n Texture dialog \n The texture dialog allows you to view and modify properties related to a texture attached to a  shape . It is accessed by clicking the  Set texture -item in the  shape properties  dialog:\n \n \n [Texture dialog] \n \n A texture is a bitmap image that can be applied to surfaces in order to make them look  more real . Imagine applying a brick texture to a rectangular surface in order to make it look like a brick wall. Following figure illustrates a textured surface:\n \n \n [Textured surface] \n \n \nThe default way CoppeliaSim applies textures to a shape is by projecting it onto the shape's x/y plane as shown in following figure:\n \n \n [Default texture projection method] \n \n Following 5 texture mapping methods are supported: \n Projection   mapping : the texure is simply projected onto the X-Y plane of the object (see here above). Texture coordinates will be calculated. \n Cylindrical mapping : the texure is wrapped around the object's Z axis. Texture coordinates will be calculated. \n Spherical mapping : the texure is spherically mapped onto the object. Texture coordinates will be calculated. \n Box mapping : the texure is applied to all 6 faces of a box-like object. Texture coordinates will be calculated. \n Imported texture coordinates : specific texture coordinates can be imported at the same time as the mesh is  imported , via the OBJ or DAE file format. \n Following figure illustrates the 5 mapping methods: \n \n [Texture mapping methods: A) projection, B) cylindrical, C) spherical, D) box, E) imported texture coordinates] \n \n When loading a new texture, following dialog will open: \n \n [Texure scaling dialog] \n \n It is recommended to keep the default settings, in order to keep compatibility to older graphic cards high (when  Scale textures to  is checked, all textures will anyway be resized to a power of 2), and file sizes low. \n Once a texture is in memory, it can be  scaled, shifted and rotated before the actual mapping takes place, in order to obtain the desired visual appearance.  \n Static textures can be loaded by clicking the  Load new texture  button. Following file formats are currently supported: \n JPEG \n PNG \n TGA \n BMP \n TIFF \n GIF \n Instead of loading textures from file, you can also select already loaded static textures, or even dynamic textures generated by  vision sensors . Just click the  Select texture from existing textures  button. Note that dynamic textures will only properly be displayed during simulation (and also only if the related vision sensor is properly handled). \n \n \n \n \n", 'tags': '', 'url': 'textureDialog.html'}, {'title': 'entities', 'text': '\n \n \n \n \n Entities \n An entity is a term that refers to a  scene object  or a  collection . Following figure illustrates the relationship between scene objects, collections and entities: \n \n \n [Entities: scene objects and collections] \n \n \n \n \n', 'tags': '', 'url': 'entities.html'}, {'title': 'collections', 'text': "\n \n \n \n \n Collections \n A collection is a user-defined collection of  scene objects . Both collections and scene objects are  entities . Collections are useful when referring to several objects like a robot for instance, when performing a specific operation, such as  checking for collision  between two robots: if a collision detection pair was defined as (collectionRobot1; collectionRobot2), then the collision checking algorithm would check whether any object from the first collection interferes with any object from the second collection. \n \n Collections are  collidable ,  measurable  and  detectable  entities. This means that collections: \n can be used in  collision detections  against other collidable entities. \n \n can be used in  minimum distance calculations  with other measurable entities. \n \n can be detected by  proximity sensors .  \n Even if a collection is collidable, measurable and detectable, this doesn't mean that all objects contained in the collection are collidable, measurable and detectable: \n During collision detection, only the collidable objects of a collection (subset of the collection) are tested against another collidable entity. \n During distance measurement, only the measurable objects of a collection (subset of the collection) are measured against another measurable entity. \n Only the detectable objects of a collection (subset of the collection) can be detected by proximity sensors. \n A collection can however override the collidable, measurable and detectable properties of its objects. \n \n A collection is defined by one or several items that can be combined in an additive or subtractive manner. Following items are supported: \n a single object \n a tree of objects: this item represents all descendants of a single object (located at the tree root). If the tree grows or shrinks, the item will dynamically grow/shrink too. \n a chain of objects: this represents all objects encountered when following all ancestors of a single object, If the chain grows or shrinks, the item will dynamically grow/shrink too. \n all scene objects \n A collection is not static, and is constantly evaluated/updated to determine its containing objects. A given collection can also be defined in many different ways, depending on specific needs: \n \n [Example collection containing 4 objects (the colored objects] \n \n Above collection could be defined as a combination of 4 items, resulting in following code: \n \n-- Collection defined as: <object2> + <object4> + <object6> + <object7>\n\nlocal object2=sim.getObject('/object2')\nlocal object4=sim.getObject('/object4')\nlocal object6=sim.getObject('/object6')\nlocal object7=sim.getObject('/object7')\ncollectionHandle=sim.createCollection(0)\nsim.addItemToCollection(collectionHandle,sim.handle_single,object2,0)\nsim.addItemToCollection(collectionHandle,sim.handle_single,object4,0)\nsim.addItemToCollection(collectionHandle,sim.handle_single,object6,0)\nsim.addItemToCollection(collectionHandle,sim.handle_single,object7,0) \n But a similar collection could also be defined as a combination of following 3 items too: \n \n-- Collection defined as: <all objects> - <tree starting at object1> + <object6>\n\nlocal object1=sim.getObject('/object1')\nlocal object6=sim.getObject('/object6')\ncollectionHandle=sim.createCollection(0)\nsim.addItemToCollection(collectionHandle,sim.handle_all,-1,0)\nsim.addItemToCollection(collectionHandle,sim.handle_tree,object1,1)\nsim.addItemToCollection(collectionHandle,sim.handle_single,object6,0) \n See also the  API functions related to collections . \n \n \n \n \n", 'tags': '', 'url': 'collections.html'}, {'title': 'objects', 'text': "\n \n \n \n \n Scene objects \n The main elements in CoppeliaSim that are used for building a simulation  scene  are scene objects (objects in short). Objects are visible in the  scene hierarchy  and in the scene  view . In the scene view, objects have a three dimensional representation as illustrated in following figure:\n \n \n [Object types in CoppeliaSim and their three dimensional representation] \n \n \nFollowing list gives a brief functional description of each object type:\n \n Shapes : a shape is a rigid mesh that is composed of triangular faces.  \n Joints : a joint object is a joint or actuator. Four types are supported: revolute joints, prismatic joints, screws and spherical joints.  \n Graphs : a graph is used to record and visualize simulation data.  \n Dummies : a dummy is a point with orientation. Dummies are multipurpose objects that can have many different applications.  \n Proximity sensors : a proximity sensor detects objects in a geometrically exact fashion within its detection volume. CoppeliaSim supports pyramid-, cylinder-, disk-, cone- and ray-type proximity sensors.  \n Vision sensors : a vision sensor is a camera-type sensor, reacting to light, colors and images.  \n Force sensors : a force sensor is an object able to measure forces and torques that are applied to it. It also has the ability to  break  if a given threashold is overshot.  \n Cameras : a camera is an object that allows  seeing  the simulation scene from various view points.  \n Lights : a light is an object that allows illuminating the simulation scene.  \n OC trees : an OC tree is a spacial partitioning data structure made up by voxels. \n Point clouds : a point cloud is an OC tree structure that contains points. \n Paths : a path is a succession of points with orientation in space. As path is a  pseudo scene object , since it is built using merely dummies and a  customization script  that describes its functionality and behaviour.  \n \nSome of above objects can have special properties allowing other objects or  various functionality  to interact with them. Objects can be:  \n Collidable : collidable objects can be tested for  collision  against other collidable objects.  \n Measurable : measurable objects can have the  minimum distance  between them and other measurable objects calculated.  \n Detectable : detectable objects can be detected by  proximity sensors .  \n Viewable : viewable objects can be  looked through ,  looked at , or their image content can be visualized in views. Refer to the  pages and views-section  for more information  \n Each object has a position and orientation within the simulation scene. We refer to an object's position and orientation as configuration of the object. Objects can be attached to other objects (or built on top of each other). If object A is built on top of object B, then object B is the parent and object A is the child. To create a parent-child relationships between object B and object A, select object A, then select object B (the selection order is important). Then select [Menu bar --> Edit --> Make last selected object parent]. Following figure illustrates this operation: \n \n \n [(1) Before attaching object A to object B, (2) after attaching object A to object B] \n \n Alternatively, you can drag and drop an object onto another one in the  scene hierarchy  to obtain a similar result. Notice that object A's configuration was not changed (both objects kept their respective configuration). However, looking at the scene hierarchy, you can see that object A became child of object B. If you now move object B, object A will automatically follow, since object A is attached to object B. Object A can be detached by selecting it, then selecting [Menu bar --> Edit --> Make selected object(s) orphan]. Doing so will detach object A without changing its configuration. Alternatively, you can drag and drop an object onto the world icon to obtain a similar result. \n \n Every object has an absolute configuration (or cumulative configuration) that is relative to the world's reference frame, and a local configuration (or relative configuration) that is relative to the parent object's reference frame. In above example, when object A became child of object B, object A's absolute configuration didn't change, but its local configuration was modified. \n \n The absolute configuration of the last selected object is displayed in the  information text . To modify or adjust the absolute or local configuration of an object, refer to the  coordinates and transformations dialog  and the section on  object position/orientation manipulation . \n \n \n \n \n \n", 'tags': '', 'url': 'objects.html'}, {'title': 'sceneObjectPropertiesDialog', 'text': '\n \n \n \n \n Scene object properties \n The  scene object  properties dialog is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n The scene object properties dialog displays properties related to objects (i.e.  scene objects ). The dialog is context sensitive and its content will mainly depend on the scene object selection state: only the properties of the last selected object will be displayed. Those properties are divided into 2 parts: \n Object-type specific properties: properties specific to the selected object type. See further below for details. \n Object common properties : properties common to all object types. \n 2 buttons in the upper part of the dialog allow selecting the desired type of properties to display. If the object selection is empty, then all dialog items will be inactive. \n \n \n [Scene object properties dialog, currently displaying the object common properties] \n \n The object-type specific properties part of the dialog will display one of following dialogs, depending on the type of the last selected object: \n The camera properties \n The light properties \n The shape properties \n The joint properties \n The dummy properties \n The graph properties \n The proximity sensor properties \n The vision sensor properties \n The force sensor properties \n \n \n \n \n', 'tags': '', 'url': 'sceneObjectPropertiesDialog.html'}, {'title': 'commonPropertiesDialog', 'text': "\n \n \n \n \n Object common properties \n The object common properties dialog is part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Common  button to display the object common properties dialog. The dialog displays the settings and parameters of the last selected  object . If no object is selected, the dialog is inactive. If more than one object is selected, then some parameters can be copied from the last selected object to the other selected objects ( Apply to selection -buttons): \n \n \n [Object common properties dialog] \n \n Selectable : indicates whether the object can be selected in the scene. Objects can always be selected in the  scene hierarchy . Refer also to the  sim.setObjectProperty  function.\n \n Invisible during selection : when enabled, then the object will be invisible for the selection process (i.e. you will be able to select  through  the object). \n Ignored by depth pass : when enabled, then the object will be ignored during the depth rendering pass. The depth rendering pass is used to correctly position the red sphere for camera movements. \n Select base of model instead : if enabled, then selecting the object in the scene will select its first parented object marked as  object is model base  instead (see further down). This property is convenient when protecting a model from faulty manipulations, allowing it to be manipulated as a single entity together with other objects. Refer to the  section on models  and also to the  sim.setObjectProperty  function.  \n \n Ignored by model bounding box : when selected, and the object is part of a  model , then the model bounding box (i.e. model selection bounding box) will not encompass that object. This is useful for invisible objects that might make the model bounding box appear too big. This property has no functional effect. Refer also to the  sim.setObjectProperty  function. \n \n Ignored for view-fitting : objects with this item selected will not be taken into account when fitting a scene to a view while no object is selected. Usually floors and similar will be tagged as such. Refer also to the  view fitting toolbar button  and to the  sim.cameraFitToView api function . \n Cannot be deleted during simul. : when enabled, then the object will ignore a deletion operation when a simulation is running (deletion will however still work when triggered via code). \n Cannot be deleted : when enabled, then the object will ignore a deletion operation (deletion will however still work when triggered via code). \n   Extension string : a string that describes additional object properties, mainly used by extension plugins (see also the  sim.getExtensionString  API function). \n Camera visibility layers : each object in CoppeliaSim can be assigned to one or several visibility layers. If there is at least one visibility layer that matches the  layer selection dialog  layers, then the object will be visible when seen from a camera. By default, a  shape  is assigned to the first layer, a  joint  to the second layer, a  dummy  to the third layer, etc.\n \n Object is model base : indicates whether the object should act as the base of a  model . An object flagged as  base of model  has special properties (e.g. copying the object will also automatically copy all its hierarchy tree). Additionally, when such an object is selected, the selection bounding box is displayed as thick stippled lines, encompassing the whole model. Refer also to the  select base of model instead  item above. Additionally, a model will share a same identifier with all of its copies or clones. A model can then transfer its DNA (i.e. share an instance of itself) to all of its clones, via the transfer DNA  toolbar  button. Imagine having 100 same robots in your scene that you  want to modify in a similar way: simply modify one of them, select it, then click the transfer DNA toolbar button.  \n \n [DNA transfer toolbar button] \n \n Edit model properties : allows opening the  model dialog .  \n Collidable : allows enabling or disabling  collision detection  capability for the selected  collidable object . \n Measurable : allows enabling or disabling  minimum distance calculation  capability for the selected  measurable object . \n Detectable : allows enabling or disabling  proximity sensor  detection capability for the selected  detectable object . \n Collection self-collision indicator : when performing collision (or minimum distance) calculations between two identical collections, CoppeliaSim will normally check all collection items against all other items in that collection. In some situation, such as a kinematic chain, one doesn't want to check consecutive links, since they might be constantly colliding at the interface. In that case, you can use the collection self-collision indicator: two items of a same collection will not be checked against each other if their indicator difference is exactly 1, 10, 100,  1000, 10000 or 100000, as can be seen on following figure:\n \n \n [Collection self-collision indicators] \n \n Scaling : objects or models can be scaled in a flexible way in CoppeliaSim. The size of an object or model, and all related properties are scaled appropriately (e.g. joint ranges, velocity settings, masses, etc.) so that the scaled object or model can normally continue to operate (but at a different scale).  \n \n Assembling : opens a dialog that allows to specify how the  assembling toolbar button  will handle the object during assembly (if objects are assembled in a different way than via the assembling toolbar button, then following settings will have no influence): \n \n [Assembling behaviour dialog] \n \n Required match values for parent : the object can be attached to another object (i.e. become another object's child), but only if one of the listed  required match values for parent  matches one of its new parent's  required match values for child  values. This feature is useful in order to set a fixture compatibility criteria (e.g. gripper A can only be attached with a robot that has a tooltip of type A). \n Required match values for child : the object can have another object attached to itself  (i.e. become another object's parent), but only if one of its  required match values for child  matches  one of its new child's  required match values for parent  values. This feature is useful in order to set a fixture compatibility criteria (e.g. gripper A can only be attached with a robot that has a tooltip of type A). \n When assembling, a specific local transform. matrix will be applied : if checked, then the object won't stay in place when assembled: a specific transformation matrix will be used as its new local transformation matrix. By default that matrix is the identity matrix, but you can specify a specific matrix by clicking  Set matrix .  This feature is useful in order to automatically position and orient an object correctly in relation to its new parent (e.g. in order to have a gripper automatically placed correctly at a robot's tooltip) \n The object selection order is important for assembly operations, i.e. first select the  to-become-child-object , then the  to-become-parent-object . If the selection order is wrong, or if the  to-become-parent-object  is not appropriate, then CoppeliaSim will try to guess what the real intention of the user was (e.g. by searching for an appropriate match in the  to-become-parent-object 's descendents), if there is no ambiguity. \n \n \n \n \n", 'tags': '', 'url': 'commonPropertiesDialog.html'}, {'title': 'collidableObjects', 'text': '\n \n \n \n \n Collidable objects \n Collidable objects are  objects  that can be tested for  collision  against other collidable objects, i.e. that will register a collision state. This does not mean that they will respond to collision (i.e.  respondable ), which is something different. Collidable objects include: \n Dummies \n Shapes \n OC trees \n Point clouds \n Dummies and point clouds, since point-based, can only collide against OC trees (which are volume-based). \n \n Collections  are also collidable, since they might contain collidable objects.  \n Collidable objects can have their  collidable property  individually enabled or disabled (enabled by default for non-pure shapes, OC trees and point clouds). This can be set in the  object common properties  or through the  sim.setObjectSpecialProperty   API  function. \n \n Additionally, collidable objects can have their  collidable property  overridden depending on their related  model properties  (if they are part of a  model ). Refer to the  model  dialog  for more information. \n \n \n \n \n \n', 'tags': '', 'url': 'collidableObjects.html'}, {'title': 'measurableObjects', 'text': '\n \n \n \n \n Measurable objects \n Measurable objects are  objects  that can be used for  minimum distance calculation  against other measurable objects. They include:\n \n Dummies \n Shapes \n OC trees \n Point clouds \n \n Collections  are also measurable, since they might contain measurable objects.  \n Measurable objects can have their  measurable property  individually enabled or disabled (enabled by default for non-pure shapes, OC trees and point clouds). This can be set in the  object common properties  or through the  sim.setObjectSpecialProperty   API  function. \n \n Additionally, measurable objects can have their  measurable property  overridden depending on their related  model properties  (if they are part of a  model ). Refer to the  model dialog  for more information. \n \n \n \n \n', 'tags': '', 'url': 'measurableObjects.html'}, {'title': 'detectableObjects', 'text': '\n \n \n \n \n Detectable objects \n Detectable objects are  objects  that can be detected by  proximity sensors . They include:  \n Dummies \n Shapes \n OC trees \n Point clouds \n Dummies and point clouds, since point-based, can not be detected by ray-type or randomized-type proximity sensors. \n Detectable objects can be detected by all proximity sensors, or only by specific types of proximity sensors, or a sub-category of proximity sensors as listed: \n \n Ultrasonic proximity sensors \n Infrared proximity sensors \n Laser proximity sensors \n Inductive proximity sensors \n Capacitive proximity sensors \n \n Collections  are also detectable, since they might contain detectable objects.  \n Detectable objects can have their  detectable property  individually enabled or disabled, and this for all types of proximity sensors (enabled by default for non-pure shapes). This can be set in the  object common properties  or through the  sim.setObjectSpecialProperty   API  function. \n \n Additionally, detectable objects can have their  detectable property  overridden depending on their related  model properties  (if they are part of a  model ). Refer to the  model dialog  for more information. \n \n \n \n \n \n', 'tags': '', 'url': 'detectableObjects.html'}, {'title': 'viewableObjects', 'text': '\n \n \n \n \n Viewable objects \n Viewable objects are  objects  that can be  looked through  ,  looked at , or that can display some image content. They include:  \n   Cameras \n   Vision sensors \n Viewable objects can be associated with  views  that will display their image content. \n \n \n \n \n', 'tags': '', 'url': 'viewableObjects.html'}, {'title': 'convexHull', 'text': '\n \n \n \n \n Convex hull \n CoppeliaSim allows calculating and adding the convex hull of specified  objects . The convex hull of a collection of meshes is the smallest convex envelope that encompasses all meshes. CoppeliaSim allows extracting the convex hull of  measurable objects  only. The calculated convex hull might not be "water-tight" (i.e. might contain overlapping triangles or non-shared edges), thus the shape will not be marked as convex. You can however run a  convex decomposition function  on the generated shape.  \n To add a convex hull, select objects that you want to have included in the convex hull and select [Menu bar --> Add --> Convex hull of selection] \n \n Depending on situations, convex hulls can drastically reduce calculation times in case of  distance calculations  or  proximity sensor  simulations for instance.  Collision detection  can also be performed faster if a rougher approximation (i.e. the convex hull) of a complex  shape  is used instead. One can also extract the convex hull of a  model  (e.g. robot), then make it invisible, but perform all calculations (collision detection, distance calculations, etc.) using the invisible convex hull instead of the complex model. \n \n \n [Objects forming a robot model (left) and corresponding simplified representation as convex hull (right)] \n \n \n \n \n', 'tags': '', 'url': 'convexHull.html'}, {'title': 'layerSelectionDialog', 'text': "\n \n \n \n \n Layer selection dialog \n The layer selection dialog is a convenient way to show or hide specific parts of a  scene . Each  scene object  can be assigned to any of the 16 available visibility layers (refer to the  object common properties ). Using this dialog, you can activate/deactivate each layer individually. If some objects should be invisible, try hiding them in a non-activated layer (e.g. current layer+8). When saving a scene, always try to stick to the default activation state (all 8 first layers enabled, the last 8 layers disabled). The reason for this is that if you copy and paste a  model  from your scene into another scene, then some objects that were supposed to be invisible might become suddenly visible.\nDuring simulation the dialog offers the possibility to only display the scene's dynamic content ( Visualize only dynamic content ), which oftentimes is helpful for debugging purpose. \n The layer selection dialog can be accessed with [Menu bar --> Tools -->Layers] or by clicking following toolbar button: \n \n \n [Layer selection dialog toolbar button] \n \n \n [Layer selection dialog. All layers are activated except for layers 9-16 (default)] \n \n \n \n \n", 'tags': '', 'url': 'layerSelectionDialog.html'}, {'title': 'cameras', 'text': "\n \n \n \n \n Cameras  \n Cameras are  viewable objects , which means that you can  look through  them and display a view of what they are  looking at . You can have as many cameras as needed in your  scene , each one of them offering a different  view  of the scene. Following shows an example of a scene containing several cameras: \n \n \n [Scene displaying views of three different cameras] \n \n Make sure not to mix-up cameras with  vision sensors . Following are the main differences:  \n A camera has no specific resolution (i.e. it adjusts automatically to the view size). A vision sensor has a fixed resolution. \n A camera's image content is not directly available via the  API  (but via a callback mechanism), and image processing not directly supported. A vision sensor's image content can be accessed via the API, and processed via the  vision callback functions . \n A camera generally requires less CPU time and operates faster than vision sensors.  \n A camera can display all  object types . A vision sensor mainly displays  shapes . \n A camera can be added to the scene with [Menu bar --> Add --> Camera]. However adding a camera in this way will add the  object  in a default position and orientation. It is a better practice to add cameras by right-clicking on a specific view of a scene and selecting [Popup menu --> Add --> Camera]. This will add the object just in front of the current view. The added camera is automatically selected and you can then  look through it  with [Popup menu --> View --> Associate view with selected camera]. For this to work you will have to make sure the popup menu is activated on a view. When a view is created but not yet associated with a viewable object, the [Popup menu --> Add --> Camera] command will add a camera and directly associate it with the view (i.e.  look through it ). A camera can be associated with any number of views. \n \n Alternatively you can also associate a view with a camera by activating following popup in a view: [Popup menu --> View --> View selector..]. This will allow you to select the desired camera view from a preview window. When a camera is associated with a view, it can be manipulated with the mouse with following toolbar buttons: \n \n \n [Camera navigation toolbar buttons: pan, rotate, shift, zoom, and fit-to-view] \n \n Pan button : allows shifting the camera in a perpendicular plane to the view direction. The clicked point in the scene will shift at the same rate as the mouse movement. If no specific point is clicked (i.e. when the background is clicked), the shift operation will be performed for an invisible point close to the camera. \n \n Rotate button : allows rotating the camera about the clicked point in the scene. If no specific point is clicked (i.e. when the background is clicked), the rotate operation will be performed about an invisible point close to the camera. \n \n Shift button : allows shifting the camera along the view direction. This has a zoom effect on camera views that are in perspective projection mode, but camera views in orthogonal projection mode might not see any effect (the cameras will however be shifted along their view direction). \n \n Camera angle button : allows adjusting the perspective projection angle of a camera view (when in perspective projection mode), or allows adjusting the view size of a camera view (when in orthogonal projection mode). \n \n Fit-to-view button : adjusts the camera of the view that has the focus in order to nicely frame all selected objects, or the entire scene if no object is selected. \n \n While the left mouse button allows above operations, the wheel of the mouse allows shifting the camera along the view direction (if the camera view is in perspective projection mode) or allows adjusting the view size of the camera view (if the camera view is in orthogonal projection mode). The right button, when clicked without a mouse movement will activate a popup menu, however, if the right button is kept pressed while moving the mouse, a camera rotation about the clicked point can be achieved. \n \n When the camera shift button is activated, it is very easy to navigate in the scene to any desired position and orientation using: (1) the left mouse button for shifting perpendicular to the view direction, (2) the mouse wheel for shifting along the view direction, and (3) the right mouse button for rotating about the clicked point: \n \n \n [Default camera navigation: (1) pan with left mouse button, (2) shift with mouse wheel, (3) rotate with right mouse button] \n \n Cameras can automatically track objects (i.e. follow them as they move) by selecting the object to track, then selecting in the appropriate view [Popup menu --> View --> Track selected object]. A tracking camera will keep its position, but automatically adjust its viewing direction in order to always keep the object to track in its view field. This is different from having a camera attached to that object through a parent-child relationship.\n \n \n \n \n \n", 'tags': '', 'url': 'cameras.html'}, {'title': 'cameraPropertiesDialog', 'text': "\n \n \n \n \n Camera properties  \n The camera properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Camera  button to display the camera dialog (the  Camera  button only appears if the last selection is a  camera ). The dialog displays the settings and parameters of the last selected camera. If more than one camera is selected, then some parameters can be copied from the last selected camera to the other selected cameras ( Apply to selection -buttons): \n \n \n [Camera  dialog] \n \n   Orthographic size : the orthographic projection size (or view size) of a camera. The effect of this parameter can only be seen if the associated view is in orthographic projection mode. \n \n   Near / far clipping plane : distance from the camera origin point from which the camera starts / stops  seeing . If close / far objects should not be displayed, increase / reduce this value. These parameters are directly linked with the rendering precision, especially when an associated view is in perspective projection mode, then you should always be careful not to have a too big gap between the far and near clipping planes, otherwise you might experience some visual artifacts known as  z-fighting  (when surfaces or pixels farther away appear to overlap surfaces/pixels closer to the camera). \n \n   Render mode : the render mode of the camera. \n   Tracked object : object to be tracked by the camera. Tracking an object will not influence the camera's position, only its orientation will be automatically adjusted in order to  follow  the tracked object.\n \n Perspective mode : allows selecting between the perspective projection type and the orthogonal projection type camera. \n   Parent as manipulation proxy : if enabled, then the camera manipulation toolbar buttons will not affect the camera's position directly, but instead will affect the camera's parent object. This option is useful if you wish to have several cameras linked to each other (e.g. the default scene in CoppeliaSim has 3 cameras arranged orthogonally to each other. If one is moved, the two others will follow) \n \n   Along own X- / Y- / Z-axis : allows specifying which camera translation movements are allowed. \n \n   Full rotation : if selected, then the camera is not limited in angular movements. \n \n   Tilting : if selected, then the camera can be tilted with the corresponding toolbar button. \n \n   Object size : size of the camera. This parameter has only a visual effect and no functional meaning. \n   Adjust color : allows adjusting a camera's color. \n Show view frustum : if selected, the view frustum (volume) is shown. \n \n \n \n \n \n", 'tags': '', 'url': 'cameraPropertiesDialog.html'}, {'title': 'lights', 'text': "\n \n \n \n \n Lights  \n Lights are  objects  which allow you to light a  scene . Without any light in the scene, objects appear in unshaded colors (in that case objects are only illuminated with an ambient light component that can be set in the  environment dialog ). Following figure illustrates the effect of lights in a scene:  \n \n [Scene illuminated (1) with ambient light only, (2) with a directional light, (3) with a spotlight] \n \n There can be up to eight active lights in a scene. There are three different types of lights:\n \n Omnidirectional lights : an omnidirectional light will illuminate the scene from a point light source.\n \n Spotlights : a spotlight will illuminate the scene only in one specific direction. You can adjust the light cone of a spotlight.\n \n Directional lights : a directional light's position is not important. Only the direction has importance and all objects in a scene will be illuminated in a similar fashion.\n \n \n [(1) omnidirectional light, (2) spotlight, (3) directional light] \n \n A light can be added to the scene with [Menu bar --> Add --> Light].\n \n \n \n \n \n", 'tags': '', 'url': 'lights.html'}, {'title': 'lightPropertiesDialog', 'text': "\n \n \n \n \n Light properties  \n The light properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Light  button to display the light  dialog (the  Light  button only appears if the last selection is a  light ). The dialog displays the settings and parameters of the last selected light. If more than one light is selected, then some parameters can be copied from the last selected light to the other selected lights ( Apply to selection -buttons): \n \n \n [Light dialog] \n \n   Light is enabled : enabled or disables a light. A maximum of 8 enabled lights can exist at the same time in a  scene .\n \n   Light is local : when this item is selected, then the light will act as a local light, and only operate when seen through a  camera  or  vision sensor  that uses local lights (i.e. the camera or vision sensor's  use local lights  item needs to be enabled). In addition to that, the light needs to be built on top of that camera or vision sensor (the light beeing the direct or indirect child). \n   Spot cutoff : in the case the light is a spotlight, this value specifies the cuttoff angle of the light. Small angles result in narrow spotlights. \n \n   Spot exponent : in the case the light is a spotlight, this value specifies the intensity distribution of the light. 0 results in a wide spotlight, 128 results in a narrow spotlight. \n \n   Constant attenuation factor : parameter indicating the constant attenuation factor of the light. \n \n   Linear attenuation factor : parameter indicating the linear attenuation factor of the light. \n \n   Quadratic attenuation factor : parameter indicating the quadratic attenuation factor of the light. \n \n   Object size : size of the light. This parameter has only a visual effect and no functional meaning. \n   Adjust light / casing color : allows adjusting a light color, or casing color. \n \n \n \n \n", 'tags': '', 'url': 'lightPropertiesDialog.html'}, {'title': 'shapes', 'text': "\n \n \n \n \n Shapes  \n Shapes are rigid mesh  objects  that are composed of triangular faces. They can be  imported/exported  and  edited . They come in four different sub-types:\n \n   Simple random shape : can represent any mesh. It has one color and one set of visual attributes. Not optimised nor recommended for  dynamics collision response calculation  (since very slow and unstable). \n   Compound random shape : can represent any mesh. It has several colors and sets of visual attributes. Not optimised nor recommended for dynamics collision response calculation (since very slow and unstable).  \n   Simple convex shape : represents a convex mesh with  one color and one set of visual attributes. Optimized for dynamics collision response calculation (but pure shapes are recommended).\n \n   Compound convex shape : represents a group of convex meshes with several colors and sets of visual attributes. Optimized for dynamics collision response calculation (but pure compound shapes are recommended).\n \n   Pure simple shape : represents a primitive shape (cuboid, cylinder or sphere (with additional variations depending on the used physics engine). A pure simple shape (or pure compound shape) is best suited for dynamics collision response calculation, since it will perform very fast and is stable. See the  dynamics  section for more information. \n \n   Pure compound shape : represents a group of primitive shapes (cuboid, cylinder or sphere). A pure compound shape (or pure simple shape) is best suited for dynamics collision response calculation, since it will perform very fast and is stable. See the  dynamics  section for more information. \n \n   Heightfield shape : can represent a terrain as a regular grid, where only the heights change. Heightfields can also be considered as pure simple shapes, and are optimized for dynamics collision response calculation. \n \n By default, all imported shapes are simple shapes. Two or more simple shapes or compound shapes can however be grouped ([Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]) or ungrouped ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]). Simple shapes can also be merged ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes] in which case the visual properties become same for all composing elements. A shape can also be divided ([Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]), depending on its configuration: the division algorithm will extract each distinct element of a shape. Two elements are distinct if they don't share any common edge. Refer also to the  model tutorial . which illustrates how to correctly import and prepare shapes for a simulation model. \n \n \nPure shapes are mainly functional shapes. They are most of the time only used by the physics engine that performs on them much better and faster than on non-pure shapes (e.g. random or convex meshes). For that reason, pure shapes are often hidden in an invisible layer (e.g. layer 9). Refer to the  layer selection dialog  and  the section on  how to design dynamic simulations  for more information. \n \n [(a) 5 simple shapes (e.g. after import), (b) 1 simple shape (after merging), (c) 1 compound shape (composed by 5 simple shapes)] \n \n Pure simple shapes can also be grouped, the resulting compound shape will however only be pure if all of its composing elements are also pure. Merging pure simple shapes will result in a non-pure simple shape. \n Shapes are  collidable ,  measurable  and  detectable  objects. This means that shapes: \n can be used in  collision detections  against other collidable objects. \n can be used in  minimum distance calculations  with other measurable objects. \n can be detected by  proximity sensors .  \n The collidable, measurable and detectable properties of a shape can be altered in the  object common properties . Additionally, those properties can be overridden if the shape is part of a  model  which overrides them. Refer to the  model dialog  for more information. \n The shape calculations (i.e. collision, distance and proximity sensor calculations) available in CoppeliaSim are also available as stand-alone routines via the  Coppelia geometric routines . \n \n \n \n \n", 'tags': '', 'url': 'shapes.html'}, {'title': 'shapeReferenceFrames', 'text': "\n \n \n \n \n Shape reference frame and bounding box \n A  shape  has a reference frame and a bounding box, as does every  object . The reference frame or coordinate frame is always located at the geometric center of the shape and indicates the point where the shape's position and orientation is calculated from. The coordinate frame has 3 axes: x-, y- and z-axis, corresponding to the red, green and blue arrows respectively. The shape's bounding box is centered around the shape's reference frame and has the same orientation as the reference frame (the x-, y- and z-axis have the same orientation as the bounding box's edges). The bounding box encompasses entirely the shape. The user can select from 4 different ways to define a shape's reference frame and bounding box orientation ( pure simple shapes  and  heightfield shapes  cannot be reoriented):\n \n Align with reference frame of world : [Menu bar --> Edit --> reorient bounding box --> with reference frame of world]. When this item is clicked (a shape must previously be selected), the coordinate frame will be computed in order to produce a bounding box with edges aligned with the world's reference frame axes (i.e. the absolute coordinate frame).  \n \n Align with main axes of random shape : [Menu bar --> Edit --> Reorient bounding box --> with main axes of random shape]. When this item is clicked (a shape must previously be selected), the reference frame will be computed in order to produce the most compact bounding box around a random shape. This is the default calculation method. \n \n Align with main axis of cylinder shape : [Menu bar --> Edit --> Reorient bounding box --> with main axis of cylinder shape]. When this item is clicked (a shape must previously be selected), a precise reference frame will be computed on a cylinder shape, with its Z-axis coinciding with the cylinder's revolute axis. This is more precise than above item ( align with main axes of random shape ), but requires a precisely defined cylinder shape. The operation can fail if the shape appears to be too far from a regular and precise cylinder. \n \n Align with main axes of cuboid shape : [Menu bar --> Edit --> Reorient bounding box --> with main axes of cuboid shape]. When this item is clicked (a shape must previously be selected), a precise reference frame will be computed on a cuboid shape, aligned with the cubid's faces. This is more precise than above item ( align with main axes of random shape ), but requires a precisely defined cuboid shape. The operation can fail if the shape appears to be too far from a regular and precise cuboid. \n \n \nThe bounding box orientation relative to its shape can also be modified in the  geometry dialog  or via the  API .  \n \n [Two same shapes. The top one's ref. frame is aligned with the world, the bottom one's ref. frame is aligned with the shape's main axes] \n \n \n \n \n", 'tags': '', 'url': 'shapeReferenceFrames.html'}, {'title': 'primitiveShapes', 'text': "\n \n \n \n \n Primitive shapes \n Next to  importing meshes  from an external file,  shapes  can also directly be created inside CoppeliaSim by selecting [Menu bar --> Add --> Primitive shape]:\n \n \n [Primitive shapes] \n \n \nGeometric parameters of the primitive shapes can be adjusted in the primitive shape dialog:\n \n \n [Primitive shape dialog] \n \n X- / Y- / Z-size : size along the world reference frame's x- / y- / z-axis.\n \n X- / Y- / Z-Subdivisions : number of elements along the world reference frame's x- / y- / z-axis\n \n Smooth shaded : whether the shape should appear smooth (Gouraud shading) or sharp.\n \n Open ends : whether the cylinder has open ends.\n \n Sides : number of sides of a cylinder, disc or sphere.\n \n Face subdivisions : number of face subdivisions of a cylinder.\n \n Disc subdivisions : number of disc subdivisions (disc or cylinder)\n \n Dynamic and respondable : if selected, the generated shape will be dynamically enabled, i.e.  dynamic and respondable .  Those properties can be changed at a later time too. \n \n Material density : the density of the material.\n \n The subdivisions and faces properties cannot directly be seen and have not a direct effect. Following shows two similar shapes with different subdivision parameters:\n \n \n [Two cuboids with different subdivision parameters (as seen in the  triangle edit mode )] \n \n Shapes with a higher subdivision count can reflect light in a more differentiated way, depending on the selected renderer. See the  triangle edit mode  and the  Subdivide largest triangles  option for more details.\n \n Colors and other visual attributes should be adjusted in the  shape properties . The shape mesh can also be adjusted and edited in the  shape edit modes , or in the  geometry dialog . \n \n \n \n \n", 'tags': '', 'url': 'primitiveShapes.html'}, {'title': 'convexDecomposition', 'text': "\n \n \n \n \n Convex decomposition \n CoppeliaSim allows calculating and adding the convex decomposition  of specified  shapes . Convex shapes perform faster and are more stable that random shapes, in regards to dynamic collision response calculation. They are however not as fast nor as stable as  pure shapes !  \n \n [Non-convex model (left) and corresponding convex-decomposed model (right)] \n \n You can either add the convex decomposition of selected shapes, or you can morph selected shapes into their convex decomposition equivalent: \n adding the convex decomp.  : [Menu bar --> Add --> Convex decomposition of selection...] \n morphing into convex decomp.  : [Menu bar --> Edit --> Morph selection into its convex decomposition...] \n Following dialog pops open and allows adjusting the way shapes are decomposed: \n \n [Convex decomposition parameter dialog] \n \n Following parameters are applied for each individual shape: \n Handle compound shape components individually : when checked, then each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single mesh. \n Max. iterations : the convex decomposition algorithm operates in an approximate way, which means that created shapes might be more or less convex. CoppeliaSim uses its own convexivity measure: a shape is considered convex only if all of its vertices lie within the half-volumes defines by all triangular faces, and this with a tolerance of 1.5% of the shape's average bounding box side length. The  max. iterations  parameter allows to iterate several times over the created meshes if they don't appear as convex enough to CoppeliaSim. \n HACD convex decomposition : enable the HACD algorithm. \n Add extra points : specifies whether extra points should be added when computing the concavity. \n Add extra face points : specifies whether faces points should be added when computing the concavity. \n Min. nb of clusters : specifies the minimum number of clusters to be generated \n Max. concavity : specifies the maximum allowed concavity. \n Max. connection distance : specifies the maximum allowed distance to get convex clusters connected. \n Target nb of triangles of decimated mesh : specifies the targeted number of triangles of the decimated mesh. \n Max. nb of vertices / convex hull : specifies the maximum number of vertices for each generated convex hull. \n Small cluster detection threshold (%) : specifies the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface. \n V-HACD convex decomposition : enable the V-HACD algorithm. \n PCA enabled : enable/disable normalizing the mesh before applying the convex decomposition. \n Voxel-based : if enabled, then voxel-based approximate convex decomposition is used, otherwise a tetrahedron-based approximate convex decomposition is used. \n Resolution : maximum number of voxels generated during the voxelization stage. \n  <li class=tab><strong>Depth</strong>: maximum number of clipping stages. During each split stage, all the   model parts (with a concavity higher than the user defined threshold)   are clipped according the <em>best</em> clipping plane.</li>  \n Concavity : maximum concavity. \n Plane downsampling : controls the granularity of the search for the  best  clipping plane. \n Convex hull downsampling : controls the precision of the convex-hull generation process during the clipping plane selection stage. \n Alpha : controls the bias toward clipping along symmetry planes. \n Beta : controls the bias toward clipping along revolution axes. \n  <li class=tab><strong>Gamma</strong>: maximum allowed concavity during the merge stage.</li>  \n Max. number of vertices / convex hull : controls the maximum number of triangles per convex-hull. \n Min. volume / convex hull : controls the adaptive sampling of the generated convex-hulls. \n \n \n \n \n", 'tags': '', 'url': 'convexDecomposition.html'}, {'title': 'shapeProperties', 'text': '\n \n \n \n \n Shape properties \n The shape properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Shape  button to display the shape dialog (the  Shape  button only appears if the last selection is a  shape ). The dialog displays the settings and parameters of the last selected shape. If more than one shape is selected, then some parameters can be copied from the last selected shape to the other selected shapes ( Apply to selection -buttons): \n \n \n [Shape dialog] \n \n Adjust color : allows editing the colors of the shape. \n Shading angle : the shading angle is the angle from which individual faces are distinguished. This only affects the visual appearance of a shape. A small angle makes a shape appear sharp, with many edges, a large angle makes a shape appear smooth and with less edges. \n \n Show edges : displays edges in black. \n \n Backface culling : each triangle composing a shape has an inside and an outside face. When Backface culling is enabled, then inside faces won\'t be displayed. This is a useful parameter for closed shapes and for shapes that are transparent.  \n \n Invert faces : this flips all triangles. Inside faces become outside faces and vice-versa. Convex shapes will become non-convex, except for pure shapes. \n \n Adjust texture : opens the  texture dialog  for the selected shape. When a shape is associated with a texture, it will be displayed in a textured way.\n \n Quick textures (selection) : applies a cubic mapped texture to all selected shapes. This is specially useful with seamless textures used as "dirt", in order to make objects look more realistic. \n Clear textures (selection) : removes the texture from all selected shapes. \n View/modify geometry : opens the  shape geometry dialog  for the selected shape. It allows to adjust various parameters of the mesh. \n Show dynamic properties dialog : toggles the  shape dynamics properties  dialog. The shape dynamics dialog allows to adjust a shape\'s dynamics properties. \n Some of above\'s parameters are only available for simple shapes. When a compound shape is selected, then you can edit its visual attributes by switching to the shape edit mode for compound shapes. You can of course also ungroup it in order to individually edit its components. \n \n \n \n \n', 'tags': '', 'url': 'shapeProperties.html'}, {'title': 'shapeDynamicsProperties', 'text': "\n \n \n \n \n Shape dynamics properties \n The shape dynamics dialog is part of the  shape properties . The dialog displays the dynamics settings and parameters of the last selected  shape . If no object is selected, the dialog is inactive. If more than one shape is selected, then some parameters can be copied from the last selected shape to the other selected shapes ( Apply to selection -buttons): \n \n \n [Shape dynamics dialog] \n \n Body is respondable : if enabled, then the shape will produce a collision reaction with other respondable shapes, however only if the respective respondable masks overlap (see the item below). See also the  designing dynamic simulation  section for more details. \n \n Respondable mask : indicates when a collision response is generated (above respondable item needs however to be enabled). The mask is composed by two 8-bit values, local and global. If two colliding shapes share any of their parents (direct or indirect), then the local masks are used, otherwise the global masks are used. If two shapes'  AND -combined masks (local or global) is different from zero, then a collision response will be generated. \n \n Edit material : allows you to edit  material properties  for all dynamics engines, such as friction, restitution, etc. \n Body is dynamic : when enabled, then the shape's position and orientation will be influenced in a  dynamics simulation . See the  designing dynamic simulation  section for more details. \n \n Set to dynamic if gets parent : when enabled and the shape is attached to another object, then the shape will be automatically made dynamic. This is useful for model bases that should be static when on their own, but dynamic when combined with another model/object (e.g. a robotic manipulator that operates on its own usually has its base static, but when attached to a vehicle, then the base should become dynamic). \n \n Compute mass & inertia properties for the selected shapes : by clicking this button, you can automatically compute the mass and inertia properties of the selected convex shapes, based on a material uniform density. \n \n Mass : the mass of the shape. Selected shapes can have their masses easily increased or decreased by a factor 2 with the  M=M*2 (for selection)  and the  M=M/2 (for selection)  buttons. This is convenient to quickly find stable simulation parameters by trial-and-error.\n \n Principal moments of inertia / mass : the mass-less (i.e. divided by the mass of the shape) principal moments of inertia. Selected shapes can have their mass-less inertia values easily increased or decreased by a factor 2 with the  I=I*2 (for selection)  and the  I=I/2 (for selection)  buttons. This is convenient to quickly find stable simulation parameters by trial-and-error.\n \n Pos./orient. of inertia frame & COM relative to shape frame : the configuration of the inertia frame and center of mass expressed relative to the  shape's reference frame . \n Set inertia matrix & COM relative to absolute frame : opens the inertia matrix dialog, allowing to specify inertia properties relative to the absolute reference frame: \n \n [Object custom data dialog] \n \n Inertia matrix divided by the mass : the inertia matrix or tensor. Values are mass-less (i.e. divided by the mass of the shape). The matrix must be expressed relative to the center of mass of the shape (i.e the matrix is symmetric).\n \n Position of the center of mass : the position of the center of mass \n Apply to selected shapes : when checked, then all selected shapes will have the same inertia properties relative to the absolute reference frame (i.e. all center of masses and inertia matrices will be coincident). \n \n \n \n \n", 'tags': '', 'url': 'shapeDynamicsProperties.html'}, {'title': 'shapeDynamicEngineProperties', 'text': "\n \n \n \n \n Material properties \n The material properties (i.e. dynamics engines properties related to  shapes ) can be accessed via the  shape dynamics properties  dialog. The material properties of the last selected shape are displayed in a dialog: \n \n \n [Dynamics engines properties dialog related to shapes] \n \n Apply predefined settings : allows you to select a set of predefined settings for a specific behaviour (e.g. no friction). \n \n \n \n Bullet properties\n \n Properties related to the  Bullet physics library . Make sure to also refer to the  Bullet user manual  for details. \n Friction (only Bullet V2.78) : a friction value used only with Bullet V2.78. Two colliding objects will have a combined friction value of value1*value2. This does not correspond to the real friction coefficient. \n Friction (after Bullet V2.78) : a friction value used only with Bullet version after V2.78. Two colliding objects will have a combined friction value of value1*value2. This does not correspond to the real friction coefficient. \n Restitution : a restitution value. Higher values tend to make collisions appear elastic. This does not correspond to the real restitution coefficient. \n Linear damping : a linear movement damping value, that adds linear drag, and that can increase stability. \n Angular damping : an angular movement damping value, that adds angular drag, and that can increase stability. \n Sticky contact (only Bullet V2.78) : when this item is checked, then contact points will be very strong, but might lead to instabilities. It is recommended to keep this disabled. This feature is not needed for Bullet versions after V2.78 \n Auto-shrink convex mesh : when this item is checked, then convex meshes will be internally shrunk, in order to compensate the collision margin factor. It is recommended to keep this disabled. \n Custom collision margin factor : when  custom collision margin  is set to true, this factor will override the default collision margin factor. The collision margin can helps improve stability. It is recommended to keep the default collision margin factor. \n \n \n \n ODE properties\n \n Properties related to the  Open Dynamics Engine . Make sure to also refer to the  ODE user manual  for details. \n Friction : a friction value. Two colliding objects will have a combined friction value of value1*value2. This does not correspond to the real friction coefficient. \n Maximum contacts : the maximum number of contact points to generate. Two colliding objects will have a combined maximum contact value of (value1+value2)/2. \n Soft ERP :  the error reduction parameter of          the contact normal , this is useful to make surfaces soft. Two colliding objects will have a combined soft ERP value of (value1+value2)/2. \n Soft CFM :  the constraint force mixing          parameter of the contact normal , this is useful to make surfaces soft. Two colliding objects will have a combined soft CFM value of (value1+value2)/2. \n Linear damping : a linear movement damping value, that adds linear drag, and that can increase stability. \n Angular damping : an angular movement damping value, that adds angular drag, and that can increase stability. \n \n \n \n Vortex properties\n \n Properties related to the  Vortex Studio engine . Make sure to also refer to the  Vortex user manual  for details. \n Restitution : collision normal response elasticity from 0 (inelastic) to 1 for pure    elastic.  \n Restitution threshold : velocity threshold below which restitution is    ignored.  \n Compliance : material softness (1/stiffness).  \n Damping : normal response damping, for soft contact (low stiffness).  \n Adhesive force : generates glue at the contact. \n Linear velocity damping : artificial linear velocity damping.  \n Angular velocity damping : artificial angular velocity damping. \n Auto angular  damping enabled : self-managed angular damping for    rigid bodies under large tension. Not recommended for wheels or rolling objects. \n Auto angular damping tension ratio : scaling factor for the self-managed    angular damping algorithm. \n Skin thickness : makes material softer within the skin thickness (makes grasping more stable).  \n Auto-slip enabled : self-management of the contact viscosity.  \n Fast moving : enables additional checks during collision detection    to prevent deep penetration or tunnel effect. \n Treat pure shape as VxConvexMesh : handles a pure shape as a convex shape. \n Treat convex shape as VxTriangleMeshBVTree : handles a convex shape as a OBB tree database (usually more accurate and stable than    convex shapes). \n Treat random shape as VxTriangleMeshUVGrid : handles a random shape as a 2D grid database (more efficient for large terrain    database). 2 VxTriangleMeshUVGrids    will never collide with each other. \n Auto-sleep : feature allowing to disable non-moving object to save simulation time. A part    is considered as sleeping when all velocities, acceleration are within corresponding    thresholds: \n Threshold linear speed : linear velocity threshold.  \n Threshold linear acceleration : linear acceleration threshold. \n Threshold angular speed : angular velocity threshold. \n Threshold angular acceleration : angular acceleration threshold. \n Threshold steps : minimum number of steps a    part must be awake prior to go to sleep again. \n Linear primary axis : an axis in the friction plane.  \n Axis orientation : a vector indicating the orientation of the primary axis (the vector will be projected into the friction plane). The vector is relative to the shape reference frame. \n Friction model : friction model along this axis. \n Friction coefficient : friction coefficient (used for scaled box and    scaled box fast model).  \n Static friction scale : static friction/dynamic friction ratio. \n Slip :  friction viscosity.  \n Slide :  friction desired relative velocity along this axis.  \n Linear secondary axis : second axis defining the friction plane. \n Angular primary axis : allows adding angular friction around the    primary axis (rolling resistance).  \n Angular secondary axis : allows adding angular friction around the secondary    axis (rolling resistance). \n Angular normal axis : allows adding angular friction around the normal axis (spin resistance). \n \n \n \n Newton properties\n \n Properties related to the  Newton Dynamics Engine . Make sure to also refer to the  Newton user manual  for details. \n Static friction : the static friction coefficient. Two colliding objects will have a combined friction value of value1*value2. \n Kinetic friction : the kinetic friction coefficient. Two colliding objects will have a combined friction value of value1*value2. \n Restitution : the restitution coefficient. Higher values tend to make collisions appear elastic. Two colliding objects will have a combined restitution value of value1+value2. \n Linear drag : a linear drag value, which can improve stability. \n Angular drag : an angular drag value, which can improve stability. \n Fast moving : enables additional checks during collision detection to prevent deep penetration or tunnel effect.. \n \n \n \n Vortex additional information\n \n Material properties defines how a single shape should behave when colliding with another shape. A collision involves two shapes and their respective material properties. A contact material combines those two material properties into a merged set of properties used to generate the contact forces between the two colliding shapes during the execution of the simulation. The rules for merging two contact materials are as follow: \n Compliance : take the most compliant and associated damping and restitution. \n Adhesive force : use the larger value. \n Skin thickness : use the larger value. \n Friction model : If the two models are different, priority goes as follow:  none ,  boxProportional ,  scaledBox ,  scaledBoxFast ,  box ,  neutral . The friction models definitions are: \n None : no friction. \n BoxProportional : n/a. \n ScaledBox : friction boundary = normal force * friction coefficient. \n ScaledBoxFast : use contact matching and contact force from the previous step. Falls back to scaledBox for a new contact. \n Box : n/a. \n Neutral : The lowest priority so the other model is used. If both are neutral, it is frictionless. \n If the two models are the same, use the lowest friction coefficient. \n If the friction is not isotropic, different friction properties may be provided in the 2 directions defining the friction plane (linear primary and secondary axes). The axis orientation is a vector in the object's local frame. It's projection in the friction plane defines the linear primary direction. The axis orientation is only used for anisotropic materials. If two anisotropic materials are interacting, one of them will be used, user cannot currently prioritize which one. \n \n \n \n \n", 'tags': '', 'url': 'shapeDynamicEngineProperties.html'}, {'title': 'geometryDialog', 'text': "\n \n \n \n \n Shape geometry dialog \n The shape geometry dialog is part of the  shape properties . The dialog allows you to view a geometry associated with a  shape , and to modify it to a certain extent. It displays the number of vertices and triangles, and the size of the  shape's bounding box . The number of vertices and triangles of a mesh is directly linked to the rendering and calculation times (e.g. during  collision detection  or  distance calculation ), and the more vertices/triangles a mesh has, the slower the simulation or scene display will be. While the  object common properties  allows to scale  objects  (including shapes), it however keeps proportions same at all times (the scaling along an object's x-, y- or z-axis is same). This restriction doesn't apply in the geometry dialog, and you can even flip a mesh along one of its axes by specifying a negative scaling factor. Remember however that some  pure simple shapes  and  pure compound shapes  have restrictions regarding non-uniform scaling. On top of that, pure shapes cannot be flipped.  \n Additionally, the shape geometry dialog lets you modify a  shape's bounding box orientation . This should only be used in very special cases. A preferred method to modify a shape's bounding box orientation is to select [Menu bar --> Edit --> Bounding box alignment --> Align selected shape's coordinate frame with main axis] or [Menu bar --> Edit --> Bounding box alignment --> Align selected shape's coordinate frame with world] while a shape is selected. \n \n \n [Shape geometry dialog] \n \n \n \n \n", 'tags': '', 'url': 'geometryDialog.html'}, {'title': 'shapeEditModes', 'text': "\n \n \n \n \n Shape edit modes \n The best option when specific  shapes  are needed in CoppeliaSim is to draw them in a CAD application (e.g. AutoCAD, 3D Studio Max, etc.) and then  import  them. When an external CAD application is not available, or when only simple shapes are required, the user can create  primitive shapes  and then customize the created shape in one of the 3 supported shape edit modes in CoppeliaSim:\n \n Triangle edit mode : in this mode, individual triangles composing the shape are visible and can be manipulated or extracted.  \n Vertex edit mode : in this mode, individual vertices composing the shape are visible and can be manipulated or extracted. \n \n Edge edit mode : in this mode, individual edges composing the shape are visible and can be manipulated or extracted. \n \n \n [Triangle, vertex and edge edit modes] \n \n Pure shapes  are converted to regular shapes before entering one of above's edit edit modes. \n A compound shape cannot directly be edited. It will first have to be ungrouped. Or you can edit its composing element's visual parameters via the  edit mode for compound shapes . \n \n The different edit modes are accessed  with a click on the appropriate toolbar button: \n \n [Shape edit mode toolbar button] \n Make sure you have a shape object selected before entering the shape edit mode. During shape edition,  objects  cannot be selected and simulation cannot be started. Once edition is finished, click on the shape edit mode toolbar button to quite the edit mode. When applying changes to a shape, CoppeliaSim will make sure the modified shape is consistent and remove unused vertices and merge vertices that are close to each other, etc. The exact behavior can be set in the  Vertices/triangles verification settings  in the  user settings dialog .\n \n \nYou can switch from one edit mode to another, and this allows you to achieve special operations. As an example, if you want to select and remove all triangles of the upper face of a cylinder, instead of individually selecting them in the  triangle edit mode , perform a shift-selection of all upper vertices in the  vertex edit mode , then switch to the triangle edit mode, then press the delete-key. \n \n \n \n \n", 'tags': '', 'url': 'shapeEditModes.html'}, {'title': 'triangleEditMode', 'text': "\n \n \n \n \n Triangle edit mode \n The triangle edit mode can be accessed with a click on the appropriate toolbar button: \n \n [Shape edit mode toolbar button] \n The above toolbar button is only active if a   shape  is selected. If the last selected shape is not a simple shape, but a compound shape, the  edit mode for compound shapes  will be activated instead. In the triangle edit mode all triangles composing the shape are individually displayed. A triangle has two faces, the front face and the back face. The front face is displayed in blue while the back face is displayed in red. When selecting triangles (using the same procedure as for selecting  objects ), they will appear in yellow and the last selected triangle in white. Shortcut copy/cut/paste/delete is supported (ctrl-c, ctrl-x, ctrl-v, delete). Selection can be cleared with the esc-key, with the deselect toolbar button, or by ctrl-clicking onto an empty area of the  scene . A shift-selection will select all triangles under the selection area, also hidden triangles (if you wish to only select visible triangles via a shift-selection, hold down the ctrl-key in addition to the shift-key). In the triangle edit mode, the portion of the window that normally displays the  scene hierarchy  is used to display the triangles of the shape being edited as a list. Items in the list can be selected with the mouse as for objects in the hierarchy window.\n \n \n [Triangle edit mode] \n \n After entering the triangle edit mode, the edit menu items ([Menu bar --> Edit]) will become specific to the triangle edit mode, and following dialog will display:\n \n \n [Triangle edit mode dialog] \n Triangle / Vertex / Edge edit mode : the currently activated edit mode. The user can switch from one edit mode to the others via these buttons (the selected items will be preserved). \n Clear selection : clears the selection of triangles.\n \n Invert selection : inverts the selection state of triangles.\n \n Extract shape : will create a simple shape based on currently selected triangles. The shape will be added to the scene but might not be visible (the shape in edit mode and the newly created shape coincide in position and orientation, or the first visibility layer is disabled). The triangle selection will remain. \n \n Extract cuboid : will create a rectangular (pure) simple shape based on currently selected triangles (will orient the new cuboid in a same way as the minimum bounding box encompassing the selected triangles).  The triangle selection will remain. This operation is useful when a complex mesh shape needs to be modeled in a simplified way to allow  efficient dynamics simulation  for instance. \n \n Extract cylinder : will create a cylindrical (pure) simple shape based on currently selected triangles (will orient the new cylinder in a same way as the minimum bounding box encompassing the selected triangles).  The triangle selection will remain. This operation is useful when a complex mesh shape needs to be modeled in a simplified way to allow  efficient dynamics simulation  for instance. \n \n Extract sphere : will create a spherical (pure) simple shape based on currently selected triangles  (will orient the new spheroid in a same way as the minimum bounding box encompassing the selected triangles).  The triangle selection will remain. This operation is useful when a complex mesh shape needs to be modeled in a simplified way to allow  efficient dynamics simulation  for instance. \n \n Flip : flips the selected triangles's side (from red to blue and from blue to red).\n \n Subdivide largest triangles : this will divide large triangles. Unless you want to reduce triangle sizes in order to obtain a more differentiated illumination of large surfaces, it is not recommended to reduce triangle sizes (unless you know exactly what you are doing). Instead, you can adjust the triangle size for the calculation structures globally (in the  environment dialog ). \n \n Triangles can be directly translated with the mouse, using the toolbar's object/item translation button to translate the selected triangle(s) in a perpendicular plane to the view direction: \n \n \n [Object/item translation toolbar button] \n \n [Shape in triangle edit mode] \n \n \n \n \n", 'tags': '', 'url': 'triangleEditMode.html'}, {'title': 'vertexEditMode', 'text': "\n \n \n \n \n Vertex edit mode \n The vertex edit mode can be accessed with a click on the appropriate toolbar button: \n \n [Shape edit mode toolbar button] \n The above toolbar button is only active if a   shape  is selected. If the last selected shape is not a simple shape, but a compound shape, the  edit mode for compound shapes  will be activated instead. In the vertex edit mode all vertices composing the shape are individually displayed in red. When selecting vertices (using the same procedure as for selecting  objects ), they will appear in yellow and the last selected vertex in white. Shortcut copy/cut/paste/delete is supported (ctrl-c, ctrl-x, ctrl-v, delete). Selection can be cleared with the esc-key, with the deselect toolbar button, or by ctrl-clicking onto an empty area of the  scene . A shift-selection will select all vertices under the selection area, also hidden vertices (if you wish to only select visible vertices via a shift-selection, hold down the ctrl-key in addition to the shift-key). In the vertex edit mode, the portion of the window that normally displays the  scene hierarchy  is used to display the vertices of the shape being edited as a list. Items in the list can be selected with the mouse as for objects in the hierarchy window.  \n \n [Vertex edit mode] \n \n After entering the vertex edit mode, the edit menu items ([Menu bar --> Edit]) will become specific to the vertex edit mode, and following dialog will display:\n \n \n [Vertex edit mode dialog] \n Triangle / Vertex / Edge Edit Mode : the currently activated edit mode. The user can switch from one edit mode to the others via these buttons (the selected items will be preserved). \n Show Hidden Vertices : when selected, will display also hidden vertices.\n \n Clear selection : clears the selection of vertices.\n \n Invert selection : inverts the selection state of vertices.\n \n Insert Triangles : will insert triangles between selected vertices. The order in which vertices are selected is important. \n \n Insert Triangle Fan : will insert a triangle fan between selected vertices. The order in which vertices are selected is important. The last selected vertex will be the common vertex between the newly inserted triangles. \n \n Copy to status bar : prints the selected vertices to the status bar. \n \n Vertices can be precisely positionned via the  coordinate and transformation dialog . They can also  be directly translated with the mouse, using the toolbar's object/item translation button to translate the selected vertex/vertices in a perpendicular plane to the view direction:  \n \n [Object/item translation toolbar button] \n \n [Shape in vertex edit mode] \n \n \n \n \n", 'tags': '', 'url': 'vertexEditMode.html'}, {'title': 'edgeEditMode', 'text': "\n \n \n \n \n Edge edit mode \n The edge edit mode can be accessed with a click on the appropriate toolbar button: \n \n [Shape edit mode toolbar button] \n The above toolbar button is only active if a   shape  is selected. If the last selected shape is not a simple shape, but a compound shape, the  edit mode for compound shapes  will be activated instead. In the edge edit mode all edges composing the shape are individually displayed in red. When selecting edges (using the same procedure as for selecting  objects ), they will appear in yellow and the last selected edge in white. Edges can be deleted with the delete-key, however edges cannot be copied, cut nor pasted. Selection can be cleared with the esc-key, with the deselect toolbar button, or by ctrl-clicking onto an empty area of the  scene . A shift-selection will select all edges under the selection area, also hidden edges (if you wish to only select visible edges via a shift-selection, hold down the ctrl-key in addition to the shift-key). In the edge edit mode, the portion of the window that normally displays the  scene hierarchy  is used to display the edges of the shape being edited as a list. Items in the list can be selected with the mouse as for objects in the hierarchy window.  \n \n [Edge edit mode] \n \n After entering the edge edit mode, the edit menu items ([Menu bar --> Edit]) will become specific to the edge edit mode, and following dialog will display:\n \n \n [Edge edit mode dialog] \n Triangle / Vertex / Edge Edit Mode : the currently activated edit mode. The user can switch from one edit mode to the others via these buttons (the selected items will be preserved). \n Show Hidden Edges : when selected, will display also hidden edges.\n \n Automatic Edge Following : when selected, and an edge is selected, that edge will be followed until a loop was created, until the edge changes direction abruptly ( Max. dir. change angle ), or until the edge disappears ( Max. edge angle ). This is a useful feature when you want to extract not only a local edge (one side of a triangle), but a global one (a shape's edge). An edge is only followed in one direction.  \n \n [Edge following] \n \n Clear selection : clears the selection of edges.\n \n Invert selection : inverts the selection state of edges.\n \n Copy to status bar : prints the selected edges to the status bar. \n \n \n \n \n \n", 'tags': '', 'url': 'edgeEditMode.html'}, {'title': 'groupedShapeEditMode', 'text': "\n \n \n \n \n Edit mode for compound shapes \n The edit mode for compound shapes can be accessed with a click on the appropriate toolbar button: \n \n [Shape edit mode toolbar button] \n The above toolbar button is only active if a  shape  is selected. If the last selected shape is not a compound shape, but a simple shape, the  triangle edit mode  will be activated instead. In the edit mode for compound shapes, you can edit the shape's components individual visual parameters. The shape's components can be selected the hierarchy window.\n \n \n [Edit mode for compound shapes] \n \n After entering the edit mode for compound shapes, the following dialog will display:\n \n \n [Edit mode dialog for compound shapes] \n Adjust color : allows editing the colors of the shape components. \n Adjust texture : opens the  texture dialog  for the selected shape component.\n \n Shading angle : the shading angle is the angle from which individual faces are distinguished.  A small angle makes a shape appear sharp, with many edges, a large angle makes a shape appear smooth and with less edges. \n \n Show edges : displays edges in black.  \n \n Backface culling : each triangle composing a shape has an inside and an outside face. When Backface culling is enabled, then inside faces won't be displayed. This is a useful parameter for closed shapes and for shapes that are transparent.  \n \n \n \n \n \n", 'tags': '', 'url': 'groupedShapeEditMode.html'}, {'title': 'joints', 'text': "\n \n \n \n \n Joints  \n A joint is an  object  that allows for a relative movement between its parent and its child/children. When a parent-child relationship is built between a joint and an object, the object is attached to the joint's second reference frame, thus, a change of the joint's linear/angular position will directly be reflected onto its children. Joints can operate in different  modes . New joints can be added to a  scene  with [Menu bar --> Add --> Joints].\n \n \n [Robotic manipulator with highlighted joints] \n \n 4 types of joints are supported: \n \n [Revolute joint, prismatic joint, screw and spherical joint] \n \n Revolute joint : a revolute joint has one DoF and is used to describe a rotational movement between objects. The rotation happens about its reference frame's z-axis \n \n Prismatic joint : a prismatic joint has one DoF and is used to describe a translational movement between objects. The translation happens along its reference frame's z-axis \n \n Screw : a screw, which can be seen as a combination of a revolute and prismatic joint with linked values, has one DoF and is used to describe a movement similar to a screw. A pitch parameter defines the amount of translation for a given amount of rotation. The translation/rotation happens along/about its reference frame's z-axis \n \n Spherical joint : a spherical joint has three DoFs and is used to describe a rotational movement between objects. In some situations, a spherical joint can be thought of as 3 concurrent and orthogonal joints, that are parented in a hierarchy-chain. The analogy is however only valid while all revolute joints keep an orientation distinct from any of the other two: indeed, should two joints come close to coincide, a singular situation might appear and the mechanism will lose one DoF. This does never happen with spherical joints, which are internally handled to avoid this kind of situation:  \n \n [Two equivalent mechanisms (in this configuration): spherical joint (left) and 3 revolute joints (right)] \n \n \n [Two non-equivalent mechanisms: the right configuration is close to a singularity] \n \n \n \n \n \n", 'tags': '', 'url': 'joints.html'}, {'title': 'jointModes', 'text': '\n \n \n \n \n Joint modes \n A joint can be in one of following 3 modes:\n \n Kinematic mode : the joint operates in kinematic mode and is not handled by the  dynamics module . It can instantaneously change its linear/angular position (via  sim.setJointPosition ), display a specific motion profile (via  sim.setJointTargetPosition  or  sim.setJointTargetVelocity ), or be handled in a customized manner via a  joint callback function \n Dependent mode : the joint is directly dependent of another joint via a linear equation. The joint is not handled by the  dynamics module \n Dynamic mode : the joint is handled by the  dynamics module , if it forms with its connecting items a valid configuration, i.e. is  dynamically enabled . In that case, it can be  controlled in various modes \n \n There are many different ways a joint can be controlled, depending on its joint mode and control mode, but one can differentiate between  high-level control  and  low-level control :  \n High-level control  is achieved mainly via specific API functions, such as  sim.setJointPosition ,  sim.setJointTargetPosition ,  sim.setJointTargetVelocity  or  sim.setJointTargetForce . Depending on the joint mode and control mode, not all functions make sense, e.g. calling sim.setJointTargetForce on a kinematic joint, or calling sim.setJointTargetPosition on a dynamic joint in velocity control \n Low-level control  is best implemented via a  joint callback function  from within CoppeliaSim. In that case the joint should be in kinematic mode, or in dynamic mode and CoppeliaSim. The callback function will then constantly called by CoppeliaSim, in order to fetch new regulation values \n Joint callback functions  are ideal for low-level control of a joint, since the controller will  regulate  the joint in each time step, i.e. skipping a regulation step for a low-level controller is not an option. For joints in kinematic mode the regulation time step is the same as the simulation time step (50 ms by default). Joints in dynamic mode on the other hand will use a much fined regulation time step as defined by the dynamics module (5 ms by default).  \n In case of an external application wanting to perform low-level control of a joint, joint callback functions are not available, and so the external application should make sure that it will run synchronously with CoppeliaSim. This happens via the  stepped mode , where the external application is in charge of explicitly triggering each simulation step. Additionally, for a fine-grained control, the simulation time step should be the same as the dynamics module time step. \n \n \n \n \n', 'tags': '', 'url': 'jointModes.html'}, {'title': 'jointProperties', 'text': "\n \n \n \n \n Joint properties \n The joint properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Joint  button to display the joint dialog (the  Joint  button only appears if the last selection is a  joint ). The dialog displays the settings and parameters of the last selected joint. If more than one joint is selected, then some parameters can be copied from the last selected joint to the other selected joints ( Apply to selection -buttons. Be aware that this however only has an effect between joints of same type or mode): \n \n \n [Joint dialog] \n \n Position is cyclic : indicates whether the angular joint position is cyclic (varies between -180 and +180 degrees without limitation). Only revolute joints can be cyclic \n \n Screw pitch : the pitch value of the joint. This property becomes available only with the Revolute/Screw-type of joint, when the  Position is cyclic -checkbox is left unchecked \n \n Position minimum : the minimum allowed value of a non-cyclic revolute joint, a screw, or a prismatic joint \n \n Position range : the variation range of a non-cyclic revolute joint, a screw or a prismatic joint. A position of such a joint is limited between  Position minimum  and  Position minimum + Position range \n Position : linear/angular joint position \n \n Mode : a joint can be in kinematic, dependent, or dynamic mode \n Adjust dependency equation : if the joint is in dependent mode, then a linear equation can be specified that links the joint to another one. The values in this section of the dialog are all indicated in meters or radians \n Length : length of the joint. Has no functional meaning\n \n Diameter : diameter of the joint. Has no functional meaning\n \n Adjust color : allows adjusting the color of the joint \n Show dynamic properties dialog : toggles the  joint dynamics properties  dialog. The joint dynamics dialog allows to adjust a joint's dynamic properties \n \n \n \n \n", 'tags': '', 'url': 'jointProperties.html'}, {'title': 'jointDynamicsProperties', 'text': '\n \n \n \n \n Joint dynamics properties \n The joint dynamics properties are part of the  joint properties . Its dialog displays the dynamics settings and parameters of the last selected  joint . If no joint is selected, or the joint is not dynamic, then the dialog is inactive. If more than one joint is selected, then some parameters can be copied from the last selected joint to the other selected joints: \n \n \n [Joint dynamics dialog] \n \n Several control modes are supported: \n Free   (no control) : the joint is free, i.e. non-motorized \n Force/torque control : the joint is controlled in force/torque, i.e. a constant force/torque is applied. Can be modulated with  sim.setJointTargetForce \n Velocity control : the joint is controlled in velocity: the specified force/torque is applied until the desired velocity is reached. Optionally, a specific motion profile for the velocity can be applied. Can be modulated with  sim.setJointTargetVelocity  and  sim.setJointTargetForce \n Position control : the joint is controlled in position: the specified force/torque is applied and the velocity is modulated via a PID controller, or via specific motion constraints, until the target position/angle is reached. Parameters can be adjusted with  sim.setJointTargetPosition ,  sim.setJointTargetForce  and  sim.setObjectFloatParam \n Spring-damper control : the joint is controlled in position by modulating the exerted force/torque via a simple KC controller, trying to reach the zero displacement position/angle. Parameters can be adjusted with  sim.setJointTargetPosition ,  sim.setJointTargetForce  and  sim.setObjectFloatParam \n Custom control : the joint calls a  joint callback function  for control, where the user can decide of a force/torque and target velocity in a flexible way \n \n \n \n \n', 'tags': '', 'url': 'jointDynamicsProperties.html'}, {'title': 'jointDynamicEngineProperties', 'text': "\n \n \n \n \n Dynamics engines properties related to joints \n The dynamics engines properties related to  joints  can be accessed via the  joint dynamics properties  dialog. The engine specific properties of the last selected joint are displayed in a dialog. If more than one joint is selected, then properties can be copied from the last selected joint to the other selected joints ( Apply all properties to selected joints ): \n \n \n [Dynamics engines properties dialog related to joints] \n \n \n \n Bullet properties\n \n Properties related to the  Bullet physics library . Make sure to also refer to the  Bullet user manual  for details. \n Normal CFM : a  constraint force mixing  parameter used when away from limits. \n Stop ERP : an  error reduction parameter  at the limits. \n Stop CFM : a  constraint force mixing  parameter at the limits. \n \n \n \n ODE properties\n \n Properties related to the  Open Dynamics Engine . Make sure to also refer to the  ODE user manual  for details. \n Normal CFM : a  constraint force mixing  parameter used when away from limits. \n Stop ERP : an  error reduction parameter  at the limits. \n Stop CFM : a  constraint force mixing  parameter at the limits. Togehter with the  Stop ERP  parameter,  spongy  or  soft  limits can be created (is not supposed to work correctly with powered joints) \n Bounce : a value that regulates the bouncyness at limits (i.e. a restitution parameter). \n Fudge factor : an arbitrary value that can help make a joint behave  correctly , e.g. be less  jumpy  when moving away from limits. \n \n \n \n Vortex properties\n \n Properties related to the  Vortex Studio engine . Make sure to also refer to the  Vortex user manual  for details. \n Joint axis friction : allows to define internal friction along or    around a constraint axis.  \n Enabled : enables internal friction.  \n Proportional : if true, friction is proportional to the tension in the constraint.  \n Coefficient : for proportional friction force, the friction is proportional to the tension    * coefficient. \n Maximum force : for non-proportional friction, the friction force can    be provided directly by the user. \n Loss : viscosity factor.  \n Joint axis limits : manages the positional or angular limits along    or around a constraint axis.  \n Lower/upper restitution : bounciness. \n Lower/upper stiffness : linear of angular stiffness of the limit’s    spring. \n Lower/upper damping : linear of angular damping of the limit’s    spring. \n Lower/upper maximum force : force or torque boundary of the limit’s    spring. \n Joint dependency : properties allowing to dynamically link two dynamically enabled joints. Two linked joints will share/exchange their respective loads (i.e. a force/torque applied to one will be transmitted to the other one, and vice-versa). \n Dependent joint : the joint that is linked to this one. This property doesn't appear as reflective (i.e. the dependency won't display for the dependent joint), in order to be able to link the dependent joint to other joints for complex dependency set-ups. All dependent joints must share a same parent shape for proper operation. \n Multiplication factor : the multiplication factor that links the dependent joints. A factor or 1 will let two linked revolute joints rotate in the same direction, at the same rate. \n Offset : not yet used. Keep at 0. \n X axis position : relaxation and friction parameters along the constraint    X axis (position). \n Relaxation : relaxation allows controlling the corresponding constraint strength.  \n Enabled : enables the relaxation.  \n Stiffness : spring stiffness for position-based equation. \n Damping : spring damping for position-based equation. \n Loss : viscosity for velocity-based equation. \n Friction :  internal friction along the axis. \n Enabled : enables internal friction for this axis.  \n Proportional : makes friction proportional to the tension in the joint.  \n Coefficient : friction set to tension * coefficient. \n Maximum force : if non-proportional, friction force is manually set by    the user. \n Loss : friction force viscosity.  \n Y axis position : relaxation and friction parameters along the constraint    Y axis (position). \n Z axis position : relaxation and friction parameters along the constraint Z    axis (position). \n X axis orientation : relaxation and friction parameters around the    constraint X axis (orientation). \n Y axis orientation : relaxation and friction parameters around the    constraint Y axis (orientation). \n Z axis orientation : relaxation and friction parameters around the constraint Z axis (orientation). \n \n \n \n Newton properties\n \n Properties related to the  Newton Dynamics Engine . Make sure to also refer to the  Newton user manual  for details. \n Joint dependency : properties allowing to dynamically link two dynamically enabled joints. Two linked joints will share/exchange their respective loads (i.e. a force/torque applied to one will be transmitted to the other one, and vice-versa). \n Dependent joint : the joint that is linked to this one. This property doesn't appear as reflective (i.e. the dependency won't display for the dependent joint), in order to be able to link the dependent joint to other joints for complex dependency set-ups. All dependent joints must share a same parent shape for proper operation. \n Multiplication factor : the multiplication factor that links the dependent joints. A factor or 1 will let two linked revolute joints rotate in the same direction, at the same rate. \n Offset : not yet used. Keep at 0. \n \n \n \n \n", 'tags': '', 'url': 'jointDynamicEngineProperties.html'}, {'title': 'dummies', 'text': '\n \n \n \n \n Dummies  \n A dummy object is the simplest  object  available: it is a point with orientation, and it can be seen as a reference frame. Dummies are multipurpose or helper objects: they are used alone to identify specific points or reference frames in the scene, they are also used in pairs to specify loop closures or tip-target relationships for dynamics or kinematics calculations. Following figure shows a dummy: \n \n \n [Dummy] \n \n Dummies are  collidable ,  measurable  and  detectable objects . This means that dummies: \n \n can be used in  collision detections  with other collidable objects that are volume based, such as  OC trees . \n can be used in  minimum distance calculations  with other measurable objects.  \n can be detected by  proximity sensors .\n \n By default, the collidable, measurable and detectable property of a dummy is turned off (see  object common properties ). \n \n Dummies can be added to the  scene  with [Menu bar --> Add --> Dummy], or created from a  shape object  in the  vertex edit mode . \n \n \n \n \n \n', 'tags': '', 'url': 'dummies.html'}, {'title': 'dummyPropertiesDialog', 'text': "\n \n \n \n \n Dummy properties \n The dummy properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Dummy  button to display the dummy dialog (the  Dummy  button only appears if the last selection is a  dummy ). The dialog displays the settings and parameters of the last selected dummy. If more than one dummy is selected, then some parameters can be copied from the last selected dummy to the other selected dummies ( Apply to selection -buttons): \n \n \n [Dummy dialog] \n \n Linked dummy : dummy linked to this one. Linked dummies (easily recognizable by a colored segment linking them, in the scene hierarchy ) have special properties and behavior, see next item for more details. \n \n Link type : the link type will specify the behavior of the linked dummies during simulation. If  Dynamics, overlap constraint  is specified, then the two dummies will try to overlap their respective position/orientation to create dynamics loop closure constraints (refer to the section on  designing dynamic simulations  for more details).\n \n Object size : size of the dummy. This parameter has only a visual effect, and no functional meaning.\n \n Adjust dummy color : allows adjusting a dummy's color\n \n \n \n \n \n", 'tags': '', 'url': 'dummyPropertiesDialog.html'}, {'title': 'graphs', 'text': "\n \n \n \n \n Graphs  \n Graphs are  scene objects  that can record and visualize data from a  simulation . Data is recorded in data streams, which are sequential lists of values associated with time stamps. \n Data streams can directly be visualized as time plots. By combining 2 or 3 data streams, one can obtain x/y curves, or 3D curves in the scene.\n  Following figure illustrates a time plot, showing 6 data streams visualizing joint velocities: \n \n [Examples of a time plot] \n \n A graph is added to the scene with [Menu bar --> Add --> Graph]. Its basic properties are accessed and adjusted in the  graph dialog . \n The user is in charge of defining data streams, curves, and feeding them with appropriate data on a regular basis (usually once per simulation step). Following illustrates how to record and visualize 2 data streams (the velocity of two joints over time): \n \nfunction sysCall_init()\n    graph=sim.getObject('/Graph')\n    joint1Vel=sim.addGraphStream(graph,'joint 1 velocity','deg/s',0,{1,0,0})\n    joint2Vel=sim.addGraphStream(graph,'joint 2 velocity','deg/s',0,{0,1,0})\nend\n\nfunction sysCall_sensing()\n    sim.setGraphStreamValue(graph,joint1Vel,180*sim.getJointVelocity(joint1Handle)/math.pi)\n    sim.setGraphStreamValue(graph,joint1Vel,180*sim.getJointVelocity(joint1Handle)/math.pi)\nend \n Next example shows how to record and visualize an x/y position curve of an object: \n \nfunction sysCall_init()\n    graph=sim.getObject('/Graph')\n    objectPosX=sim.addGraphStream(graph,'object pos x','m',1)\n    objectPosY=sim.addGraphStream(graph,'object pos y','m',1)\n    sim.addGraphCurve(graph,'object pos x/y',2,{objectPosX,objectPosY},{0,0},'m by m')\nend\n\nfunction sysCall_sensing()\n    local pos=sim.getObjectPosition(objectHandle,-1)\n    sim.setGraphStreamValue(graph,objectPosX,pos[1])\n    sim.setGraphStreamValue(graph,objectPosY,pos[2])\nend \n See also the  API functions related to graphs . \n \n \n \n \n", 'tags': '', 'url': 'graphs.html'}, {'title': 'graphPropertiesDialog', 'text': '\n \n \n \n \n Graph dialog \n The graph dialog is part of the  scene object properties dialog , which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Graph  button to display the graph dialog (the  Graph  button only appears if the last selection is a  graph ). The dialog displays the settings and parameters of the last selected graph: \n \n \n [Graph dialog] \n \n Object size : size of the graph object. This parameter has no functional effect. \n \n Buffer is cyclic : when selected and the number of elements in each data stream reached the buffer size, then the first elements will be erased in order to be able to record new elements. Otherwise recording stops when the buffer is full. \n \n Buffer size : number of elements each data streams can record. \n \n Remove all streams/curves : clears all data streams and curves. \n Remove all static streams/curves : clears all static data streams and curves. A static data stream or curve is a "frozen" data stream or curve, that can\'t be modified anymore. \n Adjust background color : allows adjusting the background color in the time graph or x/y graph view. \n \n Adjust grid color : allows adjusting the grid and graduation color in the time graph or x/y graph view.\n \n The graph object itself is mainly operated via a  customization script , that could be adapted in various ways, if needed. The behaviour of the graph can also be altered in various ways by clicking the  user parameter  icon next to the customization script. \n \n \n \n \n', 'tags': '', 'url': 'graphPropertiesDialog.html'}, {'title': 'proximitySensors', 'text': '\n \n \n \n \n Proximity sensors  \n CoppeliaSim offers a very powerful and efficient way to simulate proximity sensors. The user can model almost any type of proximity sensor, from ultrasonic to infrared, and so on. The  scene objects  that allow for this functionality are proximity sensors (which are different from  vision sensors ), which can detect  detectable   entities . Following figures illustrates  simulations  using proximity sensors: \n \n \n \n [Mobile robots using proximity sensors] \n \n Proximity sensors are added to the  scene  with [menu bar --> Add --> Proximity sensor].\n \n The proximity sensor detection routines used by the proximity sensors are also available as stand-alone routines via the  Coppelia geometric routines . \n \n \n \n \n', 'tags': '', 'url': 'proximitySensors.html'}, {'title': 'proximitySensorDescription', 'text': "\n \n \n \n \n Proximity sensor types and mode of operation \n Proximity sensors  come in 6 different types and can be customized to a large extent:\n \n Ray-type : the ray-type proximity sensor is ideally suited for very simple modeling of a proximity sensor, or for modeling of a laser range finder. They are the fastest proximity sensors.\n \n Randomized ray-type : the randomized ray-type proximity sensor operates as a ray-type sensor that randomly sweeps a cone volume. It has a similar appearance as the cone-type proximity sensor. \n \n Pyramid-type : the pyramid-type proximity sensor is ideally suited for simple modeling of a proximity sensor with a detection volume that is rectangular. They are very fast. \n \n Cylinder-type : the cylinder-type proximity sensor is ideally suited for simple modeling of a proximity sensor with a detection volume that is revolute. They are very fast. \n \n Disk-type : the disk-type proximity sensor allows precisely modeling of a proximity sensor with a revolute-scanning detection volume. Depending on the selected precision and operation mode, they can be a little bit more calculation intensive. \n \n Cone-type : the cone-type proximity sensor allows for the best and most precise modeling of most proximity sensors. Depending on the selected precision and operation mode, they can be a little bit more calculation intensive. \n \n \n [Ray-type, pyramid-type, cylinder-type, disk-type and cone- or randomized ray-type proximity sensors] \n \n Proximity sensors operate in a geometrically exact manner: they perform an exact distance calculation between their sensing point (small sphere) and any  detectable   entity  that interferes with its detection volume (they don't perform a simple collision detection between the sensing volume edges like most other simulation software, but an exact distance calculation within the detection volume). Each proximity sensor will compute following minimum distance: \n \nSensing point <-- --> (detectable entity ∩ detection volume)\n \n \n [Minimum distance calculation between sensing point and (detectable entity ∩ detection volume)] \n \n If a proximity sensor detects an object, then a trigger is activated, which will result in a call to the  trigger callback function . \n \n \n \n \n", 'tags': '', 'url': 'proximitySensorDescription.html'}, {'title': 'proximitySensorPropertiesDialog', 'text': "\n \n \n \n \n Proximity sensor properties \n The proximity sensor properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Proximity sensor  button to display the proximity sensor dialog (the  Proximity sensor  button only appears if the last selection is a  proximity sensor ). The dialog displays the settings and parameters of the last selected proximity sensor. If more than one proximity sensor is selected, then some parameters can be copied from the last selected proximity sensor to the other selected proximity sensors ( Apply to selection -buttons): \n \n \n [Proximity sensor dialog] \n \n Explicit handling : indicates whether the sensor should be explicitely handled. If checked, the sensor will not be handled when sim.handleProximitySensor(sim.handle_all_except_explicit) is called, but only if sim.handleProximitySensor(sim.handle_all) or sim.handleProximitySensor(proximitySensorHandle) is called. This is useful if the user wishes to handle the sensor in a  child script  rather than in the  main script  (if not checked the sensor will be handled twice, once when sim.handleProximitySensor(sim.handle_all_except_explicit) is called in the main script, and once when sim.handleProximitySensor(proximitySensorHandle) is called in the child script). Refer also to the section on  explicit and non-explicit calls . \n \n Show volume parameters : Toggles the  proximity sensor volume dialog . That dialog allows to customize a proximity sensor's detection volume. \n Show detection parameters : opens the  proximity sensor detection parameter dialog . That dialog allows to customize various detection parameters.  \n Show volume : displays or hides the detection volume. \n Sensing point size : the size of the sensing point. This has no effect on calculations (the sensing point, even if displayed big, is always considered as a point). \n Adjust volume color : allows adjusting the color of the sensor's volume.\n \n Adjust detection ray color : allows adjusting the color of the sensor's detection ray.\n \n \n \n \n \n", 'tags': '', 'url': 'proximitySensorPropertiesDialog.html'}, {'title': 'proximitySensorVolumeDialog', 'text': '\n \n \n \n \n Proximity sensor volume dialog \n The proximity sensor volume dialog is part of the  proximity sensor properties . The dialog displays the volume settings and parameters of the last selected  proximity sensor . If no object is selected, the dialog is inactive. If more than one proximity sensor is selected, then some parameters can be copied from the last selected proximity sensor to the other selected proximity sensors ( Apply to selection -buttons):\n \n \n [Proximity sensor volume dialog] \n \n The six types of the volume of a proximity sensor (ray, randomized ray, pyramid, cylinder, disc and cone) are defined via several parameters: \n \n [Ray, pyramid and cylinder-type detection volume parameters] \n \n \n [Disk and cone-type detection volume parameters] \n \n Face count ,  face count far ,  subdivisions  and  subdivisions far  can be used to describe the detection volume with more or less precision. More precision also implies longer calculation times. \n \n Inside gap : parameter only available for the disc- and cone-type proximity sensors. Its value can vary between 0 and 1 and represents the amount of volume (proportionally) to remove. This feature can be used to create very sophisticated detection volumes by combining several sensors: \n \n \n [Inside gap functionality and its application] \n \n \n \n \n', 'tags': '', 'url': 'proximitySensorVolumeDialog.html'}, {'title': 'proximitySensorDetectionParameterDialog', 'text': '\n \n \n \n \n Proximity sensor detection parameter dialog \n The proximity sensor detection parameter dialog is part of the  proximity sensor properties . The dialog displays various detection parameters of the last selected  proximity sensor . \n \n \n [Proximity sensor detection parameter dialog] \n \n Front / back face detection : the user can decide which side of a triangle the sensor will  see  and detect. Front faces appear as blue, back faces appear as red in the  triangle edit mode . \n \n Fast detection (approximate) : when selected, the detection process will be faster, but not exact anymore (i.e. the detected point might not be the closest point). \n \n Limited angle detection : when selected, a maximum angle between the detection ray and an object\'s face normal vector can be specified. This is a useful feature when modeling ultrasonic proximity sensors. Ultrasonic proximity sensors normally cannot  see  surfaces that don\'t face the sensor enough. When enabled and the maximum angle is small, calculation time can be drastically increased. \n \n \n [Limited angle detection principle. Yellow arrows indicate surfaces normal vectors. Maximum angle is 30° (for example)] \n \n \n [Two identical proximity sensors configurations. Only one proximity sensor has the limited angle detection turned on (right)] \n \n Don\'t allow detections if distance smaller than : some sensors have a minimum detection distance (e.g. ultrasonic sensors) from which the sensor won\'t be operating anymore (i.e. the object to be detected is too close from the sensor). To model this behavior, one could simply set an offset for the detection volume, but by doing so the sensor will still be able to detect other objects that are located farther away. A real sensor would have its "view field" blocked by the closer object and not detect anything. This can be modeled by indicating a minimum detection distance (a mask distance) that, if undershot, would simply disable detection. \n \n \n [Two proximity sensors, one without mask distance (left), the other with mask distance (right)] \n \n Randomized ray detection : randomized ray detection is available only for randomized ray type proximity sensors. During randomized ray detection, a ray will sweep a cone-shaped volume in a random fashion. You can specify how many random rays the sensor should check ( ray count ), and how many ray detections are required to trigger the sensor ( ray detections count for triggering ). \n \n \n \n \n', 'tags': '', 'url': 'proximitySensorDetectionParameterDialog.html'}, {'title': 'visionSensors', 'text': "\n \n \n \n \n Vision sensors  \n CoppeliaSim offers, next to  proximity sensors , another type of sensors: vision sensors. Vision sensors, which are  viewable objects , operate in a very similar way as  camera objects : they will render the  objects  that are in their field of view and trigger detection if specified thresholds are over- or under-shot. Vision sensors should be used over proximity sensors mainly when color, light or structure plays a role in the detection process (e.g. infrared sensors, or, more generally, sensors sensible to light (cameras, etc.)). However, depending on the graphic card the application is running on, or on the complexity of the scene objects, vision sensors might be a little bit slower than proximity sensors. Following illustrates applications using vision sensors: \n \n \n \n \n [(1) industrial robot observed by 2 vision sensors, (2) Line tracer vehicle equipped with 3 vision sensors] \n \n Make sure not to mix-up vision sensors with  cameras . Following are the main differences:  \n A vision sensor has a fixed resolution. A camera has no specific resolution (i.e. it adjusts automatically to the view size). \n A vision sensor's image content can be accessed via the  API , and image processing handles via  vision callback functions . A camera's image content is not directly available via the API.  \n A vision sensor generally requires more CPU time and operates slower than cameras.  \n A vision sensor can mainly display  shapes . A camera can display all  object types . \n \nVision sensors are added to the  scene  with [menu bar --> Add --> Vision sensor].  \n \n \n \n \n", 'tags': '', 'url': 'visionSensors.html'}, {'title': 'visionSensorDescription', 'text': '\n \n \n \n \n Vision sensor types and mode of operation \n Vision sensors  come in 2 different types and can be adjusted for different purposes:\n \n Orthographic projection-type : the field of view of orthographic projection-type vision sensors is rectangular. They are well suited for close-range infrared sensors, or laser range finders. \n \n Perspective projection-type : the field of view of perspective projection-type vision sensors is trapezoidal. They are well suited for camera-type sensors. \n \n \n [Orthogonal projection-type and perspective projection-type vision sensors] \n \n Vision sensors, which are  viewable objects , can be  looked-through  like  camera objects  [Popup menu --> View --> Associate view with selected vision sensor]. See also the section on  pages and views  for more details. \n \n [Vision sensor and various image processings] \n \n Vision sensors are very powerful in the sense that they can be used in various and flexible ways. For instance they can be used to display still or moving images from an external application or a  plugin . Plugins can also provide customized image processing algorithms as well as evaluation algorithms (e.g. triggering conditions).  Vision callback functions  represent the mechanism where image processing can take place, and where triggers can be generated (one can react to triggers in a  trigger callback function ). \n \n \n \n \n \n', 'tags': '', 'url': 'visionSensorDescription.html'}, {'title': 'visionSensorPropertiesDialog', 'text': "\n \n \n \n \n Vision sensor properties \n The vision sensor properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Vision sensor  button to display the vision sensor dialog (the  Vision sensor  button only appears if the last selection is a  vision sensor ). The dialog displays the settings and parameters of the last selected vision sensor. If more than one vision sensor is selected, then some parameters can be copied from the last selected vision sensor to the other selected vision sensors ( Apply to selection -buttons): \n \n \n [Vision sensor dialog] \n \n Explicit handling : indicates whether the sensor should be explicitely handled. If checked, the sensor will not be handled when sim.handleVisionSensor(sim.handle_all_except_explicit) is called, but only if sim.handleVisionSensor(sim.handle_all) or sim.handleVisionSensor(visionSensorHandle) is called. This is useful if the user wishes to handle the sensor in a  child script  rather than in the  main script  (if not checked the sensor will be handled twice, once when sim.handleVisionSensor(sim.handle_all_except_explicit) is called in the main script, and once when sim.handleVisionSensor(visionSensorHandle) is called in the child script). Refer also to the section on  explicit and non-explicit calls . \n \n External input : when selected, then the vision sensor's normal operation will be altered so as to be able to handle external images instead (e.g. video images). \n \n Ignore RGB info (faster) : if selected, the RGB information of the sensor (i.e. the color) will be ignored so that it can operate faster. Use this option if you only rely on the depth information of the sensor. \n Ignore depth info (faster) : if selected, the depth information of the sensor will be ignored so that it can operate faster. Use this option if you do not intend to use the depth information of the sensor. \n Packet1 is blank (faster) : if selected, then CoppeliaSim won't automatically extract specific information from acquired images, so that it can operate faster. Use this option if you do not intend to use the first packet of auxiliary values returned by API functions  sim.readVisionSensor  or  sim.handleVisionSensor . \n Render mode : three modes are currently available: \n OpenGL  (default): renders the visible color channels of objects. \n OpenGL, auxiliary channels : renders the auxiliary color channels of objects. The auxiliary channels red, green and blue colors are meant to be used in following way: red is the temperature channel (0.5 is the ambient temperature), green is the user defined channel, and blue is the active light emitter channel. \n OpenGL, color coded handles : renders the objects by coding their handles into the colors. The first data packet returned by the  sim.readVisionSensor  or  sim.handleVisionSensor  API functions represent the detected object handles (round the values down). \n POV-Ray : uses the POV-Ray plugin to render images, allowing for shadows (also soft shadows) and material effects (much slower). The plugin source code is located  here . \n External renderer : uses an external renderer implemented via a plugin. The current external renderer source code is located  here . \n External renderer, windowed : uses an external renderer implemented via a plugin, and displays the image in an external window (during simulation only). The current external renderer source code is located  here . \n OpenGL3 : uses the  OpenGL3 renderer plugin , courtesy of Stephen James. The plugin offers shadow casting, which is currently not possible natively, in CoppeliaSim. Light projection and shadows can be adjusted for each light, via the object's  extension string , e.g.  openGL3 {lightProjection {nearPlane {0.1} farPlane {10} orthoSize {8} bias {0.001} normalBias {0.005} shadowTextureSize {2048}}} \n OpenGL3, windowed : same as above, but windowed. \n Near / far clipping plane : the minimum / maximum distance from which the sensor will be able to detect. \n \n Perspective angle : the maximum opening angle of the detection volume when the sensor is in perspective mode. \n \n Orthographic size : the maximum size (along x or y) of the detection volume when the sensor is not in perspective mode. \n \n \n [Detection value parameters of the orthographic-type vision sensor] \n \n \n [Detection value parameters of the perspective-type vision sensor] \n \n Resolution X / Y : desired x- / y-resolution of the image captured by the vision sensor. Carefully chose the resolution depending on your application (high resolution will result in slower operation). With older graphic card models, the actual resolution might be different from what is indicated here (old graphic card models only support resolutions at 2^n, where n is 0, 1, 2, etc.). \n \n Adjust default image color : allows specifying the color that should be used in areas where nothing was rendered. By default, the  environment  fog color is used. \n \n Sensor size : size of the body-part of the vision sensor. This has no functional effect. \n Show view frustum : if selected, the view frustum (volume) is shown. \n Adjust color : allows adjusting the color of the sensor. \n \n \n \n \n", 'tags': '', 'url': 'visionSensorPropertiesDialog.html'}, {'title': 'forceSensors', 'text': '\n \n \n \n \n Force sensors  \n Force sensors are initially rigid links between two  shapes  that are able to measure transmitted forces and torques. The rigidity of force sensors is conditional, in the sense that force sensors can be  broken  if a certain condition arises (e.g. if a force or torque threshold is overshot). Following figure illustrates an application using a force sensor: \n \n \n \n [Force sensor object (green) measuring the force and torque exerted by a beam (blue) anchored in a wall (red)] \n \n A force sensor measures a pair of 3 values representing the force on the sensor along the x-, y- and z-axis, and the torque on the sensor about the x-, y- and z-axis: \n \n \n [Forces and torques measured by a force sensor] \n \n Initially, a force sensor acts as a rigid link. During  simulation , a force sensor can however be  broken  when a specified force/torque threshold is overshot or when some other user-defined conditions are met. Following figures illustrate the  broken  state of a force sensor: \n \n \n [Broken force sensor] \n \n A force sensor is only operational during simulation if it is dynamically enabled. For more information on dynamically enabled force sensors, refer also to the section on  designing dynamic simulations .  Joints  are also able to measure a force or a torque, however only along/about their z-axis.  \n Force sensors are added to the  scene  with [Menu bar --> Add --> Force sensor]. \n \n \n \n \n \n', 'tags': '', 'url': 'forceSensors.html'}, {'title': 'forceSensorPropertiesDialog', 'text': "\n \n \n \n \n Force sensor properties \n The force sensor properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Force sensor  button to display the force sensor dialog (the  Force sensor  button only appears if the last selection is a  force sensor ). The dialog displays the settings and parameters of the last selected force sensor. If more than one force sensor is selected, then some parameters can be copied from the last selected force sensor to the other selected force sensors ( Apply to selection -buttons):\n \n \n [Force sensor dialog] \n \n Filter : when force or torque data is acquired by the force sensor, then it is accumulated and can be filtered in order to obtain less jittery values. \n \n Sample size : the number of values that should be used for the filter.  1  will not filter values (raw output). \n Average value : if selected, then the force sensor will deliver average values (average of  sample size  values). \n \n Median value : if selected, then the force sensor will deliver median values (median of  sample size  values). \n \n Trigger settings : this section allows to set up some automatic triggering conditions. A trigger will call the  trigger callback function  (inside which one could for instance  break the force sensor ). \n \n Force threshold : the amplitude of the force vector that activates a threshold violation. \n \n Torque threshold : the amplitude of the torque vector that activates a threshold violation  \n Consecutive threshold violations for breaking : the number of consecutive times the sensor is allowed to violate a threshold before triggering.\n \n Object size : size of the sensor's 3D representation. This has no functional effect. \n \n Adjust color : allows adjusting the color of the sensor.\n \n \n \n \n \n", 'tags': '', 'url': 'forceSensorPropertiesDialog.html'}, {'title': 'octrees', 'text': '\n \n \n \n \n OC trees  \n An OC tree is an  object  that represents a spacial partitioning. It is made up by a tree data structure in which each node has exactly eight children. Occupied leaf nodes are represented as voxels. OC trees can be used to offer a simplified representation for  shapes  or  point clouds , or can act as an occupancy grid/space: \n \n \n [OC tree] \n \n OC trees are  collidable ,  measurable  and  detectable objects . This means that OC trees: \n \n can be used in  collision detections  with other collidable objects. \n can be used in  minimum distance calculations  with other measurable objects.  \n can be detected by  proximity sensors .\n \n OC trees can be added to the  scene  with [Menu bar --> Add --> OC tree], and edited via the  OC tree properties . \n \n The OC tree calculations (i.e. collision, distance and proximity sensor calculations) available in CoppeliaSim are also available as stand-alone routines via the  Coppelia geometric routines . \n \n \n \n \n', 'tags': '', 'url': 'octrees.html'}, {'title': 'octreePropertiesDialog', 'text': '\n \n \n \n \n OC tree properties \n The OC tree properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  OC tree  button to display the OC tree dialog (the  OC tree  button only appears if the last selection is an  OC tree ). The dialog displays the settings and parameters of the last selected OC tree: \n \n \n [OC tree dialog] \n \n Voxel size : the size of the OC tree voxels. The smaller the size, the more memory will be used for the OC tree data structure. \n Insert selected visible objects : allows to insert voxels based on the selected, visible objects. Only  dummies ,  shapes ,  OC trees  and  point clouds  are taken into account. Select all objects you want to insert, then select last the target OC tree object. \n Subtract selected visible objects : allows to remove voxels based on the selected, visible objects. Only  dummies ,  shapes ,  OC trees  and  point clouds  are taken into account. Select all objects you want to insert, then select last the target OC tree object. \n Clear OC tree : removes all the voxels from the OC tree. \n Voxels have random colors : each voxel will have a random color. \n Show OC tree structure : shows the OC tree data structure, mainly for debugging purposes. \n Color is emissive : voxels will be shown in emissive colors. \n Show points instead of voxels : for OC trees containing a large amount of voxels, display can be quite slow. In that case you have the possibility to display pixel voxels, instead of cubic voxels. \n Adjust color for next insertion : allows to select a new color, which will be used for new voxel insertions. \n \n \n \n \n', 'tags': '', 'url': 'octreePropertiesDialog.html'}, {'title': 'pointClouds', 'text': '\n \n \n \n \n Point clouds  \n A point cloud is an  object  that acts as an OC tree based container of points: \n \n \n [Point cloud] \n \n Point clouds are  collidable ,  measurable  and  detectable objects . This means that point clouds: \n \n can be used in  collision detections  with other collidable objects that are volume based, such as  OC trees . \n can be used in  minimum distance calculations  with other measurable objects.  \n can be detected by  proximity sensors .\n \n Point clouds can be added to the  scene  with [Menu bar --> Add --> Point cloud], and edited via the  point cloud properties . \n \n The point cloud calculations (i.e. collision, distance and proximity sensor calculations) available in CoppeliaSim are also available as stand-alone routines via the  Coppelia geometric routines . \n \n \n \n \n', 'tags': '', 'url': 'pointClouds.html'}, {'title': 'pointCloudPropertiesDialog', 'text': '\n \n \n \n \n Point cloud properties \n The point cloud properties are part of the  scene object properties  dialog, which is located at [Menu bar --> Tools --> Scene object properties]. You can also open the dialog with a double-click on an object icon in the  scene hierarchy , or with a click on its  toolbar  button: \n \n \n [Scene object properties toolbar button] \n \n In the scene object properties dialog, click  the  Point cloud  button to display the OC tree dialog (the  Point cloud  button only appears if the last selection is a  point cloud ). The dialog displays the settings and parameters of the last selected point cloud: \n \n \n [Point cloud dialog] \n \n Do not use OC tree calc. structure : by default, point clouds use an OC tree-like calculation structure for efficient point manipulation. Inserting points and removing points might be slowed down by this structure. If you enable this item, then point inserting will be more efficient, but the point cloud will not be  collidable ,  measurable  nor  detectable  anymore, and some other operations might also be limited. You can always toggle this item at a later stage, or via  sim.setPointCloudOptions . \n Max. voxel size : the maximum size of the OC tree voxels, that will contain points. The smaller the size, the more memory will be used for the OC tree data structure this point cloud is based on. \n Max. point count / voxel : the maximum number of points a single OC tree voxel can contain. If more points need to be stored in such a voxel, it will be split into 8 child voxels until the constraint is satisfied. For efficient collision detection, distance calculation and proximity sensor detections, it is recommended to keep about 10-20 points stored in a single voxel.  \n Insert selected visible objects : allows to insert points based on the selected, visible objects. Only  dummies ,  shapes ,  OC trees  and  point clouds  are taken into account. Select all objects you want to insert, then select last the target point cloud object. Shapes will previously be converted to a temporary OC tree with the specified  build resolution . The  Insert tolerance  item allows to avoid having duplicate points, by specifying a minimum distance tolerance used to decide whether the point will be inserted or not. With an insert tolerance > 0.0 the point insertion will be slower. \n Subtract selected visible objects : allows to subtract points based on the selected, visible objects. Only  dummies ,  OC trees  and  point clouds  are taken into account. Select all objects you want to subtract, then select last the target point cloud object. Dummies and point clouds will use a  subtract tolerance  value to identify points to remove. \n Clear point cloud : removes all the points from the point cloud. \n Points have random colors : each point will have a random color. \n Show OC tree structure : shows the underlying OC tree data structure, mainly for debugging purposes. \n Color is emissive : points will be shown in emissive colors. \n Point cnt display ratio : point clouds that contain a large number of points might slow down the rendering. By setting a ratio smaller than 1, a smaller amount of points will be displayed for each OC tree voxel that contains points. This has only an impact on the displayed/rendered image. \n Point size : the size of points, in pixels. \n Adjust color for next insertion : allows to select a new color, which will be used for new point insertions. \n \n \n \n \n', 'tags': '', 'url': 'pointCloudPropertiesDialog.html'}, {'title': 'paths', 'text': "\n \n \n \n \n Paths \n A path is a pseudo  object , representing a succession of points with orientation in space.  pseudo  object, since it is built using merely  dummies  and a  customization script  that describes its functionality and behaviour. \n \n [Simple path containing 4 control points] \n \n Path objects can be added to the  scene \xa0with [Menu bar --> Add --> Path]. A path is composed by control points that define its curve in space. Control points can be shifted, copy/pasted or deleted. A path's basic properties are accessed and adjusted via its user parameters (implemented via a  user config callback function ), in the scene hierarchy: \n \n [User parameter icon] \n \n A path can also automatically generate extruded  shapes ; this functionality is enabled via its user parameters, and the shape profile, color and other details can be adjusted in its  customization script , which uses the API function  sim.generateShapefromPath :  \n \nfunction path.shaping(path,pathIsClosed,upVector)\n    -- following section generates a square extrusion shape:\n    local section={0.02,-0.02,0.02,0.02,-0.02,0.02,-0.02,-0.02,0.02,-0.02}\n    local color={0.7,0.9,0.9}\n    local options=0\n    if pathIsClosed then\n        options=options|4\n    end\n    local shape=sim.generateShapeFromPath(path,section,options,upVector)\n    sim.setShapeColor(shape,nil,sim.colorcomponent_ambient_diffuse,color)\n    return shape\nend \n \n [Simple path generating an extruded square shape] \n \n To generate an extruded circular shape, use following code to create the section data: \n \nlocal section={}\nlocal radius=0.02\nlocal sides=32\nlocal da=math.pi*2/sides\nfor i=0,sides-1,1 do\n    section[2*i+1]=radius*math.cos(da*i)\n    section[2*i+2]=radius*math.sin(da*i)\nend\n-- the section shoujld be closed (first and last points perfect overlap):\nsection[#section+1]=section[1]\nsection[#section+1]=section[2] \n \n [Simple path generating an extruded circular shape] \n \n Path data is stored inside of the path object, as  custom object data . It can be accessed with: \n \n-- control point data (each one has x,y,z,qx,qy,qz,qw (position and quaternion)):\nlocal ctrlPts=sim.unpackDoubleTable(sim.readCustomDataBlock(pathHandle,'PATHCTRLPTS'))\n\n-- path data (each one has x,y,z,qx,qy,qz,qw (position and quaternion)):\nlocal pathData=sim.unpackDoubleTable(sim.readCustomDataBlock(pathHandle,'PATH') \n \n Various  API functions related to paths  are available, e.g. in order to have an object follow a path in position and orientation, one could use following script: \n \nfunction sysCall_init()\n    objectToFollowPath=sim.getObject('.')\n    path=sim.getObject('/Path')\n    pathData=sim.unpackDoubleTable(sim.readCustomDataBlock(path,'PATH'))\n    local m=Matrix(#pathData//7,7,pathData)\n    pathPositions=m:slice(1,1,m:rows(),3):data()\n    pathQuaternions=m:slice(1,4,m:rows(),7):data()\n    pathLengths,totalLength=sim.getPathLengths(pathPositions,3)\n    velocity=0.04 -- m/s\n    posAlongPath=0\n    previousSimulationTime=0\n    corout=coroutine.create(coroutineMain)\nend\n\nfunction sysCall_actuation()\n    if coroutine.status(corout)~='dead' then\n        local ok,errorMsg=coroutine.resume(corout)\n        if errorMsg then\n            error(debug.traceback(corout,errorMsg),2)\n        end\n    end\nend\n\nfunction coroutineMain()\n    sim.setThreadAutomaticSwitch(false)\n    while true do\n        local t=sim.getSimulationTime()\n        posAlongPath=posAlongPath+velocity*(t-previousSimulationTime)\n        posAlongPath=posAlongPath % totalLength\n        local pos=sim.getPathInterpolatedConfig(pathPositions,pathLengths,posAlongPath)\n        local quat=sim.getPathInterpolatedConfig(pathQuaternions,pathLengths,\n                                                 posAlongPath,nil,{2,2,2,2})\n        sim.setObjectPosition(objectToFollowPath,path,pos)\n        sim.setObjectQuaternion(objectToFollowPath,path,quat)\n        previousSimulationTime=t\n        sim.switchThread()\n    end\nend \n \n \n \n \n", 'tags': '', 'url': 'paths.html'}, {'title': 'functionality', 'text': "\n \n \n \n \n Functionality Overview \n CoppeliaSim offers powerful functions enabled by CoppeliaSim itself, enabled via  plugins ,  add-ons , additional routines, or via extension modules. Following gives an overview of CoppeliaSim's main functions:  \n Geometric calculations \n Kinematics \n Dynamics \n Data visualization/output \n Data manipulation/transformation \n Messaging/interfaces/connectivity \n Paths/trajectories \n Path planning \n Synthetic vision \n Custom user interfaces \n Import/Export \n Commands/settings \n Miscellaneous \n \xa0 \n \n \n \n \n", 'tags': '', 'url': 'functionality.html'}, {'title': 'geometricCalculations', 'text': '\n \n \n \n \n Geometric calculations \n CoppeliaSim handles major geometric calculations via the  Coppelia Geometric Routines , which is a collection of c++ functions that can be embedded into stand-alone applications. Those routines are wrapped inside of the  geometric plugin  for CoppeliaSim, which is in charge of handling: \n collision detection \n distance calculation \n proximity sensor  simulation \n Above functionality can directly operate on  dummies ,  shapes ,  OC trees  or  point clouds . \n CoppeliaSim also offers boolean operations on shapes, via  libigl, the simple C++ geometry processing library , wrapped in the  IGL plugin . See also the  API functions related to that plugin . \n \n \n \n \n', 'tags': '', 'url': 'geometricCalculations.html'}, {'title': 'collisionDetection', 'text': "\n \n \n \n \n Collision detection \n CoppeliaSim can detect collisions between two  collidable   entities  in a flexible way. The calculation is an exact interference calculation. Collision detection, as its name states, only detect collisions; it does however not directly react to them (for collision response, refer to the  dynamics module ). \n \n \n [Collision detection between two manipulators] \n \n Using the API function  sim.checkCollision , one can easily detect collision between entities, for instance collision detection between a robot and its environment, from within a  child script , in each simulation step: \n \nfunction sysCall_init()\n    local robotBase=sim.getObject('/robotModelAlias')\n    robotCollection=sim.createCollection(0)\n    sim.addItemToCollection(robotCollection,sim.handle_tree,robotBase,0)\nend\n\nfunction sysCall_sensing()\n    local result,pairHandles=sim.checkCollision(robotCollection,sim.handle_all)\n    if result>0 then\n        print('Robot is colliding. Colliding pair is '..getAsString(pairHandles))\n    end\nend \n One can also temporarily modify the color of  objects  or whole  collections , in order to visually indicate a collision: \n \nfunction changePairColor(entityPair,colorPair)\n    originalColorData={}\n    originalColorData[1]=sim.changeEntityColor(entityPair[1],colorPair[1])\n    originalColorData[2]=sim.changeEntityColor(entityPair[2],colorPair[2])\nend\n\nfunction restorePairColor()\n    if originalColorData then\n        sim.restoreEntityColor(originalColorData[1])\n        sim.restoreEntityColor(originalColorData[2])\n        originalColorData=nil\n    end\nend\n\nfunction sysCall_init()\n    local robotBase=sim.getObject('/irb360')\n    robotCollection=sim.createCollection(0)\n    sim.addItemToCollection(robotCollection,sim.handle_tree,robotBase,0)\n    collisionColors={{1,0,0},{1,0,1}} -- collider and collidee\nend\n\nfunction sysCall_sensing()\n    local result,pairHandles=sim.checkCollision(robotCollection,sim.handle_all)\n    restorePairColor()\n    if result>0 then\n        -- Change color of the collection and the collidee:\n        changePairColor({robotCollection,pairHandles[2]},collisionColors)\n        -- Change color of the collider and collidee objects:\n        -- changePairColor({pairHandles[1],pairHandles[2]},collisionColors)\n    end\nend\n\nfunction sysCall_cleanup()\n    restorePairColor()\nend \n CoppeliaSim's collision detection functionality is also available as stand-alone routines via the  Coppelia geometric routines . \n See also the  add-on   Collision check  that allows to quickly check for self-collision, collision with the environment, or collision between two entities. \n \n \n \n \n", 'tags': '', 'url': 'collisionDetection.html'}, {'title': 'distanceCalculation', 'text': "\n \n \n \n \n Distance calculation \n CoppeliaSim can measure the minimum distance between two  measurable   entities  in a flexible way. The calculation is an exact minimum distance calculation. \n \n \n \n \n [Minimum distance calculation between two manipulators] \n \n Using the API function  sim.checkDistance , one can easily calculate the minimum distance between entities, for instance between a robot and its environment, from within a  child script , in each simulation step: \n \nfunction sysCall_init()\n    local robotBase=sim.getObject('/robotModelAlias')\n    robotCollection=sim.createCollection(0)\n    sim.addItemToCollection(robotCollection,sim.handle_tree,robotBase,0)\nend\n\nfunction sysCall_sensing()\n    local result,distData,objectPair=sim.checkDistance(robotCollection,sim.handle_all)\n    if result>0 then\n        local txt='Robot clearance is '..distData[7]\n        txt=txt..'m, minimum distance object pair is '..getAsString(objectPair)\n        print(txt)\n    end\nend \n One can also display the measured minimum distance, as a colored segment in the scene: \n \nfunction sysCall_init()\n    local robotBase=sim.getObject('/robotModelAlias')\n    robotCollection=sim.createCollection(0)\n    sim.addItemToCollection(robotCollection,sim.handle_tree,robotBase,0)\n    distanceSegment=sim.addDrawingObject(sim.drawing_lines,4,0,-1,1,{0,1,0})\nend\n\nfunction sysCall_sensing()\n    local result,distData,objectPair=sim.checkDistance(robotCollection,sim.handle_all)\n    if result>0 then\n        sim.addDrawingObjectItem(distanceSegment,nil)\n        sim.addDrawingObjectItem(distanceSegment,distData)\n    end\nend \n CoppeliaSim's distance calculation functionality is also available as stand-alone routines via the  Coppelia geometric routines . \n \n \n \n \n", 'tags': '', 'url': 'distanceCalculation.html'}, {'title': 'geometricPlugin', 'text': "\n \n \n \n \n Geometric Plugin \n Performing  collision detection  and  distance calculation  is easily handled via dedicated API functions that operate on  scene objects , e.g. such as  sim.checkCollision  or  sim.checkDistance . \n The same functionality is however also available at a lower level, via the geometric plugin, and allows to perform the same kind of calculations, but in an independent manner from CoppeliaSim scene objects, e.g. you are able to create mesh, OC-tree and point cloud data structures and perform collision detection or distance calculations on them, without having to create scene content. This works by directly interacting with the  geometric plugin's API . \n For an example, refer to the following scene:  scenes/sceneObjectIndependentGeometricCalculationExample.ttt , and make sure to inspect the attached child scripts. \n \n \n \n \n", 'tags': '', 'url': 'geometricPlugin.html'}, {'title': 'simGeom API', 'text': '\n Geom plugin API reference \n All units, \nunless otherwise indicated, are specified in meters and radians. Note \nthat mesh-, point cloud- and OC tree-handles mentioned in this reference\n have no direct relation with CoppeliaSim shape-, point cloud- and OC \ntree-handles: meshes, point cloud and octrees mentioned in this API \nreference are internal representations that are exclusively created, \nmanipulated and destroyed with below API functions. \nBelow API functions are a sub-set of their  C++ API counterpart . \n simGeom.copyMesh \n simGeom.copyOctree \n simGeom.copyPtcloud \n simGeom.createMesh \n simGeom.createMeshFromSerializationData \n simGeom.createOctreeFromColorPoints \n simGeom.createOctreeFromMesh \n simGeom.createOctreeFromOctree \n simGeom.createOctreeFromPoints \n simGeom.createOctreeFromSerializationData \n simGeom.createPtcloudFromColorPoints \n simGeom.createPtcloudFromPoints \n simGeom.createPtcloudFromSerializationData \n simGeom.destroyMesh \n simGeom.destroyOctree \n simGeom.destroyPtcloud \n simGeom.getBoxBoxDistance \n simGeom.getBoxPointDistance \n simGeom.getBoxSegmentDistance \n simGeom.getBoxTriangleDistance \n simGeom.getMeshMeshCollision \n simGeom.getMeshMeshDistance \n simGeom.getMeshOctreeCollision \n simGeom.getMeshOctreeDistance \n simGeom.getMeshPointDistance \n simGeom.getMeshPtcloudDistance \n simGeom.getMeshSegmentCollision \n simGeom.getMeshSegmentDistance \n simGeom.getMeshSerializationData \n simGeom.getMeshTriangleCollision \n simGeom.getMeshTriangleDistance \n simGeom.getOctreeOctreeCollision \n simGeom.getOctreeOctreeDistance \n simGeom.getOctreePointCollision \n simGeom.getOctreePointDistance \n simGeom.getOctreePtcloudCollision \n simGeom.getOctreePtcloudDistance \n simGeom.getOctreeSegmentCollision \n simGeom.getOctreeSegmentDistance \n simGeom.getOctreeSerializationData \n simGeom.getOctreeTriangleCollision \n simGeom.getOctreeTriangleDistance \n simGeom.getOctreeVoxels \n simGeom.getPtcloudPointDistance \n simGeom.getPtcloudPoints \n simGeom.getPtcloudPtcloudDistance \n simGeom.getPtcloudSegmentDistance \n simGeom.getPtcloudSerializationData \n simGeom.getPtcloudTriangleDistance \n simGeom.getSegmentPointDistance \n simGeom.getSegmentSegmentDistance \n simGeom.getTransformedPoints \n simGeom.getTrianglePointDistance \n simGeom.getTriangleSegmentDistance \n simGeom.getTriangleTriangleDistance \n simGeom.scaleMesh \n simGeom.scaleOctree \n simGeom.scalePtcloud \n \n Mesh creation/destruction/manipulation/info \n simGeom.createMesh \n simGeom.destroyMesh \n simGeom.copyMesh \n simGeom.scaleMesh \n simGeom.getMeshSerializationData \n simGeom.createMeshFromSerializationData \n \n OC-tree creation/destruction/manipulation/info \n simGeom.createOctreeFromColorPoints \n simGeom.createOctreeFromMesh \n simGeom.createOctreeFromOctree \n simGeom.createOctreeFromPoints \n simGeom.destroyOctree \n simGeom.copyOctree \n simGeom.scaleOctree \n simGeom.getOctreeSerializationData \n simGeom.createOctreeFromSerializationData \n simGeom.getOctreeVoxels \n \n Point-cloud creation/destruction/manipulation/info \n simGeom.createPtcloudFromColorPoints \n simGeom.createPtcloudFromPoints \n simGeom.destroyPtcloud \n simGeom.copyPtcloud \n simGeom.scalePtcloud \n simGeom.getPtcloudSerializationData \n simGeom.createPtcloudFromSerializationData \n simGeom.getPtcloudPoints \n \n Mesh collision detection \n simGeom.getMeshMeshCollision \n simGeom.getMeshOctreeCollision \n simGeom.getMeshTriangleCollision \n simGeom.getMeshSegmentCollision \n \n OC-tree collision detection \n simGeom.getMeshOctreeCollision \n simGeom.getOctreeOctreeCollision \n simGeom.getOctreePtcloudCollision \n simGeom.getOctreeTriangleCollision \n simGeom.getOctreeSegmentCollision \n simGeom.getOctreePointCollision \n \n Point-cloud collision detection \n simGeom.getOctreePtcloudCollision \n \n Mesh minimum distance calculation \n simGeom.getMeshMeshDistance \n simGeom.getMeshOctreeDistance \n simGeom.getMeshPtcloudDistance \n simGeom.getMeshTriangleDistance \n simGeom.getMeshSegmentDistance \n simGeom.getMeshPointDistance \n \n OC-tree minimum distance calculation \n simGeom.getMeshOctreeDistance \n simGeom.getOctreeOctreeDistance \n simGeom.getOctreePtcloudDistance \n simGeom.getOctreeTriangleDistance \n simGeom.getOctreeSegmentDistance \n simGeom.getOctreePointDistance \n \n Point-cloud minimum distance calculation \n simGeom.getOctreePtcloudDistance \n simGeom.getMeshPtcloudDistance \n simGeom.getPtcloudPtcloudDistance \n simGeom.getPtcloudTriangleDistance \n simGeom.getPtcloudSegmentDistance \n simGeom.getPtcloudPointDistance \n \n Primitives minimum distance calculation \n simGeom.getBoxBoxDistance \n simGeom.getBoxTriangleDistance \n simGeom.getBoxSegmentDistance \n simGeom.getBoxPointDistance \n simGeom.getTriangleTriangleDistance \n simGeom.getTriangleSegmentDistance \n simGeom.getTrianglePointDistance \n simGeom.getSegmentSegmentDistance \n simGeom.getSegmentPointDistance \n \n Other API functions \n simGeom.getTransformedPoints \n \n \n \n \n simGeom.copyMesh \n \n \n Description \n Duplicates a mesh object. \n \n \n Lua synopsis \n int meshCopyHandle=simGeom.copyMesh(int meshHandle) \n \n \n Lua arguments \n \n meshHandle : the mesh object to duplicate. \n \n \n \n Lua return value(s) \n \n meshCopyHandle : the copy of the mesh object in case of success. \n \n \n \n Python synopsis \n int meshCopyHandle=simGeom.copyMesh(int meshHandle) \n \n \n See also \n simGeom.createMesh \n \n \n \n \n simGeom.copyOctree \n \n \n Description \n Duplicates an OC-tree object. \n \n \n Lua synopsis \n int octreeCopyHandle=simGeom.copyOctree(int octreeHandle) \n \n \n Lua arguments \n \n octreeHandle : the OC-tree object to duplicate. \n \n \n \n Lua return value(s) \n \n octreeCopyHandle : the handle of the duplicated OC-tree object. \n \n \n \n Python synopsis \n int octreeCopyHandle=simGeom.copyOctree(int octreeHandle) \n \n \n See also \n \n \n \n \n \n simGeom.copyPtcloud \n \n \n Description \n Duplicates a point-cloud object. \n \n \n Lua synopsis \n int ptcloudCopyHandle=simGeom.copyPtcloud(int ptcloudHandle) \n \n \n Lua arguments \n \n ptcloudHandle : the point-cloud object to duplicate. \n \n \n \n Lua return value(s) \n \n ptcloudCopyHandle : the handle of the duplicated point-cloud object. \n \n \n \n Python synopsis \n int ptcloudCopyHandle=simGeom.copyPtcloud(int ptcloudHandle) \n \n \n See also \n \n \n \n \n \n simGeom.createMesh \n \n \n Description \n Creates a mesh object. \n \n \n Lua synopsis \n int meshHandle=simGeom.createMesh(float[] \nvertices,int[] indices,float[3] meshOriginPos=nil,float[4] \nmeshOriginQuat=nil,float triangleEdgeMaxLength=0.3,int \nmaxTrianglesInBoundingBox=8) \n \n \n Lua arguments \n \n vertices : a table with the vertices of the mesh, expressed relative to the world origin. \n indices : a table with the indices of the mesh. \n meshOriginPos : the transformation frame position \nof the mesh. Can be omitted, in which case the frame of the mesh is \nlocated at the world origin. \n meshOriginQuat : the transformation frame \nquaternion of the mesh. Can be omitted, in which case the frame of the \nmesh is oriented as the world reference frame. \n triangleEdgeMaxLength : the maximum triangle size \nused internally for efficient calculations. A smaller size usually \nresults in faster calculations, but larger calculation structures. Can \nbe omitted. \n maxTrianglesInBoundingBox : the maximum number of \ntriangles in leaf bounding boxes, used internally for efficient \ncalculations. A smaller value usually results in faster calculations, \nbut larger calculation structures. Can be omitted. \n \n \n \n Lua return value(s) \n \n meshHandle : the handle to the mesh object in case of success. \n \n \n \n Python synopsis \n int meshHandle=simGeom.createMesh(list \nvertices,list indices,list meshOriginPos=None,list \nmeshOriginQuat=None,float triangleEdgeMaxLength=0.3,int \nmaxTrianglesInBoundingBox=8) \n \n \n See also \n simGeom.destroyMesh ,  simGeom.copyMesh ,  simGeom.createMeshFromSerializationData \n \n \n \n \n simGeom.createMeshFromSerializationData \n \n \n Description \n Creates a mesh object based on serialization data. \n \n \n Lua synopsis \n int meshHandle=simGeom.createMeshFromSerializationData(buffer serializationData) \n \n \n Lua arguments \n \n serializationData : the serialization data previously generated with  simGeom.getMeshSerializationData . \n \n \n \n Lua return value(s) \n \n meshHandle : the handle of the created mesh. \n \n \n \n Python synopsis \n int meshHandle=simGeom.createMeshFromSerializationData(bytes serializationData) \n \n \n See also \n simGeom.getMeshSerializationData \n \n \n \n \n simGeom.createOctreeFromColorPoints \n \n \n Description \n Creates an OC-tree object from several points with individual colors and individual user data. \n \n \n Lua synopsis \n int \noctreeHandle=simGeom.createOctreeFromColorPoints(float[] points,float[3]\n octreeOriginPos=nil,float[4] octreeOriginQuat=nil,float \ncellS=0.05,int[] rgbData=nil,int[] usrData=nil) \n \n \n Lua arguments \n \n points : a table with point data, expressed relative to the world origin. \n octreeOriginPos : the transformation frame position\n of the OC-tree. Can be omitted, in which case the frame of the OC-tree \nis located at the world origin. \n octreeOriginQuat : the transformation frame \nquaternion of the OC-tree. Can be omitted, in which case the frame \norientation of the OC-tree is same as the world origin. \n cellS : The desired OC-tree voxel size. Can be omitted. \n rgbData : the RGB colors (0-255)of the various points (i.e. one color per point). Can be omitted. \n usrData : the user data of the various points (i.e. one user data per point). Can be omitted. \n \n \n \n Lua return value(s) \n \n octreeHandle : the handle of the created OC-tree object. \n \n \n \n Python synopsis \n int \noctreeHandle=simGeom.createOctreeFromColorPoints(list points,list \noctreeOriginPos=None,list octreeOriginQuat=None,float cellS=0.05,list \nrgbData=None,list usrData=None) \n \n \n See also \n simGeom.createOctreeFromPoints ,  simGeom.createOctreeFromMesh ,  simGeom.createOctreeFromOctree ,  simGeom.destroyOctree ,  simGeom.copyOctree ,  simGeom.createOctreeFromSerializationData \n \n \n \n \n simGeom.createOctreeFromMesh \n \n \n Description \n Creates an OC-tree object from a mesh object. \n \n \n Lua synopsis \n int \noctreeHandle=simGeom.createOctreeFromMesh(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,float[3] octreeOriginPos=nil,float[4] \noctreeOriginQuat=nil,float cellS=0.05,int[3] rgbData=nil,int usrData=0) \n \n \n Lua arguments \n \n meshHandle : the mesh object. \n meshPos : the position of the mesh object. \n meshQuat : the quaternion of the mesh object. \n octreeOriginPos : the transformation frame position\n of the OC-tree. Can be omitted, in which case the frame of the OC-tree \nis located at the world origin. \n octreeOriginQuat : the transformation frame \nquaternion of the OC-tree. Can be omitted, in which case the frame \norientation of the OC-tree is same as the world origin. \n cellS : The desired OC-tree voxel size. Can be omitted. \n rgbData : the RGB color (0-255) of the generated voxels. Can be omitted. \n usrData : the user data of the generated voxels. Can be omitted. \n \n \n \n Lua return value(s) \n \n octreeHandle : the handle of the created OC-tree object. \n \n \n \n Python synopsis \n int \noctreeHandle=simGeom.createOctreeFromMesh(int meshHandle,list \nmeshPos,list meshQuat,list octreeOriginPos=None,list \noctreeOriginQuat=None,float cellS=0.05,list rgbData=None,int usrData=0) \n \n \n See also \n simGeom.createOctreeFromPoints , simGeom.createOctreeFromColorPoints ,  simGeom.createOctreeFromOctree ,  simGeom.destroyOctree ,  simGeom.copyOctree ,  simGeom.createOctreeFromSerializationData \n \n \n \n \n simGeom.createOctreeFromOctree \n \n \n Description \n Creates an OC-tree object from another OC-tree object. \n \n \n Lua synopsis \n int \nnewOctreeHandle=simGeom.createOctreeFromOctree(int octreeHandle,float[3]\n octreepos,float[4] octreeQuat,float[3] newOctreeOriginPos=nil,float[4] \nnewOctreeOriginQuat=nil,float newOctreeCellS=0.05,int[3] rgbData=nil,int\n usrData=0) \n \n \n Lua arguments \n \n octreeHandle : the handle to the OC-tree object. \n octreePos : the position of the OC-tree object. \n octreeQuat : the quaternion of the OC-tree object. \n newOctreeOriginPos : the transformation frame \nposition of the new OC-tree. Can be omitted, in which case the frame of \nthe new OC-tree is located at the world origin. \n newOctreeOriginQuat : the transformation frame \nquaternion of the new OC-tree. Can be omitted, in which case the frame \norientation of the new OC-tree is same as the world origin. \n newOctreeCellS : The desired OC-tree voxel size. Can be omitted. \n rgbData : the RGB color (0-255) of the generated voxels. Can be omitted. \n usrData : the user data of the generated voxels. Can be omitted. \n \n \n \n Lua return value(s) \n \n newOctreeHandle : the handle of the new OC-tree object. \n \n \n \n Python synopsis \n int \nnewOctreeHandle=simGeom.createOctreeFromOctree(int octreeHandle,list \noctreepos,list octreeQuat,list newOctreeOriginPos=None,list \nnewOctreeOriginQuat=None,float newOctreeCellS=0.05,list rgbData=None,int\n usrData=0) \n \n \n See also \n simGeom.createOctreeFromPoints , simGeom.createOctreeFromColorPoints ,  simGeom.createOctreeFromMesh ,  simGeom.destroyOctree ,  simGeom.copyOctree ,  simGeom.createOctreeFromSerializationData \n \n \n \n \n simGeom.createOctreeFromPoints \n \n \n Description \n Creates an OC-tree object from several points. \n \n \n Lua synopsis \n int \noctreeHandle=simGeom.createOctreeFromPoints(float[] points,float[3] \noctreeOriginPos=nil,float[4] octreeOriginQuat=nil,float cellS=0.05,int[]\n rgbData=nil,int usrData=0) \n \n \n Lua arguments \n \n points : an table with point data, expressed relative to the world origin. \n octreeOriginPos : the transformation frame position\n of the OC-tree. Can be omitted, in which case the frame position of the\n OC-tree is located at the world origin. \n octreeOriginQuat : the transformation frame \nquaternion of the OC-tree. Can be omitted, in which case the frame \norientation of the OC-tree is same as the world origin. \n cellS : The desired OC-tree voxel size. Can be omitted. \n rgbData : the RGB color (0-255) of the generated voxels. Can be omitted. \n usrData : the user data of the generated voxels. Can be omitted. \n \n \n \n Lua return value(s) \n \n octreeHandle : the handle of the created OC-tree object. \n \n \n \n Python synopsis \n int \noctreeHandle=simGeom.createOctreeFromPoints(list points,list \noctreeOriginPos=None,list octreeOriginQuat=None,float cellS=0.05,list \nrgbData=None,int usrData=0) \n \n \n See also \n simGeom.createOctreeFromColorPoints ,  simGeom.createOctreeFromMesh ,  simGeom.createOctreeFromOctree ,  simGeom.destroyOctree ,  simGeom.copyOctree ,  simGeom.createOctreeFromSerializationData \n \n \n \n \n simGeom.createOctreeFromSerializationData \n \n \n Description \n Creates an OC-tree object based on serialization data. \n \n \n Lua synopsis \n int octreeHandle=simGeom.createOctreeFromSerializationData(buffer serializationData) \n \n \n Lua arguments \n \n serializationData : the serialization data previously generated with  simGeom.getOctreeSerializationData . \n \n \n \n Lua return value(s) \n \n octreeHandle : the handle to the created OC-tree object. \n \n \n \n Python synopsis \n int octreeHandle=simGeom.createOctreeFromSerializationData(bytes serializationData) \n \n \n See also \n simGeom.getOctreeSerializationData \n \n \n \n \n simGeom.createPtcloudFromColorPoints \n \n \n Description \n Creates a point-cloud object from several points with individual colors. \n \n \n Lua synopsis \n int \nptcloudHandle=simGeom.createPtcloudFromColorPoints(float[] \npoints,float[3] ptcloudOriginPos=nil,float[4] \nptcloudOriginQuat=nil,float cellS=0.05,int maxPointCnt=20,int[] \nrgbData=nil,float proximityTol=0.005) \n \n \n Lua arguments \n \n points : a table with point data, expressed relative to the world origin. \n ptcloudOriginPos : the transformation frame \nposition of the point-cloud. Can be omitted, in which case the frame of \nthe point-cloud is located at the world origin. \n ptcloudOriginQuat : the transformation frame \nquaternion of the point-cloud. Can be omitted, in which case the frame \norientation of the point-cloud is same as the world origin. \n cellS : The desired voxel size of the underlying OC-tree. Can be omitted. \n maxPointCnt : The maximum amount of points inside of a OC-tree voxel. Can be omitted. \n rgbData : the RGB color (0-255) of the generated points. Specify one color per point. Can be omitted. \n proximityTol : the distance tolerance to other \npoints (i.e. point-point distances below the specified value are not \npermitted and points will be omitted). Can be omitted. \n \n \n \n Lua return value(s) \n \n ptcloudHandle : the handle to the created point-cloud object. \n \n \n \n Python synopsis \n int \nptcloudHandle=simGeom.createPtcloudFromColorPoints(list points,list \nptcloudOriginPos=None,list ptcloudOriginQuat=None,float cellS=0.05,int \nmaxPointCnt=20,list rgbData=None,float proximityTol=0.005) \n \n \n See also \n simGeom.createPtcloudFromPoints ,  simGeom.destroyPtcloud ,  simGeom.copyPtcloud ,  simGeom.createPtcloudFromSerializationData \n \n \n \n \n simGeom.createPtcloudFromPoints \n \n \n Description \n Creates a point-cloud object from several points. \n \n \n Lua synopsis \n int \nptcloudHandle=simGeom.createPtcloudFromPoints(float[] points,float[3] \nptcloudOriginPos=nil,float[4] ptcloudOriginQuat=nil,float cellS=0.05,int\n maxPointCnt=20,int[3] rgbData=nil,float proximityTol=0.005) \n \n \n Lua arguments \n \n points : a table with point data, expressed relative to the world origin. \n ptcloudOriginPos : the transformation frame \nposition of the point-cloud. Can be omitted, in which case the frame of \nthe point-cloud is located at the world origin. \n ptcloudOriginQuat : the transformation frame \nquaternion of the point-cloud. Can be omitted, in which case the frame \norientation of the point-cloud is same as the world origin. \n cellS : The desired voxel size of the underlying OC-tree. Can be omitted. \n maxPointCnt : The maximum amount of points inside of a OC-tree voxel. Can be omitted. \n rgbData : the RGB color (0-255) of the generated points. Can be omitted. \n proximityTol : the distance tolerance to other \npoints (i.e. point-point distances below the specified value are not \npermitted and points will be omitted). Can be omitted. \n \n \n \n Lua return value(s) \n \n ptcloudHandle : the handle to the created point-cloud object. \n \n \n \n Python synopsis \n int \nptcloudHandle=simGeom.createPtcloudFromPoints(list points,list \nptcloudOriginPos=None,list ptcloudOriginQuat=None,float cellS=0.05,int \nmaxPointCnt=20,list rgbData=None,float proximityTol=0.005) \n \n \n See also \n simGeom.createPtcloudFromColorPoints ,  simGeom.destroyPtcloud ,  simGeom.copyPtcloud ,  simGeom.createPtcloudFromSerializationData \n \n \n \n \n simGeom.createPtcloudFromSerializationData \n \n \n Description \n Creates a point-cloud object based on serialization data. \n \n \n Lua synopsis \n int ptcloudHandle=simGeom.createPtcloudFromSerializationData(buffer serializationData) \n \n \n Lua arguments \n \n serializationData : the serialization data previously generated with  simGeom.getPtcloudSerializationData . \n \n \n \n Lua return value(s) \n \n ptcloudHandle : the handle of the created point-cloud. \n \n \n \n Python synopsis \n int ptcloudHandle=simGeom.createPtcloudFromSerializationData(bytes serializationData) \n \n \n See also \n simGeom.getPtcloudSerializationData \n \n \n \n \n simGeom.destroyMesh \n \n \n Description \n Destroys a mesh object. \n \n \n Lua synopsis \n simGeom.destroyMesh(int meshHandle) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n \n \n \n Lua return value(s) \n \n \n \n Python synopsis \n simGeom.destroyMesh(int meshHandle) \n \n \n See also \n simGeom.createMesh \n \n \n \n \n simGeom.destroyOctree \n \n \n Description \n Destroys an OC-tree object. \n \n \n Lua synopsis \n simGeom.destroyOctree(int octreeHandle) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n \n \n \n Lua return value(s) \n \n \n \n Python synopsis \n simGeom.destroyOctree(int octreeHandle) \n \n \n See also \n simGeom.createOctreeFromPoints \n \n \n \n \n simGeom.destroyPtcloud \n \n \n Description \n Destroys a point-cloud object. \n \n \n Lua synopsis \n  simGeom.destroyPtcloud(int ptcloudHandle) \n \n \n Lua arguments \n \n ptcloudHandle : the handle of the point-cloud object. \n \n \n \n Lua return value(s) \n \n \n \n Python synopsis \n  simGeom.destroyPtcloud(int ptcloudHandle) \n \n \n See also \n simGeom.createPtcloudFromPoints \n \n \n \n \n simGeom.getBoxBoxDistance \n \n \n Description \n Computes the minimum distance between two cuboids. \n \n \n Lua synopsis \n float distance,float[3] \ndistSegPt1,float[3] distSegPt2=simGeom.getBoxBoxDistance(float[3] \nbox1Pos,float[4] box1Quat,float[3] box1HalfSize,float[3] \nbox2Pos,float[4] box2Quat,float[3] box2HalfSize,bool boxesAreSolid,bool \naltRoutine=false) \n \n \n Lua arguments \n \n box1Pos : the position of the first cuboid.   box1Quat : the quaternion of the first cuboid. \n box1HalfSize : the half-size of the first cuboid. \n box2Pos : the position of the second cuboid.   box2Quat : the quaternion of the second cuboid. \n box2HalfSize : the half-size of the second cuboid. \n boxesAreSolid : whether the two cuboids are solid. \nIf true, then cuboid A being fully encompassed by cuboid B will always \nlead to a distance of zero between the two cuboids. \n altRoutine : if true, an alternative calculation routine will be used. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n distSegPt1 : the minimum distance point on the first cuboid. \n distSegPt2 : the minimum distance point on the second cuboid. \n \n \n \n Python synopsis \n float distance,list distSegPt1,list \ndistSegPt2=simGeom.getBoxBoxDistance(list box1Pos,list box1Quat,list \nbox1HalfSize,list box2Pos,list box2Quat,list box2HalfSize,bool \nboxesAreSolid,bool altRoutine=False) \n \n \n See also \n simGeom.getBoxTriangleDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getBoxPointDistance \n \n \n \n \n simGeom.getBoxPointDistance \n \n \n Description \n Computes the minimum distance between a cuboid and a point. \n \n \n Lua synopsis \n float distance,float[3] \nboxDistSegPt=simGeom.getBoxPointDistance(float[3] boxPos,float[3] \nboxQuat,float[3] boxHalfSize,bool boxIsSolid,float[3] point) \n \n \n Lua arguments \n \n boxPos : the position of the cuboid.   boxQuat : the quaternion of the cuboid. \n boxHalfSize : the half-size of the cuboid. \n boxIsSolid : whether the cuboid is solid. If true, \nthen the point being fully encompassed by the cuboid will always lead to\n a distance of zero. \n point : position of the point. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n boxDistSegPt : the minimum distance point on the cuboid. \n \n \n \n Python synopsis \n float distance,list \nboxDistSegPt=simGeom.getBoxPointDistance(list boxPos,list boxQuat,list \nboxHalfSize,bool boxIsSolid,list point) \n \n \n See also \n simGeom.getMeshPointDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudPointDistance ,  simGeom.getBoxBoxDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getTrianglePointDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getBoxSegmentDistance \n \n \n Description \n Computes the minimum distance between a cuboid and a segment. \n \n \n Lua synopsis \n float distance,float[3] \nboxDistSegPt,float[3] \nsegmentSegPt=simGeom.getBoxSegmentDistance(float[3] boxPos,float[3] \nboxQuat,float[3] boxHalfSize,bool boxIsSolid,float[3] \nsegmentEndPoint,float[3] segmentVector,bool altRoutine=false) \n \n \n Lua arguments \n \n boxPos : the position of the cuboid.   boxQuat : the quaternion of the cuboid. \n boxHalfSize : the half-size of the cuboid. \n boxIsSolid : whether the cuboid is solid. If true, \nthen the segment being fully encompassed by the cuboid will always lead \nto a distance of zero. \n segmentEndPoint : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n altRoutine : if true, an alternative calculation routine will be used. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n boxDistSegPt : the minimum distance point on the cuboid. \n segmentSegPt : the minimum distance point on the segment. \n \n \n \n Python synopsis \n float distance,list boxDistSegPt,list \nsegmentSegPt=simGeom.getBoxSegmentDistance(list boxPos,list boxQuat,list\n boxHalfSize,bool boxIsSolid,list segmentEndPoint,list \nsegmentVector,bool altRoutine=False) \n \n \n See also \n simGeom.getMeshSegmentDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getBoxBoxDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getBoxPointDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getSegmentSegmentDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getBoxTriangleDistance \n \n \n Description \n Computes the minimum distance between a cuboid and a triangle. \n \n \n Lua synopsis \n float distance,float[3] \nboxDistSegPt,float[3] \ntriangleDistSegPt=simGeom.getBoxTriangleDistance(float[3] \nboxPos,float[3] boxQuat,float[3] boxHalfSize,bool boxIsSolid,float[3] \np,float[3] v,float[3] w,bool altRoutine=false) \n \n \n Lua arguments \n \n boxPos : the position of the cuboid.   boxQuat : the quaternion of the cuboid. \n boxHalfSize : the half-size of the cuboid. \n boxIsSolid : whether the cuboid is solid. If true, \nthen the triangle being fully encompassed by the cuboid will always lead\n to a distance of zero. \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n altRoutine : if true, an alternative calculation routine will be used. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n boxDistSegPt : the minimum distance point on the cuboid. \n triangleDistSegPt : the minimum distance point on the triangle. \n \n \n \n Python synopsis \n float distance,list boxDistSegPt,list \ntriangleDistSegPt=simGeom.getBoxTriangleDistance(list boxPos,list \nboxQuat,list boxHalfSize,bool boxIsSolid,list p,list v,list w,bool \naltRoutine=False) \n \n \n See also \n simGeom.getMeshTriangleDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getBoxBoxDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getBoxPointDistance ,  simGeom.getTriangleTriangleDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getTrianglePointDistance \n \n \n \n \n simGeom.getMeshMeshCollision \n \n \n Description \n Checks for collision between two mesh objects. \n \n \n Lua synopsis \n bool collisionResult,int[2] \ncaching,float[] intersections=simGeom.getMeshMeshCollision(int \nmesh1Handle,float[3] mesh1Pos,float[4] mesh1Quat,int \nmesh2Handle,float[3] mesh2Pos,float[4] mesh2Quat,int[2] caching=nil,bool\n returnIntersections=false) \n \n \n Lua arguments \n \n mesh1Handle : the handle of the first mesh object. \n mesh1Pos : the position of the first mesh object. \n mesh1Quat : the quaternion of the first mesh object. \n mesh2Handle : the handle of the second mesh object. \n mesh2Pos : the position of the second mesh object. \n mesh2Quat : the quaternion of the second mesh object. \n caching : a table with two values from previous collision checking between the same two entities, to speed-up calculations. \n returnIntersections : whether the interference segments should be computed and returned. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status \n caching : a table with two values that can be used \nto speed-up next collision checking between the same two entities \n(memorizes the colliding triangle in the two meshes). \n intersections : the interference segments. \n \n \n \n Python synopsis \n bool collisionResult,list caching,list \nintersections=simGeom.getMeshMeshCollision(int mesh1Handle,list \nmesh1Pos,list mesh1Quat,int mesh2Handle,list mesh2Pos,list \nmesh2Quat,list caching=None,bool returnIntersections=False) \n \n \n See also \n simGeom.getMeshOctreeCollision ,  simGeom.getMeshTriangleCollision ,  simGeom.getMeshSegmentCollision \n \n \n \n \n simGeom.getMeshMeshDistance \n \n \n Description \n Computes the minimum distance between two mesh objects. \n \n \n Lua synopsis \n float distance,float[3] \nminDistSegPt1,float[3] minDistSegPt2,int[2] \ncaching=simGeom.getMeshMeshDistance(int mesh1Handle,float[3] \nmesh1Pos,float[4] mesh1Quat,int mesh2Handle,float[3] mesh2Pos,float[4] \nmesh2Quat,float thresholdDist=nil,int[2] caching=nil) \n \n \n Lua arguments \n \n mesh1Handle : the handle of the first mesh object. \n mesh1Pos : the position of the first mesh.   mesh1Quat : the quaternion of the first mesh. \n mesh2Handle : the handle of the second mesh object. \n mesh2Pos : the position of the second mesh.   mesh2Quat : the quaternion of the second mesh. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a table with two values from previous \ndistance calculation between the same two entities, to speed-up \ncalculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n minDistSegPt1 : the minimum distance point on the first mesh. nil if the distance is not smaller than the threshold distance. \n minDistSegPt2 : the minimum distance point on the second mesh. nil if the distance is not smaller than the threshold distance. \n caching : a table with two values that can be used \nto speed-up next distance calculation between the same two entities. nil\n if the distance is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list minDistSegPt1,list \nminDistSegPt2,list caching=simGeom.getMeshMeshDistance(int \nmesh1Handle,list mesh1Pos,list mesh1Quat,int mesh2Handle,list \nmesh2Pos,list mesh2Quat,float thresholdDist=None,list caching=None) \n \n \n See also \n simGeom.getMeshOctreeDistance ,  simGeom.getMeshPtcloudDistance ,  simGeom.getMeshTriangleDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getMeshPointDistance \n \n \n \n \n simGeom.getMeshOctreeCollision \n \n \n Description \n Checks for collision between a mesh object and an OC-tree object. \n \n \n Lua synopsis \n bool collisionResult,int[2] \ncaching=simGeom.getMeshOctreeCollision(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,int octreeHandle,float[3] octreePos,float[4] \noctreeQuat,int[2] caching=nil) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n caching : a table with two values from previous collision checking between the same two entities, to speed-up calculations. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a table with two values that can be used to speed-up next collision checking between the same two entities. \n \n \n \n Python synopsis \n bool collisionResult,list \ncaching=simGeom.getMeshOctreeCollision(int meshHandle,list meshPos,list \nmeshQuat,int octreeHandle,list octreePos,list octreeQuat,list \ncaching=None) \n \n \n See also \n simGeom.getMeshMeshCollision ,  simGeom.getMeshTriangleCollision ,  simGeom.getMeshSegmentCollision ,  simGeom.getOctreeOctreeCollision ,  simGeom.getOctreePtcloudCollision ,  simGeom.getOctreeTriangleCollision ,  simGeom.getOctreeSegmentCollision ,  simGeom.getOctreePointCollision \n \n \n \n \n simGeom.getMeshOctreeDistance \n \n \n Description \n Computes the minimum distance between a mesh object and an OC-tree object. \n \n \n Lua synopsis \n float distance,float[3] \nmeshMinDistPt,float[3] ocMinDistPt,int[2] \ncaching=simGeom.getMeshOctreeDistance(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,int octreeHandle,float[3] octreePos,float[4] \noctreeQuat,float thresholdDist=nil,int[2] caching=nil) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a table with two values from previous \ndistance calculation between the same two entities, to speed-up \ncalculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n meshMinDistPt : the minimum distance point on the mesh. nil if the distance is not smaller than the threshold distance. \n ocMinDistPt : the minimum distance point on the OC-tree. nil if the distance is not smaller than the threshold distance. \n caching : a table with two values that can be used \nto speed-up next distance calculation between the same two entities. nil\n if the distance is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list meshMinDistPt,list \nocMinDistPt,list caching=simGeom.getMeshOctreeDistance(int \nmeshHandle,list meshPos,list meshQuat,int octreeHandle,list \noctreePos,list octreeQuat,float thresholdDist=None,list caching=None) \n \n \n See also \n simGeom.getMeshMeshDistance ,  simGeom.getMeshPtcloudDistance ,  simGeom.getMeshTriangleDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreeOctreeDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getOctreePointDistance \n \n \n \n \n simGeom.getMeshPointDistance \n \n \n Description \n Computes the minimum distance between a mesh object and a point. \n \n \n Lua synopsis \n float distance,float[3] meshMinDistPt,int \ncaching=simGeom.getMeshPointDistance(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,float[3] point,float thresholdDist=nil,int \ncaching=-1) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n point : the position of the point. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n meshMinDistPt : the minimum distance point on the mesh. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list meshMinDistPt,int \ncaching=simGeom.getMeshPointDistance(int meshHandle,list meshPos,list \nmeshQuat,list point,float thresholdDist=None,int caching=-1) \n \n \n See also \n simGeom.getMeshMeshDistance ,  simGeom.getMeshOctreeDistance ,  simGeom.getMeshPtcloudDistance ,  simGeom.getMeshTriangleDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudPointDistance ,  simGeom.getBoxPointDistance ,  simGeom.getTrianglePointDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getMeshPtcloudDistance \n \n \n Description \n Computes the minimum distance between a mesh object and a point-cloud object. \n \n \n Lua synopsis \n float distance,float[3] \nmeshMinDistPt,float[3] pcMinDistPt,int[2] \ncaching=simGeom.getMeshPtcloudDistance(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,int ptcloudHandle,float[3] pcPos,float[4] \npcQuat,float thresholdDist=nil,int[2] caching=nil) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n ptcloudHandle : the handle of the point-cloud object. \n pcPos : the position of the point-cloud.   pcQuat : the quaternion of the point-cloud. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a table with two values from previous \ndistance calculation between the same two entities, to speed-up \ncalculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n meshMinDistPt : the minimum distance point on the mesh. nil if the distance is not smaller than the threshold distance. \n pcMinDistPt : the minimum distance point on the point-cloud. nil if the distance is not smaller than the threshold distance. \n caching : a table with two values that can be used \nto speed-up next distance calculation between the same two entities. nil\n if the distance is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list meshMinDistPt,list \npcMinDistPt,list caching=simGeom.getMeshPtcloudDistance(int \nmeshHandle,list meshPos,list meshQuat,int ptcloudHandle,list pcPos,list \npcQuat,float thresholdDist=None,list caching=None) \n \n \n See also \n simGeom.getMeshMeshDistance ,  simGeom.getMeshOctreeDistance ,  simGeom.getMeshTriangleDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getPtcloudPtcloudDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getPtcloudPointDistance \n \n \n \n \n simGeom.getMeshSegmentCollision \n \n \n Description \n Checks for collision between a mesh object and a segment. \n \n \n Lua synopsis \n bool collisionResult,int caching,float[] \nintersections=simGeom.getMeshSegmentCollision(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,float[3] segmentExtremity,float[3] \nsegmentVector,int caching=-1,bool returnIntersections) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n segmentExtremity : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n caching : a values from previous collision checking\n between the same two entities, to speed-up collision checking. Can be \nomitted or set to -1. \n returnIntersections : whether the interference segments should be returned. Can be omitted. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a value that can be used to speed-up next collision checking between the same two entities. \n intersections : the interference segments which actually represent one or more segments with zero length. \n \n \n \n Python synopsis \n bool collisionResult,int caching,list \nintersections=simGeom.getMeshSegmentCollision(int meshHandle,list \nmeshPos,list meshQuat,list segmentExtremity,list segmentVector,int \ncaching=-1,bool returnIntersections) \n \n \n See also \n simGeom.getMeshMeshCollision ,  simGeom.getMeshOctreeCollision ,  simGeom.getMeshTriangleCollision ,  simGeom.getOctreeSegmentCollision \n \n \n \n \n simGeom.getMeshSegmentDistance \n \n \n Description \n Computes the minimum distance between a mesh object and a segment. \n \n \n Lua synopsis \n float distance,float[3] \nmeshMinDistPt,float[3] segmentDistSegPt,int \ncaching=simGeom.getMeshSegmentDistance(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,float[3] segmentEndPoint,float[3] \nsegmentVector,float thresholdDist=nil,int caching=-1) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n segmentEndPoint : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n meshMinDistPt : the minimum distance point on the mesh. nil if the distance is not smaller than the threshold distance. \n segmentDistSegPt : the minimum distance point on the segment. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list meshMinDistPt,list \nsegmentDistSegPt,int caching=simGeom.getMeshSegmentDistance(int \nmeshHandle,list meshPos,list meshQuat,list segmentEndPoint,list \nsegmentVector,float thresholdDist=None,int caching=-1) \n \n \n See also \n simGeom.getMeshMeshDistance ,  simGeom.getMeshOctreeDistance ,  simGeom.getMeshPtcloudDistance ,  simGeom.getMeshTriangleDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getSegmentSegmentDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getMeshSerializationData \n \n \n Description \n Retrieves the serialization data from a mesh object. \n \n \n Lua synopsis \n buffer serializationData=simGeom.getMeshSerializationData(int meshHandle) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n \n \n \n Lua return value(s) \n \n serializationData : the serialization data. \n \n \n \n Python synopsis \n bytes serializationData=simGeom.getMeshSerializationData(int meshHandle) \n \n \n See also \n simGeom.createMeshFromSerializationData \n \n \n \n \n simGeom.getMeshTriangleCollision \n \n \n Description \n Checks for collision between a mesh object and a triangle. \n \n \n Lua synopsis \n bool collisionResult,int caching,float[] \nintersections=simGeom.getMeshTriangleCollision(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,float[3] p,float[3] v,float[3] w,int \ncaching=-1,bool returnIntersections) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n caching : a values from previous collision checking\n between the same two entities, to speed-up collision checking. Can be \nomitted or set to -1. \n returnIntersections : whether the interference segments should be returned. Can be omitted. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a value that can be used to speed-up next collision checking between the same two entities. \n intersections : the interference segments. \n \n \n \n Python synopsis \n bool collisionResult,int caching,list \nintersections=simGeom.getMeshTriangleCollision(int meshHandle,list \nmeshPos,list meshQuat,list p,list v,list w,int caching=-1,bool \nreturnIntersections) \n \n \n See also \n simGeom.getMeshMeshCollision ,  simGeom.getMeshOctreeCollision ,  simGeom.getMeshSegmentCollision ,  simGeom.getOctreeTriangleCollision \n \n \n \n \n simGeom.getMeshTriangleDistance \n \n \n Description \n Computes the minimum distance between a mesh object and a triangle. \n \n \n Lua synopsis \n float distance,float[3] \nmeshMinDistPt,float[3] triangleMinDistPt,int \ncaching=simGeom.getMeshTriangleDistance(int meshHandle,float[3] \nmeshPos,float[4] meshQuat,float[3] p,float[3] v,float[3] w,float \nthresholdDist=nil,int caching=-1) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n meshPos : the position of the mesh.   meshQuat : the quaternion of the mesh. \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n meshMinDistPt : the minimum distance point on the mesh. nil if the distance is not smaller than the threshold distance. \n triangleMinDistPt : the minimum distance point on the triangle. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list meshMinDistPt,list \ntriangleMinDistPt,int caching=simGeom.getMeshTriangleDistance(int \nmeshHandle,list meshPos,list meshQuat,list p,list v,list w,float \nthresholdDist=None,int caching=-1) \n \n \n See also \n simGeom.getMeshMeshDistance ,  simGeom.getMeshOctreeDistance ,  simGeom.getMeshPtcloudDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getTriangleTriangleDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getTrianglePointDistance \n \n \n \n \n simGeom.getOctreeOctreeCollision \n \n \n Description \n Checks for collision between two OC-tree objects. \n \n \n Lua synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreeOctreeCollision(int oc1Handle,float[3] \noctree1Pos,float[4] octree1Quat,int oc2Handle,float[3] \noctree2Pos,float[4] octree2Quat,int[2] caching=nil) \n \n \n Lua arguments \n \n oc1Handle : handle of the first OC-tree object. \n octree1Pos : the position of the first OC-tree.   octree1Pos : the quaternion of the first OC-tree. \n oc2Handle : handle of the second OC-tree object. \n octree2Pos : the position of the second OC-tree.   octree2Pos : the quaternion of the second OC-tree. \n caching : a table with two values from previous \ncollision checking between the same two entities, to speed-up collision \nchecking. Can be omitted. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a table with two values that can be used to speed-up next collision checking between the same two entities. \n \n \n \n Python synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreeOctreeCollision(int oc1Handle,list \noctree1Pos,list octree1Quat,int oc2Handle,list octree2Pos,list \noctree2Quat,list caching=None) \n \n \n See also \n simGeom.getMeshOctreeCollision ,  simGeom.getOctreePtcloudCollision ,  simGeom.getOctreeTriangleCollision ,  simGeom.getOctreeSegmentCollision ,  simGeom.getOctreePointCollision \n \n \n \n \n simGeom.getOctreeOctreeDistance \n \n \n Description \n Computes the minimum distance between two OC-tree objects. \n \n \n Lua synopsis \n float distance,float[3] \noc1MinDistPt,float[3] oc2MinDistPt,int[2] \ncaching=simGeom.getOctreeOctreeDistance(int oc1Handle,float[3] \noctree1Pos,float[4] octree1Quat,int oc2Handle,float[3] \noctree2Pos,float[4] octree2Quat,float thresholdDist=nil,int[2] \ncaching=nil) \n \n \n Lua arguments \n \n oc1Handle : the handle of the first OC-tree object. \n octree1Pos : the position of the first OC-tree.   octree1Pos : the quaternion of the first OC-tree. \n oc2Handle : the handle of the second OC-tree object. \n octree2Pos : the position of the second OC-tree.   octree2Pos : the quaternion of the second OC-tree. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a table with two values from previous \ndistance calculation between the same two entities, to speed-up \ncalculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n oc1MinDistPt : the minimum distance point on the first OC-tree. nil if the distance is not smaller than the threshold distance. \n oc2MinDistPt : the minimum distance point on the second OC-tree. nil if the distance is not smaller than the threshold distance. \n caching : a table with two values that can be used \nto speed-up next distance calculation between the same two entities. nil\n if the distance is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list oc1MinDistPt,list \noc2MinDistPt,list caching=simGeom.getOctreeOctreeDistance(int \noc1Handle,list octree1Pos,list octree1Quat,int oc2Handle,list \noctree2Pos,list octree2Quat,float thresholdDist=None,list caching=None) \n \n \n See also \n simGeom.getMeshOctreeDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getOctreePointDistance \n \n \n \n \n simGeom.getOctreePointCollision \n \n \n Description \n Checks for collision between an OC-tree object and a point. \n \n \n Lua synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreePointCollision(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,float[3] point,int caching=-1) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n point : a point expressed relative to the world reference frame. \n caching : a value from previous collision checking between the same two entities, to speed-up collision checking. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a value that can be used to speed-up next collision checking between the same two entities. \n \n \n \n Python synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreePointCollision(int octreeHandle,list \noctreePos,list octreeQuat,list point,int caching=-1) \n \n \n See also \n simGeom.getMeshOctreeCollision ,  simGeom.getOctreeOctreeCollision ,  simGeom.getOctreePtcloudCollision ,  simGeom.getOctreeTriangleCollision ,  simGeom.getOctreeSegmentCollision \n \n \n \n \n simGeom.getOctreePointDistance \n \n \n Description \n Computes the minimum distance between an OC-tree object and a point. \n \n \n Lua synopsis \n float distance,float[3] ocMinDistPt,int \ncaching=simGeom.getOctreePointDistance(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,float[3] point,float thresholdDist=nil,int\n caching=-1) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n point : the position of the point. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n ocMinDistPt : the minimum distance point on the OC-tree. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list ocMinDistPt,int \ncaching=simGeom.getOctreePointDistance(int octreeHandle,list \noctreePos,list octreeQuat,list point,float thresholdDist=None,int \ncaching=-1) \n \n \n See also \n simGeom.getMeshOctreeDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreeOctreeDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getPtcloudPointDistance ,  simGeom.getBoxPointDistance ,  simGeom.getTrianglePointDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getOctreePtcloudCollision \n \n \n Description \n Checks for collision between am OC-tree object and a point-cloud object. \n \n \n Lua synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreePtcloudCollision(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,int ptcloudHandle,float[3] \nptcloudPos,float[4] ptcloudQuat,int[2] caching=nil) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n ptcloudHandle : the handle of the point-cloud object. \n ptcloudPos : the position of the point-cloud.   ptcloudQuat : the quaternion of the point-cloud. \n caching : a table with two values from previous collision checking between the same two entities, to speed-up collision checking.. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a value that can be used to speed-up next collision checking between the same two entities. \n \n \n \n Python synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreePtcloudCollision(int octreeHandle,list \noctreePos,list octreeQuat,int ptcloudHandle,list ptcloudPos,list \nptcloudQuat,list caching=None) \n \n \n See also \n simGeom.getMeshOctreeCollision ,  simGeom.getOctreeOctreeCollision ,  simGeom.getOctreeTriangleCollision ,  simGeom.getOctreeSegmentCollision ,  simGeom.getOctreePointCollision \n \n \n \n \n simGeom.getOctreePtcloudDistance \n \n \n Description \n Computes the minimum distance between an OC-tree object and a point-cloud object. \n \n \n Lua synopsis \n float distance,float[3] \nocMinDistPt,float[3] pcMinDistPt,int[2] \ncaching=simGeom.getOctreePtcloudDistance(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,int ptcloudHandle,float[3] pcPos,float[4] \npcQuat,float thresholdDist=nil,int[2] caching=nil) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n ptcloudHandle : the handle of the point-cloud object. \n pcPos : the position of the point-cloud.   pcQuat : the quaternion of the point-cloud. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a table with two values from previous \ndistance calculation between the same two entities, to speed-up \ncalculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n ocMinDistPt : the minimum distance point on the OC-tree. nil if the distance is not smaller than the threshold distance. \n pcMinDistPt : the minimum distance point on the point-cloud. nil if the distance is not smaller than the threshold distance. \n caching : a table with two values that can be used \nto speed-up next distance calculation between the same two entities. nil\n if the distance is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list ocMinDistPt,list \npcMinDistPt,list caching=simGeom.getOctreePtcloudDistance(int \noctreeHandle,list octreePos,list octreeQuat,int ptcloudHandle,list \npcPos,list pcQuat,float thresholdDist=None,list caching=None) \n \n \n See also \n simGeom.getMeshPtcloudDistance ,  simGeom.getOctreeOctreeDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudPtcloudDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getPtcloudPointDistance \n \n \n \n \n simGeom.getOctreeSegmentCollision \n \n \n Description \n Checks for collision between an OC-tree object and a segment. \n \n \n Lua synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreeSegmentCollision(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,float[3] segmentExtremity,float[3] \nsegmentVector,int caching=-1) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n segmentExtremity : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n caching : a value from previous collision checking between the same two entities, to speed-up collision checking. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a value that can be used to speed-up next collision checking between the same two entities. \n \n \n \n Python synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreeSegmentCollision(int octreeHandle,list \noctreePos,list octreeQuat,list segmentExtremity,list segmentVector,int \ncaching=-1) \n \n \n See also \n simGeom.getMeshOctreeCollision ,  simGeom.getMeshSegmentCollision ,  simGeom.getOctreeOctreeCollision ,  simGeom.getOctreePtcloudCollision ,  simGeom.getOctreeTriangleCollision ,  simGeom.getOctreePointCollision \n \n \n \n \n simGeom.getOctreeSegmentDistance \n \n \n Description \n Computes the minimum distance between an OC-tree object and a segment. \n \n \n Lua synopsis \n float distance,float[3] \nocMinDistPt,float[3] segmentDistSegPt,int \ncaching=simGeom.getOctreeSegmentDistance(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,float[3] segmentEndPoint,float[3] \nsegmentVector,float thresholdDist=nil,int caching=-1) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n segmentEndPoint : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n ocMinDistPt : the minimum distance point on the OC-tree. nil if the distance is not smaller than the threshold distance. \n segmentDistSegPt : the minimum distance point on the segment. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list ocMinDistPt,list \nsegmentDistSegPt,int caching=simGeom.getOctreeSegmentDistance(int \noctreeHandle,list octreePos,list octreeQuat,list segmentEndPoint,list \nsegmentVector,float thresholdDist=None,int caching=-1) \n \n \n See also \n simGeom.getMeshOctreeDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getOctreeOctreeDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getSegmentSegmentDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getOctreeSerializationData \n \n \n Description \n Retrieves the serialization data from an OC-tree object. \n \n \n Lua synopsis \n buffer serializationData=simGeom.getOctreeSerializationData(int octreeHandle) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n \n \n \n Lua return value(s) \n \n serializationData : the serialization data. \n \n \n \n Python synopsis \n bytes serializationData=simGeom.getOctreeSerializationData(int octreeHandle) \n \n \n See also \n simGeom.createOctreeFromSerializationData \n \n \n \n \n simGeom.getOctreeTriangleCollision \n \n \n Description \n Checks for collision between an OC-tree object and a triangle. \n \n \n Lua synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreeTriangleCollision(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,float[3] p,float[3] v,float[3] w,int \ncaching=-1) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n caching : a value from previous collision checking between the same two entities, to speed-up collision checking. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n collisionResult : the collision status. \n caching : a value that can be used to speed-up next collision checking between the same two entities. \n \n \n \n Python synopsis \n bool collisionResult,int \ncaching=simGeom.getOctreeTriangleCollision(int octreeHandle,list \noctreePos,list octreeQuat,list p,list v,list w,int caching=-1) \n \n \n See also \n simGeom.getMeshOctreeCollision ,  simGeom.getMeshTriangleCollision ,  simGeom.getOctreeOctreeCollision ,  simGeom.getOctreePtcloudCollision ,  simGeom.getOctreeSegmentCollision ,  simGeom.getOctreePointCollision \n \n \n \n \n simGeom.getOctreeTriangleDistance \n \n \n Description \n Computes the minimum distance between an OC-tree object and a triangle. \n \n \n Lua synopsis \n float distance,float[3] \nocMinDistPt,float[3] triangleMinDistPt,int \ncaching=simGeom.getOctreeTriangleDistance(int octreeHandle,float[3] \noctreePos,float[4] octreeQuat,float[3] p,float[3] v,float[3] w,float \nthresholdDist=nil,int caching=-1) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n octreePos : the position of the OC-tree.   octreeQuat : the quaternion of the OC-tree. \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted or -1. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n ocMinDistPt : the minimum distance point on the OC-tree. nil if the distance is not smaller than the threshold distance. \n triangleMinDistPt : the minimum distance point on the triangle. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list ocMinDistPt,list \ntriangleMinDistPt,int caching=simGeom.getOctreeTriangleDistance(int \noctreeHandle,list octreePos,list octreeQuat,list p,list v,list w,float \nthresholdDist=None,int caching=-1) \n \n \n See also \n simGeom.getMeshOctreeDistance ,  simGeom.getMeshTriangleDistance ,  simGeom.getOctreeOctreeDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getTriangleTriangleDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getTrianglePointDistance \n \n \n \n \n simGeom.getOctreeVoxels \n \n \n Description \n Retrieves voxel data from an OC-tree. \n \n \n Lua synopsis \n float[] posData,int[] colorData,int[] userData=simGeom.getOctreeVoxels(int octreeHandle) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n \n \n \n Lua return value(s) \n \n posData : position data: for each voxel, there are 3 position values (XYZ). \n colorData : color data: for each voxel, there are 3 color values (RGB, 0-1). \n userData : user data: for each voxel, there is one user data value. \n \n \n \n Python synopsis \n list posData,list colorData,list userData=simGeom.getOctreeVoxels(int octreeHandle) \n \n \n See also \n \n \n \n \n \n simGeom.getPtcloudPointDistance \n \n \n Description \n Computes the minimum distance between a point-cloud object and a point. \n \n \n Lua synopsis \n float distance,float[3] pcMinDistPt,int \ncaching=simGeom.getPtcloudPointDistance(int ptcloudHandle,float[3] \npcPos,float[4] pcQuat,float[3] point,float thresholdDist=nil,int \ncaching=-1) \n \n \n Lua arguments \n \n ptcloudHandle : the handle of the point-cloud object. \n pcPos : the position of the point-cloud.   pcQuat : the quaternion of the point-cloud. \n point : the position of the point. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n pcMinDistPt : the minimum distance point on the point-cloud. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list pcMinDistPt,int \ncaching=simGeom.getPtcloudPointDistance(int ptcloudHandle,list \npcPos,list pcQuat,list point,float thresholdDist=None,int caching=-1) \n \n \n See also \n simGeom.getMeshPtcloudDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudPtcloudDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getBoxPointDistance ,  simGeom.getTrianglePointDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getPtcloudPoints \n \n \n Description \n Retrieves point data from a point-cloud. \n \n \n Lua synopsis \n float[] posData,int[] colorData=simGeom.getPtcloudPoints(int ptcloudHandle,float prop=1) \n \n \n Lua arguments \n \n ptcloudHandle : the handle of the point-cloud object. \n prop : the proportion of data to retrieve, on a voxel-basis. 1 retrieves all data, 0.25 retrieves 25% of the data. \n \n \n \n Lua return value(s) \n \n posData : the position data: for each point, there are 3 position values (XYZ). \n colorData : the color data: for each point, there are 3 color values (RGB, 0-1). \n \n \n \n Python synopsis \n list posData,list colorData=simGeom.getPtcloudPoints(int ptcloudHandle,float prop=1) \n \n \n See also \n \n \n \n \n \n simGeom.getPtcloudPtcloudDistance \n \n \n Description \n Computes the minimum distance between two point-cloud objects. \n \n \n Lua synopsis \n float distance,float[3] \npc1MinDistPt,float[3] pc2MinDistPt,int[2] \ncaching=simGeom.getPtcloudPtcloudDistance(int pc1Handle,float[3] \npc1pos,float[4] pc1Quat,int pc2Handle,float[3] pc2Pos,float[4] \npc2Quat,float distanceThreshold=nil,int[2] caching) \n \n \n Lua arguments \n \n pc1Handle : the handle of the first point-cloud object. \n pc1Pos : the position of the first point-cloud. \n pc1Quat : the quaternion of the first point-cloud. \n pc2Handle : the handle of the second point-cloud object. \n pc2Pos : the position of the second point-cloud. \n pc2Quat : the quaternion of the second point-cloud. \n distanceThreshold : the distance threshold. Can be omitted. \n caching : a table with two values from previous \ndistance calculation between the same two entities, to speed-up \ncalculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n pc1MinDistPt : the minimum distance point on the first point-cloud. nil if the distance is not smaller than the threshold distance. \n pc2MinDistPt : the minimum distance point on the second point-cloud. nil if the distance is not smaller than the threshold distance. \n caching : a table with two values that can be used \nto speed-up next distance calculation between the same two entities. nil\n if the distance is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list pc1MinDistPt,list \npc2MinDistPt,list caching=simGeom.getPtcloudPtcloudDistance(int \npc1Handle,list pc1pos,list pc1Quat,int pc2Handle,list pc2Pos,list \npc2Quat,float distanceThreshold=None,list caching) \n \n \n See also \n simGeom.getMeshPtcloudDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getPtcloudPointDistance \n \n \n \n \n simGeom.getPtcloudSegmentDistance \n \n \n Description \n Computes the minimum distance between a point-cloud and a segment. \n \n \n Lua synopsis \n float distance,float[3] \npcMinDistPt,float[3] segmentDistSegPt,int \ncaching=simGeom.getPtcloudSegmentDistance(int ptcloudHandle,float[3] \npcPos,float[4] pcQuat,float[3] segmentEndPoint,float[3] \nsegmentVector,float thresholdDist=nil,int caching=-1) \n \n \n Lua arguments \n \n ptcloudHandle : the handle of the point-cloud object. \n pcPos : the position of the point-cloud.   pcQuat : the quaternion of the point-cloud. \n segmentEndPoint : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n pcMinDistPt : the minimum distance point on the point-cloud. nil if the distance is not smaller than the threshold distance. \n segmentDistSegPt : the minimum distance point on the segment. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list pcMinDistPt,list \nsegmentDistSegPt,int caching=simGeom.getPtcloudSegmentDistance(int \nptcloudHandle,list pcPos,list pcQuat,list segmentEndPoint,list \nsegmentVector,float thresholdDist=None,int caching=-1) \n \n \n See also \n simGeom.getMeshPtcloudDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getPtcloudPtcloudDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getPtcloudPointDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getSegmentSegmentDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getPtcloudSerializationData \n \n \n Description \n Retrieves the serialization data from a point-cloud object. \n \n \n Lua synopsis \n buffer serializationData=simGeom.getPtcloudSerializationData(int ptcloudHandle) \n \n \n Lua arguments \n \n ptcloudHandle : the handle of the point-cloud object. \n \n \n \n Lua return value(s) \n \n serializationData : the serialization data. \n \n \n \n Python synopsis \n bytes serializationData=simGeom.getPtcloudSerializationData(int ptcloudHandle) \n \n \n See also \n simGeom.createPtcloudFromSerializationData \n \n \n \n \n simGeom.getPtcloudTriangleDistance \n \n \n Description \n Computes the minimum distance between a point-cloud object and a triangle. \n \n \n Lua synopsis \n float distance,float[3] \npcMinDistPt,float[3] triangleMinDistPt,int \ncaching=simGeom.getPtcloudTriangleDistance(int ptcloudHandle,float[3] \npcPos,float[4] pcQuat,float[3] p,float[3] v,float[3] w,float \nthresholdDist=nil,int caching=nil) \n \n \n Lua arguments \n \n ptcloudHandle : the handle of the point-cloud object. \n pcPos : the position of the point-cloud.   pcQuat : the quaternion of the point-cloud. \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n thresholdDist : the distance threshold. Can be omitted. \n caching : a value from previous distance calculation between the same two entities, to speed-up calculations. Can be omitted. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities, or if it is not smaller than the threshold distance, the threshold distance. \n pcMinDistPt : the minimum distance point on the point-cloud. nil if the distance is not smaller than the threshold distance. \n triangleMinDistPt : the minimum distance point on the triangle. nil if the distance is not smaller than the threshold distance. \n caching : a value that can be used to speed-up next\n distance calculation between the same two entities. nil if the distance\n is not smaller than the threshold distance. \n \n \n \n Python synopsis \n float distance,list pcMinDistPt,list \ntriangleMinDistPt,int caching=simGeom.getPtcloudTriangleDistance(int \nptcloudHandle,list pcPos,list pcQuat,list p,list v,list w,float \nthresholdDist=None,int caching=None) \n \n \n See also \n simGeom.getMeshPtcloudDistance ,  simGeom.getOctreePtcloudDistance ,  simGeom.getPtcloudPtcloudDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getPtcloudPointDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getTriangleTriangleDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getTrianglePointDistance \n \n \n \n \n simGeom.getSegmentPointDistance \n \n \n Description \n Computes the minimum distance between a segment and a point. \n \n \n Lua synopsis \n float distance,float[3] \nsegmentDistSegPt=simGeom.getSegmentPointDistance(float[3] \nsegmentEndPoint,float[3] segmentVector,float[3] point) \n \n \n Lua arguments \n \n segmentEndPoint : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n point : position of the point \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n segmentDistSegPt : the minimum distance point on the segment. \n \n \n \n Python synopsis \n float distance,list segmentDistSegPt=simGeom.getSegmentPointDistance(list segmentEndPoint,list segmentVector,list point) \n \n \n See also \n simGeom.getMeshSegmentDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getPtcloudPointDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getBoxPointDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getTrianglePointDistance ,  simGeom.getSegmentSegmentDistance \n \n \n \n \n simGeom.getSegmentSegmentDistance \n \n \n Description \n Computes the minimum distance between two segments. \n \n \n Lua synopsis \n float distance,float[3] \nsegment1DistSegPt,float[3] \nsegment2DistSegPt=simGeom.getSegmentSegmentDistance(float[3] \nsegment1EndPoint,float[3] segment1Vector,float[3] \nsegment2EndPoint,float[3] segment2Vector) \n \n \n Lua arguments \n \n segment1EndPoint : position of point A on the first segment \n segment1Vector : vector stretching from point A to point B on the first segment. \n segment2EndPoint : position of point A on the second segment \n segment2Vector : vector stretching from point A to point B on the second segment. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n segment1DistSegPt : the minimum distance point on the first segment. \n segment2DistSegPt : the minimum distance point on the second segment. \n \n \n \n Python synopsis \n float distance,list segment1DistSegPt,list\n segment2DistSegPt=simGeom.getSegmentSegmentDistance(list \nsegment1EndPoint,list segment1Vector,list segment2EndPoint,list \nsegment2Vector) \n \n \n See also \n simGeom.getMeshSegmentDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getTransformedPoints \n \n \n Description \n Transforms points via a transformation matrix, or via a position and a quaternion or Euler angles. \n \n \n Lua synopsis \n \n 1) float[] transformedPoints=simGeom.getTransformedPoints(float[] points,float[12] transformationMatrix) \n 2) float[] transformedPoints=simGeom.getTransformedPoints(float[] points,float[3] pos,float[4] quaternion) \n 2) float[] transformedPoints=simGeom.getTransformedPoints(float[] points,float[3] pos,float[3] eulerAngles) \n \n \n \n Lua arguments \n \n points : the points to transform. \n transformationMatrix : a transformation matrix: 12 \nvalues (the last row of the 4x4 matrix (0,0,0,1) is not needed). The \nx-axis of the orientation component is (matrix[1],matrix[5],matrix[9]), \nthe y-axis of the orientation component is \n(matrix[2],matrix[6],matrix[10]), the z-axis of the orientation \ncomponent is (matrix[3],matrix[7],matrix[11]), and the translation \ncomponent is (matrix[4],matrix[8],matrix[12]). \n pos : a position. \n quaternion : a quaternion. \n eulerAngles : Euler angles. \n \n \n \n Lua return value(s) \n \n transformedPoints : the transformed points. \n \n \n \n Python synopsis \n \n 1) list transformedPoints=simGeom.getTransformedPoints(list points,list transformationMatrix) \n 2) list transformedPoints=simGeom.getTransformedPoints(list points,list pos,list quaternion) \n 2) list transformedPoints=simGeom.getTransformedPoints(list points,list pos,list eulerAngles) \n \n \n \n See also \n \n \n \n \n \n \n simGeom.getTrianglePointDistance \n \n \n Description \n Computes the minimum distance between a triangle and a point. \n \n \n Lua synopsis \n float distance,float[3] triangleDistSegPt=simGeom.getTrianglePointDistance(float[3] p,float[3] v,float[3] w,float[3] point) \n \n \n Lua arguments \n \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n point : position of the point \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n triangleDistSegPt : the minimum distance point on the triangle. \n \n \n \n Python synopsis \n float distance,list triangleDistSegPt=simGeom.getTrianglePointDistance(list p,list v,list w,list point) \n \n \n See also \n simGeom.getMeshTriangleDistance ,  simGeom.getMeshPointDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getOctreePointDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getPtcloudPointDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getBoxPointDistance ,  simGeom.getTriangleTriangleDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getTriangleSegmentDistance \n \n \n Description \n Computes the minimum distance between a triangle and a segment. \n \n \n Lua synopsis \n float distance,float[3] \ntriangleDistSegPt,float[3] \nsegmentDistSegPt=simGeom.getTriangleSegmentDistance(float[3] p,float[3] \nv,float[3] w,float[3] segmentEndPoint,float[3] segmentVector) \n \n \n Lua arguments \n \n p : position of vertex A on the triangle. \n v : vector stretching from vertex A to vertex B on the triangle. \n w : vector stretching from vertex A to vertex C on the triangle. \n segmentEndPoint : position of vertex A on the segment. \n segmentVector : vector stretching from vertex A to vertex B on the segment. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n triangleDistSegPt : the minimum distance point on the triangle. \n segmentDistSegPt : the minimum distance point on the segment. \n \n \n \n Python synopsis \n float distance,list triangleDistSegPt,list\n segmentDistSegPt=simGeom.getTriangleSegmentDistance(list p,list v,list \nw,list segmentEndPoint,list segmentVector) \n \n \n See also \n simGeom.getMeshTriangleDistance ,  simGeom.getMeshSegmentDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getOctreeSegmentDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getPtcloudSegmentDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getBoxSegmentDistance ,  simGeom.getTriangleTriangleDistance ,  simGeom.getTrianglePointDistance ,  simGeom.getSegmentSegmentDistance ,  simGeom.getSegmentPointDistance \n \n \n \n \n simGeom.getTriangleTriangleDistance \n \n \n Description \n Computes the minimum distance between two triangles. \n \n \n Lua synopsis \n float distance,float[3] \ndistSegPt1,float[3] \ndistSegPt2=simGeom.getTriangleTriangleDistance(float[3] p1,float[3] \nv1,float[3] w1,float[3] p2,float[3] v2,float[3] w2) \n \n \n Lua arguments \n \n p1 : position of point A on triangle 1. \n v1 : vector stretching from point A to point B on triangle 1. \n w1 : vector stretching from point A to point C on triangle 1. \n p2 : position of point A on triangle 2. \n v2 : vector stretching from point A to point B on triangle 2. \n w2 : vector stretching from point A to point C on triangle 2. \n \n \n \n Lua return value(s) \n \n distance : the minimum distance between the two entities. \n triangle1DistSegPt : the minimum distance point on the first triangle. \n triangle2DistSegPt : the minimum distance point on the second triangle. \n \n \n \n Python synopsis \n float distance,list distSegPt1,list \ndistSegPt2=simGeom.getTriangleTriangleDistance(list p1,list v1,list \nw1,list p2,list v2,list w2) \n \n \n See also \n simGeom.getMeshTriangleDistance ,  simGeom.getOctreeTriangleDistance ,  simGeom.getPtcloudTriangleDistance ,  simGeom.getBoxTriangleDistance ,  simGeom.getTriangleSegmentDistance ,  simGeom.getTrianglePointDistance \n \n \n \n \n simGeom.scaleMesh \n \n \n Description \n Scales a mesh object. \n \n \n Lua synopsis \n simGeom.scaleMesh(int meshHandle,float scalingFactor) \n \n \n Lua arguments \n \n meshHandle : the handle of the mesh object. \n scalingFactor : the scaling factor. \n \n \n \n Lua return value(s) \n \n \n \n Python synopsis \n simGeom.scaleMesh(int meshHandle,float scalingFactor) \n \n \n See also \n \n \n \n \n \n simGeom.scaleOctree \n \n \n Description \n Scales an OC-tree object. \n \n \n Lua synopsis \n  simGeom.scaleOctree(int octreeHandle,float scalingFactor) \n \n \n Lua arguments \n \n octreeHandle : the handle of the OC-tree object. \n scalingFactor : the scaling factor. \n \n \n \n Lua return value(s) \n \n \n \n Python synopsis \n  simGeom.scaleOctree(int octreeHandle,float scalingFactor) \n \n \n See also \n \n \n \n \n \n simGeom.scalePtcloud \n \n \n Description \n Scales a point-cloud object. \n \n \n Lua synopsis \n simGeom.scalePtcloud(int ptcloudHandle,float scalingFactor) \n \n \n Lua arguments \n \n ptcloudHandle : the handle of the point-cloud object. \n scalingFactor : the scaling factor. \n \n \n \n Lua return value(s) \n \n \n \n Python synopsis \n simGeom.scalePtcloud(int ptcloudHandle,float scalingFactor) \n \n \n See also \n \n \n \n \n \n , ', 'tags': '', 'url': 'simGeom API.html'}, {'title': 'coppeliaGeometricRoutines', 'text': '\n \n \n \n \n Coppelia Geometric Routines \n The  Coppelia Geometric Routines  is a collection of C++ functions that allow to perform the same geometric calculations as you are able to do from within CoppeliaSim (i.e.  collision detection ,  minimum distance calculation , and  proximity sensor  simulation on  meshes ,  oc-trees  and  point clouds ). Those functions give CoppeliaSim its geometric calculation capability. \n You can embedd and use the Coppelia Geometric Routines in your stand-alone application, which then can programmatically set up complex calculation tasks. Refer also to the  Coppelia Geometric Routines C++ API documentation . \n The Coppelia Geometric Routines source code is not directly part of CoppeliaSim, and carries separate licensing conditions. Refer to the source code for details, and  contact us . \n Following very simple example illustrates how to measure the smallest distance between two meshes: \n \n#include "geom.h"\n\nint main(int argc, char* argv[])\n{\n    // Create mesh 1 (containing a single triangle, for simplicity):\n    std::vector<simReal> vertices1{0.0,0.0,0.0,\n                                   0.5,0.5,0.0,\n                                   0.5,0.0,0.5};\n    std::vector<int> indices1{0,1,2};\n    CObbStruct* mesh1=geom_createMesh(&vertices1[0],vertices1.size(),&indices1[0],indices1.size());\n\n    // Create mesh 2 (containing a single triangle, for simplicity):\n    std::vector<simReal> vertices2{0.5,0.0,0.0,\n                                   0.0,0.5,0.5,\n                                   0.0,0.0,0.5};\n    std::vector<int> indices2{0,1,2};\n    CObbStruct* mesh2=geom_createMesh(&vertices2[0],vertices2.size(),&indices2[0],indices2.size());\n\n    // now move and rotate the two meshes and compute their minimum distance:\n    simReal t=0.0;\n    while (true)\n    {\n        t+=0.001;\n        C7Vector mesh1Transformation;\n        mesh1Transformation.X=C3Vector(0.5*cos(0.1*t),0.0,0.0); // sinusoidal x-axis movement\n        mesh1Transformation.Q.setIdentity();\n        C7Vector mesh2Transformation;\n        mesh2Transformation.X=C3Vector(0.0,0.4*cos(0.2*t),0.3*cos(0.1*t)); // sinusoidal y- and z-axis movement\n        C3Vector eulerAngles(0.0,0.0,t*1.2); // rotation around vertical axis\n        mesh2Transformation.Q.setEulerAngles(eulerAngles);\n\n        // compute the distance:\n        simReal dist=REAL_MAX;\n        geom_getMeshMeshDistanceIfSmaller(mesh1,mesh1Transformation,mesh2,mesh2Transformation,dist);\n \n        printf("mesh-mesh minimum distance: %f\\n",dist);\n    }\n    return(0);\n} \n \n \n \n \n', 'tags': '', 'url': 'coppeliaGeometricRoutines.html'}, {'title': 'CoppeliaGeometricRoutinesAPI', 'text': 'Please follow  this link .', 'tags': '', 'url': 'CoppeliaGeometricRoutinesAPI.html'}, {'title': 'IGLPluginAPIreference', 'text': '\n IGL Plugin API reference \n Wrapper for libigl \n simIGL.boolean \n \n \n \n simIGL.boolean\n \n \n \n                                                    Description\n                                                 \n Compute several boolean operations on the meshes specified by vertices and (triangle) indices \n \n \n Lua synopsis \n mesh result=simIGL.boolean(mesh a, mesh b, int op) \n \n \n \n Lua parameters \n \n \n a  (mesh): first mesh \n \n b  (mesh): second mesh \n \n op  (int): operation, see  simIGL.boolean_op \n \n \n \n \n Lua return values \n \n result  (mesh): resulting mesh \n \n \n Python synopsis \n mesh result=simIGL.boolean(mesh a, mesh b, int op) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simIGL.boolean_op\n \n union \n intersection \n difference \n symmetric_difference \n resolve \n \n \n \n Data structures \n Data structures are used to pass complex data around. Create data structures in Lua in the form of a map, e.g.:  {line_size=3, add_to_legend=false, selectable=true} \n \n mesh\n \n \n \n                                                Description\n                                             \n \n \n \n Fields \n \n \n vertices  (table of float): vertices of the mesh (3 * n values) \n \n indices  (table of int): triangle indices of the mesh (3 * m indices, zero-based) \n \n normals  (table of float): per-vertex normals (3 * n values) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'IGLPluginAPIreference.html'}, {'title': 'kinematics', 'text': "\n \n \n \n \n Kinematics \n CoppeliaSim's kinematics  functionality is very powerful, flexible and allows handling virtually any type of mechanism in inverse kinematics mode (IK mode) or forward kinematics mode (FK mode). It is operated via the  Coppelia Kinematics Routines  (a collection of c++ functions that can be embedded into stand-alone applications), wrapped into the  kinematics plugin . \n The problem of IK can be seen as the one of finding the joint values corresponding to some specific position and/or orientation of a given body element (generally the end effector). More generally, it is a transformation from the task space coordinates into the joint space coordinates. For a serial manipulator for instance, the problem would be to find the value of all  joints  in the manipulator given the position (and/or orientation) of the end effector. The inverse problem - finding the end effector position and/or orientation given the joint values - is referred to as FK problem and is often perceived as an easier task than IK. This is surely true when dealing with open kinematic chains, but does not hold true for general type mechanical configurations as following one for instance:\n \n \n [Non-trivial FK problem: knowing the joint values indicated by the arrows, the end effector position and orientation is sought] \n \n The kinematics functionality is available via the  kinematics plugin : it allows setting up complex kinematics tasks in a separate IK environment, for nice isolation from the other aspects a simulation model might be involved with (e.g. dynamics, etc.) \n IK groups  containing  IK elements  are used to handle IK and FK tasks within CoppeliaSim: \n Basics on IK groups and IK elements \n Solving IK and FK for any type of mechanism \n Also make sure to have a look at the  inverse kinematics tutorial , and the various example scenes in folder  scenes/kinematics . \n \n \n \n \n", 'tags': '', 'url': 'kinematics.html'}, {'title': 'basicsOnIkGroupsAndIkElements', 'text': "\n \n \n \n \n Basics on IK groups and IK elements \n CoppeliaSim uses  IK groups  and  IK elements  to solve inverse and forward kinematics tasks. It is important to understand how an IK task is solved in order to take full advantage of the kinematics functionality in CoppeliaSim. Make sure to have a look at the various example scenes related to IK and FK in folder  scenes/kinematics .  \n An IK task is defined by an IK group, which contains one or more IK elements: \n \n IK group : an IK group contains one or more IK elements. To solve the kinematics of a simple kinematic chain, one IK group containing one IK element is needed. The IK group defines the overall solving properties (such as the  solver, the number of iterations, etc.).  \n \n IK element : an IK element represents a simple kinematic chain, which is a linkage containing at least one joint in IK mode. The chain is specified by a  tip, indicating the end-effector (usually the last object in the chain), and a base, indicating the base object (or first object) in the chain, and a target for the tip to follow. In short, an IK element is made up by: \n \n a  base , which represents the start of the kinematic chain. \n \n several  links  (any type of object except joints in IK mode). Joints which are not in  IK mode  are however also considered as links (in that case they behave as rigid joints (joints with a fixed linear/angular position)).  \n \n several  joints . which need to be in IK mode, otherwise they are considered as links (see above). \n a  tip . The tip is usually the last object in the considered kinematic chain (when going from the base to the tip), and is often the end-effector. The tip object should be linked to a target object (see hereafter). \n \n a  target . The target represents the position and/or orientation the tip should adopt (or follow) when solving for IK. The target object should be linked to a tip object (see hereabove). \n \n Following figures show two kinematic chains as they are described via IK elements. The two IK elements perceive the two chains in a similar way (the very first joint of the second example is ignored by the IK element): \n \n \n [Two kinematic chains, each describing an IK element] \n \n The goal of an IK element  (i.e. resolution of an IK element) is to have the target followed by the tip (i.e. having tip and target overlap, given certain constraints), by computing the appropriate joint values for the kinematic chain: \n \n \n [IK element and corresponding model of the IK solving task] \n \n In above example (in 2D for simplicity), we can specify various constraints for the tip-target pair, e.g.: \n   X positional constraint : the tip would follow the target only on the X-axis, and the kinematic chain would appear redundant for this task since the chain itself has 3 Degrees of Freedom (DoFs). \n   X/Y positional constraints : the tip would follow the target only in position, and the kinematic chain would still appear redundant for this task. \n   X/Y positional + Θ orientational constraints : the tip would follow the target in position and orientation, and the kinematic chain would not appear as redundant anymore for this task. \n Note that even for the most basic IK task, an IK element is solved via the resolution of the encompassing  IK group. \n Two separate kinematic chains are handled in an identical fashion, however this time, two IK groups are needed (and each one of them should contain one IK element for each kinematic chain). Solving order of the two IK groups is usually not important: \n \n \n [Two separate IK chains and corresponding model of the IK solving tasks] \n \n In above example, should  target2  be attached to a mobile part of the first kinematic chain, then the solving order becomes important and the  IK group1   should be solved first  (solving result will displace  target2  as can be seen from following figure): \n \n \n [Two separate IK chains, where the target of the second chain is attached to the first chain, and corresponding model of the IK solving tasks] \n \n A similar case can appear when one IK element is built on top of another IK element,  without  sharing any common joint as can be seen from following figure: the first kinematic chain is indicated in black, the second in light blue.  Base2 , indicated in purple, is the common object between the two chains. Solving   IK element2  won't displace the purple link, however solving  IK element1  will displace it. For that reason   IK group1  has to be solved before  IK group2  as in above case (solving order is important): \n \n \n [Two IK chains sharing one common link but no common joints and corresponding model of the IK solving tasks] \n \n A more difficult case appears when two or more kinematic chains share common joints. In that case sequential solving doesn't work most of the time (in following example, the two IK elements tend to rotate the common joint into opposite directions) and a simultaneous solving method is needed. To simultaneously solve several IK elements, just group them into one common IK group. This case is illustrated in following figure: \n \n \n [Two IK chains sharing one common joint and corresponding model of the IK solving task] \n \n \n \n \n", 'tags': '', 'url': 'basicsOnIkGroupsAndIkElements.html'}, {'title': 'solvingIkAndFk', 'text': "\n \n \n \n \n Solving IK and FK for any type of mechanism \n The Inverse Kinematics (IK) or Forward Kinematics (FK) are solved for a mechanism by using IK Groups and IK Elements (see the section on  basics on IK groups and IK elements ). Keep following points in mind in order to successfully set up IK or FK calculations: \n \n Specify individual kinematic chains by providing a base and a tip.\n \n Specify a target to follow. \n \n Group IK elements in a single IK Group if they share common joints.  \n Sort individual IK Groups in order to obtain the wanted behavior.\n \n Verify that joints in a kinematic chain have the correct properties enabled or disabled. \n \n Verify that individual IK Elements are not overconstrained. If this cannot be avoided, then select a damped resolution method. \n \n The last point is quite important to understand: a kinematic chain's tip that has all constraints turned on, will follow its associated target in the x-, y-, z-directions, while trying to keep the same orientation as the target. This however only works well when the kinematic chain has at least 6 non-redundant Degrees of Freedom (DoFs). The tip should always be appropriately constrained (i.e. never indicate more constraints than there are DoFs in the mechanism). Positional constraints are most of the time specified relative to the base's orientation as can be seen from following figure: \n \n \n [Positional constraints for a kinematic chain] \n \n Sometimes it is however not possible to correctly specify the constraints for a tip, and in that case the IK group's calculation method should be a damped method (e.g. the damped least squares method) with an appropriately selected damping factor. A damped resolution method should also be selected when a target can't possibly be reached (out of reach, or close to a singular configuration). Damping can result in more stable calculations, but keep in mind that damping will always slow down calculations (more iterations will be needed to bring the tip into place). \n \n Turning Alpha-Beta constraint on, will match the tip's z-axis orientation with the target's z-axis orientation, while keeping a free rotation around the z-axis if Gamma constraint is off. When Alpha-Beta constraint AND Gamma constraint are turned on, then the tip will try to adopt exactly the same orientation as its  target. \n \n Solving the IK problem for simple kinematic chains is explained in the section on  basics on IK groups and IK elements . Solving the FK problem of simple kinematic chains is trivial (just apply the desired joint values to all joints in the chain to obtain the position and orientation of the tip or end effector). It is less trivial to solve the IK and FK problem for closed mechanisms. \n \n \n \n Solving IK and FK for closed mechanisms\n \n In following section, two general examples are discussed that should allow the user to understand the approach to solving general type closed mechanisms: \n \n In the case of an FK problem, identify first the joints that you want to control (i.e. the joints that are driving the mechanism, the active joints). Those joints should be excluded from all kinematic calculation (select a joint mode different from  inverse kinematics mode ). Those joints will be considered as rigid by the kinematic calculations from now on. Then, identify which kinematic chain needs to be closed. Closing will be handled by loop closure constraints in the form of tip-target pairs as shown in following figure: \n \n \n [Forward Kinematics solving method for closed mechanisms] \n \n Then, set the desired joint values for the active joints and call the inverse kinematics functionality to handle loop closure constraints. \n \n Following example shows some additional functionality that can be used to solve complicated kinematic problems: \n \n \n [Inverse kinematics task] \n \n As can be seen from the figure, there is one IK task desired by the user: bring the tip onto the target (or have the tip follow the target). This can be solved in the regular way, or the user can make usage of the joint dependency functionality. Following figure demonstrates this: \n \n \n [Inverse kinematics task with joint overlap constraints] \n \n The IK main task is in charge of reaching the target, the loop closure constraint is in charge of closing the mechanism, and the joint overlap constraints are in charge of keeping the base of the mechanism overlapped (as one single chain). The parameters of the joint dependency linear equation  have to be carefully chosen in order to reach a perfect overlap (e.g. if two corresponding joints (the ones linked through the overlap constraint) have the same orientation, then the coefficient in the equation needs to be set to -1 (since one joint is built bottom-up and the other one is built top-down)). \n \n Most of the time there are several different ways of solving the IK or FK of a mechanism, and it is always worth considering various alternatives before implementing the most complicated one.  \n \n \n \n \n \n", 'tags': '', 'url': 'solvingIkAndFk.html'}, {'title': 'kinematicsPlugin', 'text': "\n \n \n \n \n Kinematics Plugin \n The kinematics plugin for CoppeliaSim ( simExtIK.dll  or similar) wraps the  Coppelia Kinematics Routines . It exports  several API functions  that can be recognized from their simIK-prefix; they allow to create, handle and solve forward/inverse kinematics tasks for any type of mechanism (redundant/non-redundant, containing nested loops, etc.) fully programmatically. \n Kinematics tasks can very easily be set up from the scene's content like in following example: \n \n-- set-up:\nfunction sysCall_init()\n    simBase=sim.getObject('/base')\n    simTip=sim.getObject('/tip')\n    simTarget=sim.getObject('/target')\n    ikEnv=simIK.createEnvironment()\n    ikGroup=simIK.createIkGroup(ikEnv)\n    local ikElement=simIK.addIkElementFromScene(ikEnv,ikGroup,simBase,simTip,simTarget,desiredConstraints)\nend\n\n-- IK calculation, and application to the scene:\nfunction sysCall_actuation()\n    simIK.applyIkEnvironmentToScene(ikEnv,ikGroup)\nend \n simIK.addIkElementFromScene  will parse the scene given a base, tip and target object, and generate an IK element appropriately, with the given constraints.  simIK.applyIkEnvironmentToScene  on the other hand will compute IK, then apply the calculation results to the corresponding scene joints. One can of course also manually build the kinematic environment, for full control, as in following example: \n \n-- set-up:\nfunction sysCall_init()\n    simJoints={sim.getObject('/j1'),sim.getObject('/j2')}\n    ikJoints={}\n    ikBase=simIK.createDummy(ikEnv) -- create a dummy in the IK environemnt\n    -- set that dummy into the same pose as its CoppeliaSim counterpart:\n    simIK.setObjectMatrix(ikEnv,ikBase,-1,sim.getObjectMatrix(simBase,-1)) \n    local parent=ikBase\n    for i=1,#simJoints,1 do -- loop through all joints\n        -- create a joint in the IK environment:\n        ikJoints[i]=simIK.createJoint(ikEnv,simIK.jointtype_revolute)\n       -- set it into IK mode: \n        simIK.setJointMode(ikEnv,ikJoints[i],simIK.jointmode_ik) \n        -- set the same joint limits as its CoppeliaSim counterpart joint:\n        local cyclic,interv=sim.getJointInterval(simJoints[i])\n        simIK.setJointInterval(ikEnv,ikJoints[i],cyclic,interv)\n        -- set the same lin./ang. joint position as its CoppeliaSim counterpart joint: \n        simIK.setJointPosition(ikEnv,ikJoints[i],sim.getJointPosition(simJoints[i]))\n        -- set the same object pose as its CoppeliaSim counterpart joint: \n        simIK.setObjectMatrix(ikEnv,ikJoints[i],-1,sim.getObjectMatrix(simJoints[i],-1)) \n        simIK.setObjectParent(ikEnv,ikJoints[i],parent) -- set its corresponding parent\n        parent=ikJoints[i]\n    end\n    ikTip=simIK.createDummy(ikEnv) -- create the tip dummy in the IK environment\n    -- set that dummy into the same pose as its CoppeliaSim counterpart:\n    simIK.setObjectMatrix(ikEnv,ikTip,-1,sim.getObjectMatrix(simTip,-1)) \n    simIK.setObjectParent(ikEnv,ikTip,parent) -- attach it to the kinematic chain\n    ikTarget=simIK.createDummy(ikEnv) -- create the target dummy in the IK environment\n    -- set that dummy into the same pose as its CoppeliaSim counterpart:\n    simIK.setObjectMatrix(ikEnv,ikTarget,-1,sim.getObjectMatrix(simTip,-1)) \n    simIK.setLinkedDummy(ikEnv,ikTip,ikTarget) -- link the two dummies\n    ikGroup=simIK.createIkGroup(ikEnv) -- create an IK group\n    -- set its resolution method to undamped:\n    simIK.setIkGroupCalculation(ikEnv,ikGroup,simIK.method_pseudo_inverse,0,3)\n    -- add an IK element to that IK group: \n    local ikElement=simIK.addIkElement(ikEnv,ikGroup,ikTip)\n    -- specify the base of that IK element: \n    simIK.setIkElementBase(ikEnv,ikGroup,ikElement,ikBase)\n    -- specify the constraints of that IK element: \n    simIK.setIkElementConstraints(ikEnv,ikGroup,ikElement,simIK.constraint_x+simIK.constraint_y) \nend\n\n-- IK calculation, and application to the scene:\nfunction sysCall_actuation()\n    -- reflect the pose of the target dummy in the IK environment:\n    simIK.setObjectMatrix(ikEnv,ikTarget,ikBase,sim.getObjectMatrix(simTarget,simBase)) \n    simIK.handleIkGroup(ikEnv,ikGroup) -- solve\n    -- apply the calculated joint values:\n    sim.setJointPosition(simJoints[1],simIK.getJointPosition(ikEnv,ikJoints[1])) \n    sim.setJointPosition(simJoints[2],simIK.getJointPosition(ikEnv,ikJoints[2]))\nend \n For examples on how to use above API functions, refer to the scenes in  scenes/kinematics/ , and make sure to inspect the attached scripts. \n \n \n \n \n", 'tags': '', 'url': 'kinematicsPlugin.html'}, {'title': 'simIKAPI', 'text': "\n IK plugin API reference \n API functions for creating kinematics tasks. All units, unless otherwise indicated, are specified in meters and radians. \n simIK.addIkElement \n simIK.addIkElementFromScene \n simIK.applyIkEnvironmentToScene \n simIK.applySceneToIkEnvironment \n simIK.computeJacobian \n simIK.createEnvironment \n simIK.createDummy \n simIK.createIkGroup \n simIK.createJoint \n simIK.doesObjectExist \n simIK.doesIkGroupExist \n simIK.duplicateEnvironment \n simIK.eraseEnvironment \n simIK.eraseObject \n simIK.generatePath \n simIK.findConfig \n simIK.getAlternateConfigs \n simIK.getIkElementBase \n simIK.getIkElementConstraints \n simIK.getIkElementFlags \n simIK.getIkElementPrecision \n simIK.getIkElementWeights \n simIK.getIkGroupCalculation \n simIK.getIkGroupFlags \n simIK.getIkGroupHandle \n simIK.getJacobian \n simIK.getJointDependency \n simIK.getJointIkWeight \n simIK.getJointInterval \n simIK.getJointMatrix \n simIK.getJointMaxStepSize \n simIK.getJointMode \n simIK.getJointPosition \n simIK.getJointScrewPitch \n simIK.getJointTransformation \n simIK.getJointType \n simIK.getLinkedDummy \n simIK.getManipulability \n simIK.getObjectHandle \n simIK.getObjectMatrix \n simIK.getObjectParent \n simIK.getObjectPose \n simIK.getObjects \n simIK.getObjectTransformation \n simIK.handleIkGroup \n simIK.load \n simIK.save \n simIK.setIkElementBase \n simIK.setIkElementConstraints \n simIK.setIkElementFlags \n simIK.setIkElementPrecision \n simIK.setIkElementWeights \n simIK.setIkGroupCalculation \n simIK.setIkGroupFlags \n simIK.setJointDependency \n simIK.setJointIkWeight \n simIK.setJointInterval \n simIK.setJointMaxStepSize \n simIK.setJointMode \n simIK.setJointPosition \n simIK.setJointScrewPitch \n simIK.setLinkedDummy \n simIK.setObjectMatrix \n simIK.setObjectParent \n simIK.setObjectPose \n simIK.setObjectTransformation \n simIK.setSphericalJointMatrix \n simIK.setSphericalJointRotation \n \n Environment functions and helpers \n simIK.createEnvironment \n simIK.eraseEnvironment \n simIK.duplicateEnvironment \n simIK.save \n simIK.load \n simIK.addIkElementFromScene \n simIK.applyIkEnvironmentToScene \n simIK.applySceneToIkEnvironment \n \n Objects \n simIK.getObjects \n simIK.getObjectHandle \n simIK.doesObjectExist \n simIK.eraseObject \n simIK.getObjectParent \n simIK.setObjectParent \n simIK.getObjectPose \n simIK.setObjectPose \n simIK.getObjectTransformation \n simIK.setObjectTransformation \n simIK.getObjectMatrix \n simIK.setObjectMatrix \n \n Dummies \n simIK.createDummy \n simIK.eraseObject \n simIK.getLinkedDummy \n simIK.setLinkedDummy \n \n Joints \n simIK.createJoint \n simIK.eraseObject \n simIK.getJointPosition \n simIK.setJointPosition \n simIK.getJointMode \n simIK.setJointMode \n simIK.getJointInterval \n simIK.setJointInterval \n simIK.getJointDependency \n simIK.setJointDependency \n simIK.getJointIkWeight \n simIK.setJointIkWeight \n simIK.getJointMaxStepSize \n simIK.setJointMaxStepSize \n simIK.getJointScrewPitch \n simIK.setJointScrewPitch \n simIK.getJointTransformation \n simIK.setSphericalJointRotation \n simIK.getJointType \n simIK.getJointMatrix \n simIK.setSphericalJointMatrix \n \n IK groups \n simIK.createIkGroup \n simIK.getIkGroupHandle \n simIK.doesIkGroupExist \n simIK.getIkGroupFlags \n simIK.setIkGroupFlags \n simIK.getIkGroupCalculation \n simIK.setIkGroupCalculation \n \n IK elements \n simIK.addIkElement \n simIK.addIkElementFromScene \n simIK.getIkElementFlags \n simIK.setIkElementFlags \n simIK.getIkElementConstraints \n simIK.setIkElementConstraints \n simIK.getIkElementBase \n simIK.setIkElementBase \n simIK.getIkElementPrecision \n simIK.setIkElementPrecision \n simIK.getIkElementWeights \n simIK.setIkElementWeights \n \n IK calculation \n simIK.handleIkGroup \n simIK.applyIkEnvironmentToScene \n simIK.findConfig \n simIK.getAlternateConfigs \n simIK.computeJacobian \n simIK.getJacobian \n simIK.getManipulability \n simIK.generatePath \n \n \n \n \n simIK.addIkElement \n \n \n Description \n Adds a new IK element to an IK group. \n \n \n Lua synopsis \n int elementHandle=simIK.addIkElement(int environmentHandle,int ikGroupHandle,int tipDummyHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n tipDummyHandle : the handle of the dummy object that should act as the tip in the IK element. \n \n \n \n Lua return values \n elementHandle : the IK element handle in the IK group \n \n \n Python synopsis \n int elementHandle=simIK.addIkElement(int environmentHandle,int ikGroupHandle,int tipDummyHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle ,  simIK.addIkElementFromScene \n \n \n \n \n simIK.addIkElementFromScene \n \n \n Description \n Convenience function to quickly generate an IK element from a kinematic chain in the scene. Use together with  simIK.applyIkEnvironmentToScene . \n \n \n Lua synopsis \n int ikElement,map \nsimToIkObjectMap=simIK.addIkElementFromScene(int environmentHandle,int \nikGroup,int baseHandle,int tipHandle,int targetHandle,int constraints) \n \n \n Lua arguments \n \n environmentHandle : the handle of the IK environment. \n ikGroup : the handle of the IK group, where the IK element should be added. \n baseHandle : the handle of the base object in the \nscene. Can be -1 if the base of the kinematic chain is not moving nor \nchanging orientation. \n tipHandle : the handle of the tip object in the scene. \n targetHandle : the handle of the target object in the scene. \n constraints : the constraints for the IK element \nthat should be created. Bit-combine following: simIK.constraint_x, \nsimIK.constraint_y, simIK.constraint_z, simIK.constraint_alpha_beta, \nsimIK.constraint_gamma (simIK.constraint_gamma should only be set if \nsimIK.constraint_alpha_beta is also set). For convenience we also have \nsimIK.constraint_position=simIK.constraint_x|simIK.constraint_y|simIK.constraint_z,\n \nsimIK.constraint_orientation=simIK.constraint_alpha_beta|simIK.constraint_gamma,\n and \nsimIK.constraint_pose=simIK.constraint_position|simIK.constraint_orientation. \n \n \n \n Lua return values \n \n ikElement : the handle of the created IK element. \n simToIkObjectMap : the mapping of scene object to IK environment objects. \n \n \n \n Python synopsis \n int ikElement,list \nsimToIkObjectMap=simIK.addIkElementFromScene(int environmentHandle,int \nikGroup,int baseHandle,int tipHandle,int targetHandle,int constraints) \n \n \n See also \n simIK.applyIkEnvironmentToScene ,  simIK.addIkElement \n \n \n \n \n simIK.applyIkEnvironmentToScene \n \n \n Description \n Convenience function to compute and apply inverse kinematic values to the scene. Use together with  simIK.addIkElementFromScene . \n \n \n Lua synopsis \n int result=simIK.applyIkEnvironmentToScene(int environmentHandle,int ikGroup,bool applyOnlyWhenSuccessful=false) \n \n \n Lua arguments \n \n environmentHandle : the handle of the IK environment. \n ikGroup : the handle of the IK group. \n applyOnlyWhenSuccessful : whether computed values should only be applied if computation result is simIK.ikresult_success. \n \n \n \n Lua return values \n \n result : the resolution result, in return. Possible\n values are simIK.ikresult_not_performed, simIK.ikresult_success, or \nsimIK.ikresult_fail \n \n \n \n Python synopsis \n int result=simIK.applyIkEnvironmentToScene(int environmentHandle,int ikGroup,bool applyOnlyWhenSuccessful=False) \n \n \n See also \n simIK.addIkElementFromScene , simIK.applySceneToIkEnvironment \n \n \n \n \n simIK.applySceneToIkEnvironment \n \n \n Description \n Convenience function to apply the scene state to its ik environment counterpart. Use together with  simIK.addIkElementFromScene . \n \n \n Lua synopsis \n simIK.applySceneToIkEnvironment(int environmentHandle,int ikGroup) \n \n \n Lua arguments \n \n environmentHandle : the handle of the IK environment. \n ikGroup : the handle of the IK group. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.applySceneToIkEnvironment(int environmentHandle,int ikGroup) \n \n \n See also \n simIK.addIkElementFromScene , simIK.applyIkEnvironmentToScene \n \n \n \n \n simIK.computeJacobian \n \n \n Description \n Computes the Jacobian for an IK group. \n \n \n Lua synopsis \n bool success=simIK.computeJacobian(int environmentHandle,int ikGroupHandle,int options) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n options : options flag, bit-coded. bit0 set (i.e. 1): takes joint weights into account. \n \n \n \n Lua return values \n \n success : whether the Jacobian could successfully be computed. \n \n \n \n Python synopsis \n bool success=simIK.computeJacobian(int environmentHandle,int ikGroupHandle,int options) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJacobian ,  simIK.getManipulability \n \n \n \n \n simIK.createDummy \n \n \n Description \n Creates a dummy object. \n \n \n Lua synopsis \n int dummyHandle=simIK.createDummy(int environmentHandle,string dummyName='') \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n dummyName : the name of the dummy. \n \n \n \n Lua return values \n \n dummyHandle : the handle of the dummy. \n \n \n \n Python synopsis \n int dummyHandle=simIK.createDummy(int environmentHandle,string dummyName='') \n \n \n See also \n simIK.createEnvironment ,  simIK.doesObjectExist ,  simIK.createJoint ,  simIK.eraseObject \n \n \n \n \n simIK.createEnvironment \n \n \n Description \n Creates an new IK environment. \n \n \n Lua synopsis \n int environmentHandle=simIK.createEnvironment() \n \n \n Lua arguments \n \n \n \n \n Lua return values \n \n environmentHandle : the handle of the newly created environment. \n \n \n \n Python synopsis \n int environmentHandle=simIK.createEnvironment() \n \n \n See also \n simIK.eraseEnvironment ,  simIK.load \n \n \n \n \n simIK.createIkGroup \n \n \n Description \n Creates an IK group. \n \n \n Lua synopsis \n int ikGroupHandle=simIK.createIkGroup(int environmentHandle,string ikGroupName='') \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupName : the name of the IK group. \n \n \n \n Lua return values \n \n ikGroupHandle : the handle of the IK group. \n \n \n \n Python synopsis \n int ikGroupHandle=simIK.createIkGroup(int environmentHandle,string ikGroupName='') \n \n \n See also \n simIK.createEnvironment ,  simIK.doesIkGroupExist \n \n \n \n \n simIK.createJoint \n \n \n Description \n Creates a joint object. \n \n \n Lua synopsis \n int jointHandle=simIK.createJoint(int environmentHandle,string jointName='') \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointName : the name of the joint. \n jointType : the type of the joint. Supported types are simIK.jointtype_revolute, simIK.jointtype_prismatic and simIK.jointtype_spherical. \n \n \n \n Lua return values \n \n jointHandle : the handle of the joint. \n \n \n \n Python synopsis \n int jointHandle=simIK.createJoint(int environmentHandle,string jointName='') \n \n \n See also \n simIK.createEnvironment ,  simIK.doesObjectExist ,  simIK.createDummy ,  simIK.eraseObject \n \n \n \n \n simIK.doesObjectExist \n \n \n Description \n Checks whether an object exists, based on its name. \n \n \n Lua synopsis \n bool result=simIK.doesObjectExist(int environmentHandle,string objectName) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectName : the name of the object. \n \n \n \n Lua return values \n \n result : true if the object exists. \n \n \n \n Python synopsis \n bool result=simIK.doesObjectExist(int environmentHandle,string objectName) \n \n \n See also \n simIK.createEnvironment ,  simIK.getObjectHandle \n \n \n \n \n simIK.doesIkGroupExist \n \n \n Description \n Checks whether an IK group exists, based on its name. \n \n \n Lua synopsis \n bool result=simIK.doesIkGroupExist(int environmentHandle,string ikGroupName) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupName : the name of the IK group. \n \n \n \n Lua return values \n \n result : true if the IK group exists. \n \n \n \n Python synopsis \n bool result=simIK.doesIkGroupExist(int environmentHandle,string ikGroupName) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkGroupHandle \n \n \n \n \n simIK.duplicateEnvironment \n \n \n Description \n Duplicates an IK environment. Useful when operating on an environment while leaving the original environment unchanged. \n \n \n Lua synopsis \n int newEnvironmentHandle=simIK.duplicateEnvironment(int environmentHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n \n \n \n Lua return values \n \n newEnvironmentHandle : the handle of the duplicated environment. \n \n \n \n Python synopsis \n int newEnvironmentHandle=simIK.duplicateEnvironment(int environmentHandle) \n \n \n See also \n simIK.eraseEnvironment ,  simIK.createEnvironment \n \n \n \n \n simIK.eraseEnvironment \n \n \n Description \n Erases an IK environment. \n \n \n Lua synopsis \n simIK.eraseEnvironment(int environmentHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.eraseEnvironment(int environmentHandle) \n \n \n See also \n simIK.createEnvironment \n \n \n \n \n simIK.eraseObject \n \n \n Description \n Erases an object. \n \n \n Lua synopsis \n simIK.eraseObject(int environmentHandle,int objectHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : handle of the object. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.eraseObject(int environmentHandle,int objectHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.getObjectHandle ,  simIK.createDummy ,  simIK.createJoint \n \n \n \n \n simIK.findConfig \n \n \n Description \n Searches for a manipulator configuration \nthat matches the target dummy/dummies position/orientation in space. \nSearch is randomized. One should call  simIK.getAlternateConfigs \n for each returned configuration, if some revolute joints of the \nmanipulator have a range of more than 360 degrees, in order to generate \nsome equivalent poses but alternate configurations. The IK environment \nremains unchanged. \n \n \n Lua synopsis \n float[] \njointPositions=simIK.findConfig(int environmentHandle,int \nikGroupHandle,int[] jointHandles,float thresholdDist=0.1,float \nmaxTime=0.5,float[4] metric={1,1,1,0.1},func/string \nvalidationCallback=nil,auxData=nil) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n jointHandles : a table that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK. \n thresholdDist : a distance indicating when IK \nshould be computed in order to try to bring the tip onto the target: \nsince the search algorithm proceeds by generating random configurations,\n many of them produce a tip pose that is too far from the target pose to\n run IK successfully. Choosing a large value will result in slow \ncalculations, choosing a small value might produce a smaller subset of \nsolutions. Distance between two poses is calculated using a metric (see \nmetric argument below). \n maxTime : the upper time limit, in seconds, after which the function returns. \n metric : a table to 4 values indicating a metric \nused to compute pose-pose distances: \ndistance=sqrt((dx*metric[1])^2+(dy*metric[2])^2+(dz*metric[3])^2+(angle*metric[4])^2). \n validationCallback : an optional callback function \nexpressed as a function or a string. The callback function takes as \ninput arguments the proposed joint values (i.e. a configuration) and   auxData , and as return value whether the configuration is valid (e.g. is not colliding). \n auxData : auxiliary data that will be handed to the validation callback. \n \n \n \n Lua return values \n \n jointPositions : a table that contains the IK \ncalculated joint values, as specified by the jointHandles table, if a \nvalid configuration was found. \n \n \n \n Python synopsis \n list jointPositions=simIK.findConfig(int \nenvironmentHandle,int ikGroupHandle,list jointHandles,float \nthresholdDist=0.1,float maxTime=0.5,list \nmetric=[1,1,1,0.1],function/string validationCallback=None,auxData=None) \n \n \n See also \n simIK.createEnvironment ,  simIK.duplicateEnvironment ,  simIK.getAlternateConfigs ,  simIK.computeJacobian ,  simIK.getJacobian \n \n \n \n \n simIK.generatePath \n \n \n Description \n Generates a path that drives the IK tip \nonto its IK target, in a straight line (i.e. shortest path in Cartesian \nspace). The function returns a path in the configuration space if the \noperation was successful. A reason for a non-successful operation can \nbe: there are some forbidden poses/configurations on the way, or some of\n the configuration points cannot be reached (e.g. out of reach, or due \nto joint limits). The IK environment remains unchanged. \n \n \n Lua synopsis \n float[] \nconfigurationList=simIK.generatePath(int environmentHandle,int \nikGroupHandle,int[] jointHandles,int tipHandle,int \npathPointCount,function/string validationCallback=nil,auxData=nil \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the IK group handle. \n jointHandles : a table that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK. \n tipHandle : the handle of the tip object. \n pathPointCount : the desired number of path points. Each path point contains a joint configuration. A minimum of two path points is required. \n validationCallback : an optional callback function,\n expressed as a function or string. The callback function takes as input\n arguments proposed joint values (i.e. a configuration) and   auxData , and as return value whether the configuration is valid (e.g. is not colliding). \n auxData : auxiliary data that will be handed to the validation callback. \n \n \n \n Lua return values \n \n configurationList : a table that contains configurations (in row-major order) that will bring the IK tip onto its IK target. \n \n \n \n Python synopsis \n list \nconfigurationList=simIK.generatePath(int environmentHandle,int \nikGroupHandle,list jointHandles,int tipHandle,int \npathPointCount,function/string validationCallback=None,auxData=None \n \n \n See also \n simIK.duplicateEnvironment \n \n \n \n \n simIK.getAlternateConfigs \n \n \n Description \n Useful when called after  simIK.findConfig :\n generates alternative manipulator configurations, for a same \nend-effector pose, for a manipulator that has revolute joints with a \nrange larger than 360 degrees. The original submitted configuration will\n be part of the returned configurations. The IK environment remains \nunchanged. \n \n \n Lua synopsis \n float[] \nconfigurations=simIK.getAlternateConfigs(int environmentHandle,int[] \njointHandles,float[] lowLimits=nil,float[] ranges=nil) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandles : a table with the handles of the manipulator joints. \n lowLimits : a table with joint low limit values for\n each specified joint. This can be useful when you wish to explore a \nsub-set of the joint's intervals. \n ranges : a table with joint range values for each \nspecified joint. This can be useful when you wish to explore a sub-set \nof the joint's intervals. If the range value is 0, then the lowLimit and\n range values are taken from the joint's properties. If the range value \nis negative, then the search interval will be centered around the \ncurrent linear/angular joint position, with an extent of (-range). \n \n \n \n Lua return values \n \n configurations : a table containing configurations \n(in row-major order) that are equivalent to the specified inputConfig, \nin terms of end-effector pose. \n \n \n \n Python synopsis \n list configurations=simIK.getAlternateConfigs(int environmentHandle,list jointHandles,list lowLimits=None,list ranges=None) \n \n \n See also \n simIK.createEnvironment ,  simIK.findConfig \n \n \n \n \n simIK.getConfigForTipPose \n \n \n Description \n Deprecated. Use simIK.findConfig instead. \n \n \n Lua synopsis \n float[] \njointPositions=simIK.getConfigForTipPose(int environmentHandle,int \nikGroupHandle,int[] jointHandles,float thresholdDist=0.1,float \nmaxTime=0.5,float[4] metric={1,1,1,0.1},function \nvalidationCallback=nil,auxData=nil,int[] jointOptions={},float[] \nlowLimits={},float[] ranges={}) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n jointHandles : a table that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK. \n thresholdDist : a distance indicating when IK \nshould be computed in order to try to bring the tip onto the target: \nsince the search algorithm proceeds by generating random configurations,\n many of them produce a tip pose that is too far from the target pose to\n run IK successfully. Choosing a large value will result in slow \ncalculations, choosing a small value might produce a smaller subset of \nsolutions. Distance between two poses is calculated using a metric (see \nmetric argument below). \n maxTime : the upper time limit, in seconds, after which the function returns. \n metric : a table to 4 values indicating a metric \nused to compute pose-pose distances: \ndistance=sqrt((dx*metric[1])^2+(dy*metric[2])^2+(dz*metric[3])^2+(angle*metric[4])^2). \n validationCallback : an optional callback function.\n The callback function takes as input arguments the proposed joint \nvalues (i.e. a configuration) and   auxData , and as return value whether the configuration is valid (e.g. is not colliding). \n auxData : auxiliary data that will be handed to the validation callback. \n jointOptions : a table with bit-coded values \ncorresponding to each specified joint handle. Bit 0 (i.e. 1) indicates \nthe corresponding joint is dependent of another joint. \n lowLimits : a table with joint low limit values for\n each specified joint. This can be useful when you wish to explore a \nsub-set of the joint's intervals. \n ranges : a table with joint range values for each \nspecified joint. This can be useful when you wish to explore a sub-set \nof the joint's intervals. If the range value is 0, then the lowLimit and\n range values are taken from the joint's properties. If the range value \nis negative, then the search interval will be centered around the \ncurrent linear/angular joint position, with an extent of (-range). \n \n \n \n Lua return values \n \n jointPositions : a table that contains the IK \ncalculated joint values, as specified by the jointHandles table, if a \nvalid configuration was found. \n \n \n \n Python synopsis \n list \njointPositions=simIK.getConfigForTipPose(int environmentHandle,int \nikGroupHandle,list jointHandles,float thresholdDist=0.1,float \nmaxTime=0.5,list metric=[1,1,1,0.1],function \nvalidationCallback=None,auxData=None,list jointOptions=[],list \nlowLimits=[],list ranges=[]) \n \n \n See also \n simIK.createEnvironment ,  simIK.duplicateEnvironment ,  simIK.getAlternateConfigs ,  simIK.computeJacobian ,  simIK.getJacobian \n \n \n \n \n simIK.getIkElementBase \n \n \n Description \n Retrieves the base object of an IK element. \n \n \n Lua synopsis \n int baseHandle,int constraintsBaseHandle=simIK.getIkElementBase(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n \n \n \n Lua return values \n \n baseHandle : the handle of the base object, or -1 if the world is the base. \n constraintsBaseHandle : the handle of the \nconstraints base object, relative to which the constraints are \nspecified. Returns -1 if the constraints are relative to the base \nobject. \n \n \n \n Python synopsis \n int baseHandle,int constraintsBaseHandle=simIK.getIkElementBase(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setIkElementBase ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.getIkElementConstraints \n \n \n Description \n Retrieves the constraints of an IK element. \n \n \n Lua synopsis \n int constraints=simIK.getIkElementConstraints(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n \n \n \n Lua return values \n \n constraints : the constraints. A bit-combination of\n following is possible: simIK.constraint_x, simIK.constraint_y, \nsimIK.constraint_z, simIK.constraint_alpha_beta, simIK.constraint_gamma. \n \n \n \n Python synopsis \n int constraints=simIK.getIkElementConstraints(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setIkElementConstraints ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.getIkElementFlags \n \n \n Description \n Retrieves various flags of an IK element. \n \n \n Lua synopsis \n int flags=simIK.getIkElementFlags(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n \n \n \n Lua return values \n \n flags : bit-coded flags: bit0 set(1)=the enabled state of the ik element. \n \n \n \n Python synopsis \n int flags=simIK.getIkElementFlags(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setIkElementFlags ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.getIkElementPrecision \n \n \n Description \n Retrieves the precision settings of an IK element. \n \n \n Lua synopsis \n float[2] precision=simIK.getIkElementPrecision(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n \n \n \n Lua return values \n \n precision : a table with the linear and angular precision. \n \n \n \n Python synopsis \n list precision=simIK.getIkElementPrecision(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setIkElementPrecision ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.getIkElementWeights \n \n \n Description \n Retrieves the desired linear and angular resolution weights of an IK element. \n \n \n Lua synopsis \n float[2] weights=simIK.getIkElementWeights(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n \n \n \n Lua return values \n \n weights : a table with the linear and angular resolution weights. \n \n \n \n Python synopsis \n list weights=simIK.getIkElementWeights(int environmentHandle,int ikGroupHandle,int elementHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setIkElementWeights ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.getIkGroupCalculation \n \n \n Description \n Retrieves calculation properties for an IK group. \n \n \n Lua synopsis \n int method,float damping,int maxIterations=simIK.getIkGroupCalculation(int environmentHandle,int ikGroupHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n \n \n \n Lua return values \n \n method : the resolution method. Possible values are\n simIK.method_pseudo_inverse (features a tiny bit of hard-coded \ndamping), simIK.method_undamped_pseudo_inverse, \nsimIK.method_damped_least_squares and simIK.method_jacobian_transpose. \n damping : the damping, in case the resolution method is simIK.method_damped_least_squares. \n maxIterations : the maximum number of iterations. \n \n \n \n Python synopsis \n int method,float damping,int maxIterations=simIK.getIkGroupCalculation(int environmentHandle,int ikGroupHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setIkGroupCalculation ,  simIK.getIkGroupHandle \n \n \n \n \n simIK.getIkGroupFlags \n \n \n Description \n Retrieves flags of an IK group. \n \n \n Lua synopsis \n int flags=simIK.getIkGroupFlags(int environmentHandle,int ikGroupHandle)) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n \n \n \n Lua return values \n \n flags : the flags of the IK group. bit0 set (i.e. \n1)=group is enabled, bit1 set (i.e. 2)=max. step sizes are ignored, bit2\n set (i.e. 4)=restore joints if target position not reached, bit3 set \n(i.e. 8)=restore joints if target orientation not reached. \n \n \n \n Python synopsis \n int flags=simIK.getIkGroupFlags(int environmentHandle,int ikGroupHandle)) \n \n \n See also \n simIK.createEnvironment ,  simIK.setIkGroupFlags ,  simIK.getIkGroupHandle \n \n \n \n \n simIK.getIkGroupHandle \n \n \n Description \n Retrieves the handle of an IK group based on its name. \n \n \n Lua synopsis \n int ikGroupHandle=simIK.getIkGroupHandle(int environmentHandle,string ikGroupName) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupName : the name of the IK group. \n \n \n \n Lua return values \n \n ikGroupHandle : the handle of the IK group. \n \n \n \n Python synopsis \n int ikGroupHandle=simIK.getIkGroupHandle(int environmentHandle,string ikGroupName) \n \n \n See also \n simIK.createEnvironment ,  simIK.doesIkGroupExist ,  simIK.createIkGroup \n \n \n \n \n simIK.getJacobian \n \n \n Description \n Retrieves the Jacobian previously computed via  simIK.computeJacobian . \n \n \n Lua synopsis \n float[] jacobian,int[2] matrixSize=simIK.getJacobian(int environmentHandle,int ikGroupHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n \n \n \n Lua return values \n \n jacobian : a table with the jacobian values. \n matrixSize : a table containing the sizes (row count (i.e. number of DoFs) and column count) of the Jacobian matrix. \n \n \n \n Python synopsis \n list jacobian,list matrixSize=simIK.getJacobian(int environmentHandle,int ikGroupHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.computeJacobian ,  simIK.getManipulability \n \n \n \n \n simIK.getJointDependency \n \n \n Description \n Retrieves information about a possible joint dependency. \n \n \n Lua synopsis \n int depJointHandle,float offset,float mult=simIK.getJointDependency(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n depJointHandle : the handle of the dependency joint. \n offset : the offset. We have linear/angular joint position = dependency linear/angular joint position * mult + offset. \n mult : the multiplication factor. We have linear/angular joint position = dependency linear/angular joint position * mult + offset. \n \n \n \n Python synopsis \n int depJointHandle,float offset,float mult=simIK.getJointDependency(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setJointDependency ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointIkWeight \n \n \n Description \n Retrieves the IK weight of a joint, i.e. the weight it has during IK resolution. \n \n \n Lua synopsis \n float weight=simIK.getJointIkWeight(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n weight : the IK weight. \n \n \n \n Python synopsis \n float weight=simIK.getJointIkWeight(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setJointIkWeight ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointInterval \n \n \n Description \n Retrieves the joint limits. \n \n \n Lua synopsis \n bool cyclic,float[2] interval=simIK.getJointInterval(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n cyclic : whether the joint is cyclic (has no limits). \n interval : a table with two values: the joint lower limit, and the joint range (i.e. joint upper limit = joint lower limit + joint range) \n \n \n \n Python synopsis \n bool cyclic,list interval=simIK.getJointInterval(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setJointInterval ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointMatrix \n \n \n Description \n Retrieves the intrinsic transformation matrix of a joint. \n \n \n Lua synopsis \n float[12] matrix=simIK.getJointMatrix(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n matrix : a table of 12 numbers representing the transformation matrix (the last row of the 4x4 matrix (0,0,0,1) is not returned). \n \n \n \n Python synopsis \n list matrix=simIK.getJointMatrix(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setSphericalJointMatrix ,  simIK.getJointPosition ,  simIK.getJointTransformation ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointMaxStepSize \n \n \n Description \n Retrieves the maximum step size of a joint. \n \n \n Lua synopsis \n float stepSize=simIK.getJointMaxStepSize(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n stepSize : the maximum step size. \n \n \n \n Python synopsis \n float stepSize=simIK.getJointMaxStepSize(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setJointMaxStepSize ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointMode \n \n \n Description \n Retrieves the joint mode. \n \n \n Lua synopsis \n int jointMode=simIK.getJointMode(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n jointMode : the joint mode. Possible values are: simIK.jointmode_passive, simIK.jointmode_ik, simIK.jointmode_dependent \n \n \n \n Python synopsis \n int jointMode=simIK.getJointMode(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setJointMode ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointPosition \n \n \n Description \n Retrieves the position (linear or angular) of a joint. \n \n \n Lua synopsis \n float position=simIK.getJointPosition(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n position : the position. \n \n \n \n Python synopsis \n float position=simIK.getJointPosition(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setJointPosition ,  simIK.getJointMatrix ,  simIK.getJointTransformation ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointScrewPitch \n \n \n Description \n Retrieves the screw pitch of a revolute joint. \n \n \n Lua synopsis \n float pitch=simIK.getJointScrewPitch(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n pitch : the screw pitch of the joint. A pitch value\n of zero represents a revolute joint, a value different from zero \nrepresents a screw. \n \n \n \n Python synopsis \n float pitch=simIK.getJointScrewPitch(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setJointScrewPitch ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointTransformation \n \n \n Description \n Retrieves the intrinsic transformation of a joint. \n \n \n Lua synopsis \n float[3] position,float[4] quaternion,float[3] euler=simIK.getJointTransformation(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n position : the translation of the joint. \n quaternion : the rotation of the joint, expressed as quaternion (x,y,z,w). \n euler : the rotation of the joint, expressed as Euler angles (alpha,beta,gamma). \n \n \n \n Python synopsis \n list position,list quaternion,list euler=simIK.getJointTransformation(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setSphericalJointRotation ,  simIK.getJointPosition ,  simIK.getJointMatrix ,  simIK.getObjectHandle \n \n \n \n \n simIK.getJointType \n \n \n Description \n Retrieves the joint type. \n \n \n Lua synopsis \n int jointType=simIK.getJointType(int environmentHandle,int jointHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n \n \n \n Lua return values \n \n jointType : the joint type. Possible values are: simIK.jointtype_revolute, simIK.jointtype_prismatic and simIK.jointtype_spherical \n \n \n \n Python synopsis \n int jointType=simIK.getJointType(int environmentHandle,int jointHandle) \n \n \n See also \n simIK.createJoint \n \n \n \n \n simIK.getLinkedDummy \n \n \n Description \n Retrieves the handle of a dummy linked to this one. \n \n \n Lua synopsis \n int linkedDummyHandle=simIK.getLinkedDummy(int environmentHandle,int dummyHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n dummyHandle : the handle of the dummy object. \n \n \n \n Lua return values \n \n linkedDummyHandle : the handle of the linked dummy object. Is -1 if no dummy object is linked to this one. \n \n \n \n Python synopsis \n int linkedDummyHandle=simIK.getLinkedDummy(int environmentHandle,int dummyHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setLinkedDummy ,  simIK.getObjectHandle \n \n \n \n \n simIK.getManipulability \n \n \n Description \n Retrieves the manipulability value ( sqrt(det(J*JT)) ) of the Jacobian previously computed via  simIK.computeJacobian . \n \n \n Lua synopsis \n float manipulability=simIK.getManipulability(int environmentHandle,int ikGroupHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n \n \n \n Lua return values \n \n manipulability : the manipulability value. \n \n \n \n Python synopsis \n float manipulability=simIK.getManipulability(int environmentHandle,int ikGroupHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.computeJacobian ,  simIK.getJacobian \n \n \n \n \n simIK.getObjectHandle \n \n \n Description \n Retrieves the handle of an object based on its name. \n \n \n Lua synopsis \n int objectHandle=simIK.getObjectHandle(int environmentHandle,string objectName) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectName : the name of the object. \n \n \n \n Lua return values \n \n objectHandle : the object handle. \n \n \n \n Python synopsis \n int objectHandle=simIK.getObjectHandle(int environmentHandle,string objectName) \n \n \n See also \n simIK.createEnvironment ,  simIK.doesObjectExist ,  simIK.createDummy ,  simIK.createJoint \n \n \n \n \n simIK.getObjectMatrix \n \n \n Description \n Retrieves the transformation matrix of an\n object. If the object is a joint object, the matrix does not include \nthe joint's intrinsic transformation. \n \n \n Lua synopsis \n float[12] matrix=simIK.getObjectMatrix(int environmentHandle,int objectHandle,int relativeToObjectHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n relativeToObjectHandle : the handle of an object \nrelative to which we want the matrix expressed. Otherwise, specify \nsimIK.handle_world if you want the absolute matrix, or \nsimIK.handle_parent if you want the matrix relative to the parent \nobject. \n \n \n \n Lua return values \n \n matrix : a table of 12 numbers representing the transformation matrix (the last row of the 4x4 matrix (0,0,0,1) is not returned) \n \n \n \n Python synopsis \n list matrix=simIK.getObjectMatrix(int environmentHandle,int objectHandle,int relativeToObjectHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setObjectMatrix ,  simIK.getObjectPose , simIK.getObjectTransformation ,  simIK.getJointTransformation ,  simIK.getObjectHandle \n \n \n \n \n simIK.getObjectParent \n \n \n Description \n Retrieves an object's parent handle. \n \n \n Lua synopsis \n int parentObjectHandle=simIK.getObjectParent(int environmentHandle,int objectHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n \n \n \n Lua return values \n \n parentObjectHandle : the returned handle of the parent, or -1 if the object has no parent. \n \n \n \n Python synopsis \n int parentObjectHandle=simIK.getObjectParent(int environmentHandle,int objectHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setObjectParent ,  simIK.getObjectHandle \n \n \n \n \n simIK.getObjectPose \n \n \n Description \n Retrieves the pose (position and \nquaternion) of an object. If the object is a joint object, the pose does\n not include the joint's intrinsic transformation. \n \n \n Lua synopsis \n float[7] pose=simIK.getObjectPose(int environmentHandle,int objectHandle,int relativeToObjectHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n relativeToObjectHandle : the handle of an object \nrelative to which we want the pose expressed. Otherwise, specify \nsimIK.handle_world if you want the absolute pose, or simIK.handle_parent\n if you want the pose relative to the parent object. \n \n \n \n Lua return values \n \n pose : the position and quaternion of the object (x,y,z,qx,qy,qz,qw). \n \n \n \n Python synopsis \n list pose=simIK.getObjectPose(int environmentHandle,int objectHandle,int relativeToObjectHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setObjectPose ,  simIK.getObjectTransformation ,  simIK.getObjectMatrix ,  simIK.getJointTransformation ,  simIK.getObjectHandle \n \n \n \n \n simIK.getObjects \n \n \n Description \n Allows to loop through all objects in the environment. \n \n \n Lua synopsis \n int objectHandle,string objectName,bool isJoint,int jointType=simIK.getObjects(int environmentHandle,int index) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n index : the zero-based index. Start at 0, and \nincrement until there is no return values anymore, in order to loop \nthrough all objects in the environment. \n \n \n \n Lua return values \n \n objectHandle : the handle of the object, or nil if there is no object at the specified index. \n objectName : the name of the object. \n isJoint : whether the object is a joint. \n jointType : the type of joint, if the object at the\n specified index is a joint. Possible values are \nsimIK.jointtype_revolute, simIK.jointtype_prismatic or \nsimIK.jointtype_spherical. \n \n \n \n Python synopsis \n int objectHandle,string objectName,bool isJoint,int jointType=simIK.getObjects(int environmentHandle,int index) \n \n \n See also \n simIK.getObjectHandle ,  simIK.doesObjectExist \n \n \n \n \n simIK.getObjectTransformation \n \n \n Description \n Retrieves the transformation (position \nand quaternion/euler angles) of an object. If the object is a joint \nobject, the transformation does not include the joint's intrinsic \ntransformation. \n \n \n Lua synopsis \n float[3] position,float[4] \nquaternion,float[3] euler=simIK.getObjectTransformation(int \nenvironmentHandle,int objectHandle,int relativeToObjectHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n relativeToObjectHandle : the handle of an object \nrelative to which we want the transformation expressed. Otherwise, \nspecify simIK.handle_world if you want the absolute transformation, or \nsimIK.handle_parent if you want the transformation relative to the \nparent object. \n \n \n \n Lua return values \n \n position : the position of the object. \n quaternion : the orientation of the object, expressed as quaternion (x,y,z,w). \n euler : the orientation of the object, expressed as Euler angles (alpha,beta,gamma). \n \n \n \n Python synopsis \n list position,list quaternion,list \neuler=simIK.getObjectTransformation(int environmentHandle,int \nobjectHandle,int relativeToObjectHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.setObjectTransformation ,  simIK.getObjectPose ,  simIK.getObjectMatrix ,  simIK.getJointTransformation ,  simIK.getObjectHandle \n \n \n \n \n simIK.handleIkGroup \n \n \n Description \n Handles (i.e. computes/resolves) an IK group. \n \n \n Lua synopsis \n int result=simIK.handleIkGroup(int environmentHandle,int ikGroupHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group, or simIK.handle_all to handle all IK groups. \n \n \n \n Lua return values \n \n result : the resolution result, in return. Possible\n values are simIK.ikresult_not_performed, simIK.ikresult_success, or \nsimIK.ikresult_fail \n \n \n \n Python synopsis \n int result=simIK.handleIkGroup(int environmentHandle,int ikGroupHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.computeJacobian ,  simIK.findConfig \n \n \n \n \n simIK.load \n \n \n Description \n Loads kinematic content previously \nexported in the CoppeliaSim application. Make sure that the environment \nis empty before calling this function. \n \n \n Lua synopsis \n simIK.load(int environmentHandle,buffer data) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n data : a buffer with the kinematic content. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.load(int environmentHandle,bytes data) \n \n \n See also \n simIK.save ,  simIK.createEnvironment ,  simIK.eraseEnvironment \n \n \n \n \n simIK.save \n \n \n Description \n Saves the kinematic content of an IK environment. \n \n \n Lua synopsis \n buffer data=simIK.save(int environmentHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n \n \n \n Lua return values \n \n data : the exported data. \n \n \n \n Python synopsis \n bytes data=simIK.save(int environmentHandle) \n \n \n See also \n simIK.load \n \n \n \n \n simIK.setIkElementBase \n \n \n Description \n Sets the base object of an IK element. \n \n \n Lua synopsis \n simIK.setIkElementBase(int environmentHandle,int ikGroupHandle,int elementHandle,int baseHandle,int constraintsBaseHandle=-1) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n baseHandle : the handle of the base object, or -1 if the world is the base. \n constraintsBaseHandle : the handle of the \nconstraints base object, relative to which the constraints are \nspecified. Set to -1 to have the constraints relative to the base \nobject. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setIkElementBase(int environmentHandle,int ikGroupHandle,int elementHandle,int baseHandle,int constraintsBaseHandle=-1) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkElementBase ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.setIkElementConstraints \n \n \n Description \n Sets the constraints of an IK element. \n \n \n Lua synopsis \n simIK.setIkElementConstraints(int environmentHandle,int ikGroupHandle,int elementHandle,int constraints) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n constraints : the constraints. Bit-combine \nfollowing: simIK.constraint_x, simIK.constraint_y, simIK.constraint_z, \nsimIK.constraint_alpha_beta, simIK.constraint_gamma \n(simIK.constraint_gamma should only be set if \nsimIK.constraint_alpha_beta is also set). For convenience we also have \nsimIK.constraint_position=simIK.constraint_x|simIK.constraint_y|simIK.constraint_z,\n \nsimIK.constraint_orientation=simIK.constraint_alpha_beta|simIK.constraint_gamma,\n and \nsimIK.constraint_pose=simIK.constraint_position|simIK.constraint_orientation. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setIkElementConstraints(int environmentHandle,int ikGroupHandle,int elementHandle,int constraints) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkElementConstraints ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.setIkElementFlags \n \n \n Description \n Sets various flags of an IK element. \n \n \n Lua synopsis \n simIK.setIkElementFlags(int environmentHandle,int ikGroupHandle,int elementHandle,int flags) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n flags : bit-coded flags: bit0 set (1)=the enabled state of the IK element. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setIkElementFlags(int environmentHandle,int ikGroupHandle,int elementHandle,int flags) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkElementFlags ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.setIkElementPrecision \n \n \n Description \n Sets the desired precision of an IK element. \n \n \n Lua synopsis \n simIK.setIkElementPrecision(int environmentHandle,int ikGroupHandle,int elementHandle,float[2] precision) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n precision : a table with two values for the linear and angular precision. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setIkElementPrecision(int environmentHandle,int ikGroupHandle,int elementHandle,list precision) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkElementPrecision ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.setIkElementWeights \n \n \n Description \n Sets the desired linear and angular resolution weights of an IK element. \n \n \n Lua synopsis \n simIK.setIkElementWeights(int environmentHandle,int ikGroupHandle,int elementHandle,float[2] weights) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n elementHandle : the IK element handle, or X, where \nX=handleOfTipDummy+simIK.handleflag_tipdummy (if several IK elements \nwith the same tip dummy exist, then the first encountered will be \nselected). \n weights : a table with two values for the linear and angular resolution weight. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setIkElementWeights(int environmentHandle,int ikGroupHandle,int elementHandle,list weights) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkElementWeights ,  simIK.getIkGroupHandle ,  simIK.getObjectHandle \n \n \n \n \n simIK.setIkGroupCalculation \n \n \n Description \n Sets calculation properties for an IK group. \n \n \n Lua synopsis \n simIK.setIkGroupCalculation(int environmentHandle,int ikGroupHandle,int method,float damping,float maxIterations) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n method : the resolution method. Possible values are\n simIK.method_pseudo_inverse (features a tiny bit of hard-coded \ndamping), simIK.method_undamped_pseudo_inverse, \nsimIK.method_damped_least_squares and simIK.method_jacobian_transpose. \n damping : the damping, in case the resolution method is simIK.method_damped_least_squares. \n maxIterations : the maximum number of iterations. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setIkGroupCalculation(int environmentHandle,int ikGroupHandle,int method,float damping,float maxIterations) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkGroupCalculation ,  simIK.getIkGroupHandle \n \n \n \n \n simIK.setIkGroupFlags \n \n \n Description \n Sets flags of an IK group. \n \n \n Lua synopsis \n simIK.setIkGroupFlags(int environmentHandle,int ikGroupHandle,int flags) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n ikGroupHandle : the handle of the IK group. \n flags : the flags of the IK group. bit0 set (i.e. \n1)=group is enabled, bit1 set (i.e. 2)=max. step sizes are ignored, bit2\n set (i.e. 4)=restore joints if target position not reached, bit3 set \n(i.e. 8)=restore joints if target orientation not reached. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setIkGroupFlags(int environmentHandle,int ikGroupHandle,int flags) \n \n \n See also \n simIK.createEnvironment ,  simIK.getIkGroupFlags ,  simIK.getIkGroupHandle \n \n \n \n \n simIK.setJointDependency \n \n \n Description \n Sets information about a possible dependent joint. \n \n \n Lua synopsis \n simIK.setJointDependency(int environmentHandle,int jointHandle,int depJointHandle,float offset=0,float mult=1) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n depJointHandle : the handle of the joint, this joint is dependent of. -1 to disable. \n offset : the offset. We have linear/angular joint position = dependency linear/angular joint position * mult + offset \n mult : the multiplication factor. We have linear/angular joint position = dependency linear/angular joint position * mult + offset \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setJointDependency(int environmentHandle,int jointHandle,int depJointHandle,float offset=0,float mult=1) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointDependency ,  simIK.getObjectHandle \n \n \n \n \n simIK.setJointIkWeight \n \n \n Description \n Sets the IK weight of a joint, i.e. the weight it has during IK resolution. \n \n \n Lua synopsis \n simIK.setJointIkWeight(int environmentHandle,int jointHandle,float weight) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n weight : the IK weight. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setJointIkWeight(int environmentHandle,int jointHandle,float weight) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointIkWeight ,  simIK.getObjectHandle \n \n \n \n \n simIK.setJointInterval \n \n \n Description \n Sets the joint limits. \n \n \n Lua synopsis \n simIK.setJointInterval(int environmentHandle,int jointHandle,bool cyclic,float[2] interval={}) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n cyclic : whether the joint is cyclic (has no limits). Only revolute joints can be cyclic. \n interval : a table with two values: the joint lower limit, and the joint range (i.e. joint upper limit = joint lower limit + joint range) \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setJointInterval(int environmentHandle,int jointHandle,bool cyclic,list interval=[]) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointInterval ,  simIK.getObjectHandle \n \n \n \n \n simIK.setJointMaxStepSize \n \n \n Description \n Sets the maximum step size of a joint. \n \n \n Lua synopsis \n simIK.setJointMaxStepSize(int environmentHandle,int jointHandle,float stepSize) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n stepSize : the maximum step size. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setJointMaxStepSize(int environmentHandle,int jointHandle,float stepSize) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointMaxStepSize ,  simIK.getObjectHandle \n \n \n \n \n simIK.setJointMode \n \n \n Description \n Sets the joint mode. \n \n \n Lua synopsis \n simIK.setJointMode(int environmentHandle,int jointHandle,int jointMode) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n jointMode : the joint mode. Allowed values are: simIK.jointmode_passive, simIK.jointmode_ik, simIK.jointmode_dependent \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setJointMode(int environmentHandle,int jointHandle,int jointMode) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointMode ,  simIK.getObjectHandle \n \n \n \n \n simIK.setJointPosition \n \n \n Description \n Sets the position (linear or angular) of a joint. \n \n \n Lua synopsis \n simIK.setJointPosition(int environmentHandle,int jointHandle,float position) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n position : the position. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setJointPosition(int environmentHandle,int jointHandle,float position) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointPosition ,  simIK.setSphericalJointMatrix ,  simIK.setSphericalJointRotation ,  simIK.getObjectHandle \n \n \n \n \n simIK.setJointScrewPitch \n \n \n Description \n Sets the screw pitch, in case of a revolute joint. \n \n \n Lua synopsis \n simIK.setJointScrewPitch(int environmentHandle,int jointHandle,float pitch) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n pitch : the screw pitch of the joint. A pitch value\n of zero represents a revolute joint, a value different from zero \nrepresents a screw. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setJointScrewPitch(int environmentHandle,int jointHandle,float pitch) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointScrewPitch ,  simIK.getObjectHandle \n \n \n \n \n simIK.setLinkedDummy \n \n \n Description \n Links this dummy object to another dummy object, or detaches it from another dummy object. \n \n \n Lua synopsis \n simIK.setLinkedDummy(int environmentHandle,int dummyHandle,int linkedDummyHandle) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n dummyHandle : the handle of the dummy object. \n linkedDummyHandle : the handle of the dummy object to be linked, or -1 to detach this dummy object from a linked dummy object. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setLinkedDummy(int environmentHandle,int dummyHandle,int linkedDummyHandle) \n \n \n See also \n simIK.createEnvironment ,  simIK.getLinkedDummy ,  simIK.getObjectHandle \n \n \n \n \n simIK.setObjectMatrix \n \n \n Description \n Sets the transformation matrix of an \nobject. If the object is a joint object, the matrix does not include the\n joint's intrinsic transformation. \n \n \n Lua synopsis \n simIK.setObjectMatrix(int environmentHandle,int objectHandle,int relativeToObjectHandle,float[12] matrix) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n relativeToObjectHandle : the handle of an object \nrelative to which the matrix is expressed. Otherwise, specify \nsimIK.handle_world if you specify the absolute matrix, or \nsimIK.handle_parent if you specify the matrix relative to the parent \nobject. \n matrix : a table of 12 values representing the transformation matrix (the last row of the 4x4 matrix (0,0,0,1) is omitted) \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setObjectMatrix(int environmentHandle,int objectHandle,int relativeToObjectHandle,list matrix) \n \n \n See also \n simIK.createEnvironment ,  simIK.getObjectMatrix ,  simIK.setObjectPose ,  simIK.setObjectTransformation ,  simIK.setJointPosition ,  simIK.getObjectHandle \n \n \n \n \n simIK.setObjectParent \n \n \n Description \n Sets the parent of an object. \n \n \n Lua synopsis \n simIK.setObjectParent(int environmentHandle,int objectHandle,int parentObjectHandle, bool keepInPlace=true) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n parentObjectHandle : the desired parent object, set -1 for no parent. \n keepInPlace : if true, the object will stay in place, otherwise, it will keep its local transformation. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setObjectParent(int environmentHandle,int objectHandle,int parentObjectHandle, bool keepInPlace=True) \n \n \n See also \n simIK.createEnvironment ,  simIK.getObjectParent ,  simIK.getObjectHandle \n \n \n \n \n simIK.setObjectPose \n \n \n Description \n Sets the pose (position and quaternion) \nof an object. If the object is a joint object, the pose does not include\n the joint's intrinsic transformation. \n \n \n Lua synopsis \n simIK.setObjectPose(int environmentHandle,int objectHandle,int relativeToObjectHandle,float[7] pose) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n relativeToObjectHandle : the handle of an object \nrelative to which the pose is expressed. Otherwise, specify \nsimIK.handle_world if you specify the absolute pose, or \nsimIK.handle_parent if you specify the pose relative to the parent \nobject. \n pose : the position and quaternion (x,y,z,qx,qy,qz,qw). \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setObjectPose(int environmentHandle,int objectHandle,int relativeToObjectHandle,list pose) \n \n \n See also \n simIK.createEnvironment ,  simIK.getObjectPose ,  simIK.setObjectTransformation ,  simIK.setObjectMatrix ,  simIK.setJointPosition ,  simIK.getObjectHandle \n \n \n \n \n simIK.setObjectTransformation \n \n \n Description \n Sets the transformation (position and \nquaternion/Euler angles) of an object. If the object is a joint object, \nthe transformation does not include the joint's intrinsic \ntransformation. \n \n \n Lua synopsis \n simIK.setObjectTransformation(int \nenvironmentHandle,int objectHandle,int relativeToObjectHandle,float[3] \nposition,float[] eulerOrQuaternion) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n objectHandle : the handle of the object. \n relativeToObjectHandle : the handle of an object \nrelative to which the transformation is expressed. Otherwise, specify \nsimIK.handle_world if you specify the absolute transformation, or \nsimIK.handle_parent if you specify the transformation relative to the \nparent object. \n position : the position component of the transformation. \n eulerOrQuaternion : the orientation component of \nthe transformation. If 3 values are specified, then they will be \ninterpreted as Euler angles (alpha,beta,gamma). If 4 values are \nspecified, they will be interpreted as quaternion values (x,y,z,w). \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setObjectTransformation(int \nenvironmentHandle,int objectHandle,int relativeToObjectHandle,list \nposition,list eulerOrQuaternion) \n \n \n See also \n simIK.createEnvironment ,  simIK.getObjectTransformation ,  simIK.setObjectPose ,  simIK.setObjectMatrix ,  simIK.setJointPosition ,  simIK.getObjectHandle \n \n \n \n \n simIK.setSphericalJointMatrix \n \n \n Description \n Sets the rotation transformation matrix of a spherical joint. \n \n \n Lua synopsis \n simIK.setSphericalJointMatrix(int environmentHandle,int jointHandle,float[12] matrix) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n matrix : a table of 12 values representing the \ntransformation matrix (the last row of the 4x4 matrix (0,0,0,1) is \nomitted). The translation part in the matrix will be ignored. \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setSphericalJointMatrix(int environmentHandle,int jointHandle,list matrix) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointMatrix ,  simIK.setJointPosition ,  simIK.setSphericalJointRotation ,  simIK.getObjectHandle \n \n \n \n \n simIK.setSphericalJointRotation \n \n \n Description \n Sets the rotation transformation of a spherical joint. \n \n \n Lua synopsis \n simIK.setSphericalJointRotation(int environmentHandle,int jointHandle,float[] eulerOrQuaternion) \n \n \n Lua arguments \n \n environmentHandle : the handle of the environment. \n jointHandle : the handle of the joint. \n eulerOrQuaternion : the rotation transformation to \napply. If 3 values are specified, they will be interpreted as Euler \nangles (alpha,beta,gamma). If 4 values are specified, they will be \ninterpreted as quaternion values (x,y,z,w). \n \n \n \n Lua return values \n \n \n \n \n Python synopsis \n simIK.setSphericalJointRotation(int environmentHandle,int jointHandle,list eulerOrQuaternion) \n \n \n See also \n simIK.createEnvironment ,  simIK.getJointTransformation ,  simIK.setSphericalJointMatrix ,  simIK.setJointPosition ,  simIK.getObjectHandle \n \n \n \n \n , ", 'tags': '', 'url': 'simIKAPI.html'}, {'title': 'coppeliaKinematicsRoutines', 'text': '\n \n \n \n \n Coppelia Kinematics Routines \n The  Coppelia Kinematics Routines  is a collection of C++ functions that allow to solve forward/inverse kinematics tasks for any type of mechanism (redundant/non-redundant, containing nested loops, etc.). Those functions give CoppeliaSim its kinematics calculation capability. \n You can embedd and use the Coppelia Kinematics Routines in your stand-alone application, which then can programmatically set up complex kinematics tasks. Refer also to the  Coppelia Kinematics Routines C++ API documentation . \n The Coppelia Kinematics Routines source code is not directly part of CoppeliaSim, and carries separate licensing conditions. Refer to the source code for details, and  contact us . \n Following is a simple example how to set up an inverse kinematics task, and perform calculations from within an external application: \n \n#include "ik.h"\n\nint main(int argc, char* argv[])\n{\n    // Create the IK environment:\n    ikCreateEnvironment();\n\n    // Create a simple 3 DoF kinematic chain:\n    int tipHandle,targetHandle;\n    int joint1Handle,joint2Handle,joint3Handle;\n    ikCreateJoint(nullptr,ik_jointtype_revolute,&joint1Handle);\n    ikCreateJoint(nullptr,ik_jointtype_revolute,&joint2Handle);\n    C7Vector tr(C4Vector(1.57,0.0,0.0),C3Vector::zeroVector);\n    ikSetObjectTransformation(joint2Handle,-1,&tr);\n    ikSetObjectParent(joint2Handle,joint1Handle,true);\n    ikCreateJoint(nullptr,ik_jointtype_revolute,&joint3Handle);\n    tr.X=C3Vector(0.0,0.0,0.2);\n    ikSetObjectTransformation(joint3Handle,-1,&tr);\n    ikSetObjectParent(joint3Handle,joint2Handle,true);\n    ikCreateDummy(nullptr,&tipHandle);\n    tr.Q.clear();\n    tr.X=C3Vector(0.0,0.0,0.4);\n    ikSetObjectTransformation(tipHandle,-1,&tr);\n    ikSetObjectParent(tipHandle,joint3Handle,true);\n    ikCreateDummy(nullptr,&targetHandle);\n    ikSetObjectTransformation(targetHandle,-1,&tr);\n    ikSetLinkedDummy(tipHandle,targetHandle);\n    // we now have: joint1 --> joint2 --> joint3 --> tipDummy <...> targetDummy\n\n    // Create an IK group that constrains the chain tip to follow (in position)\n    // the target dummy:\n    int ikGroup;\n    ikCreateIkGroup(nullptr,&ikGroup);\n    int ikElementIndex;\n    ikAddIkElement(ikGroup,tipHandle,&ikElementIndex);\n    ikSetIkElementConstraints(ikGroup,ikElementIndex,ik_constraint_position);\n\n    ikGetObjectTransformation(targetHandle,-1,&tr);\n    while (true)\n    {\n        // Slightly move the target dummy:\n        tr.X=tr.X+C3Vector(0.001,0.002,-0.0001);\n        ikSetObjectTransformation(targetHandle,-1,&tr)\n\n        // Solve IK:\n        int result;\n        ikHandleIkGroup(ikGroup,&result);\n        if (result==ik_result_fail)\n            break;\n\n        // Read joint values:\n        simReal joint1Angle,joint2Angle,joint3Angle;\n        ikGetJointPosition(joint1Handle,&joint1Angle);\n        ikGetJointPosition(joint2Handle,&joint2Angle);\n        ikGetJointPosition(joint3Handle,&joint3Angle);\n    }\n    return(0);\n} \n \n \n \n \n', 'tags': '', 'url': 'coppeliaKinematicsRoutines.html'}, {'title': 'CoppeliaKinematicsRoutinesAPI', 'text': 'Please follow  this link .', 'tags': '', 'url': 'CoppeliaKinematicsRoutinesAPI.html'}, {'title': 'dynamicsModule', 'text': "\n \n \n \n \n Dynamics \n CoppeliaSim's dynamics module currently supports four different physics engines: the  Bullet physics library , the  Open Dynamics Engine ,  the  Vortex Studio engine  and the  Newton Dynamics engine . At any time, the user is free to quickly switch from one engine to the other according to his/her  simulation  needs. The reason for this diversity in physics engine support is that physics simulation is a complex task, that can be achieved with various degrees of precision, speed, or with support of diverse features: \n Bullet physics library : an open source physics engine featuring 3D collision detection, rigid body dynamics, and soft body dynamics (feature that is currently not supported in CoppeliaSim). It is used in games, and in visual effects in movies. It is often considered as a  game physics engine . \n \n [Bullet Physics] \n \n Open Dynamics Engine (ODE) : an open source physics engine with two main components: rigid body dynamics and collision detection. It has been used in many applications and games. It is often considered as a  game physics engine . \n \n [Open Dynamics Engine] \n \n Vortex® Studio : a closed source, commercial physics engine producing high fidelity physics simulations. Vortex offers real-world parameters (i.e. corresponding to physical units) for a large number of physical properties, making this engine both realistic and precise. Vortex is mainly used in high performance/precision industrial and research applications. The Vortex plugin for CoppeliaSim is based on  Vortex Studio , which requires each user to  register with CM Labs , for a free license key. \n \n [Vortex Studio] \n \n Newton Dynamics : Newton Dynamics is a cross-platform life-like physics simulation library. It implements a deterministic solver, which is not based on   traditional LCP or iterative methods, but possesses the stability and   speed of both respectively. This feature makes Newton Dynamics a tool   not only for games, but also for any real-time physics simulation. Current plugin implementation is a BETA version. \n \n [Newton Dynamics] \n \n The dynamics module allows simulating interactions between  objects  that are near to real-world object interactions. It allows objects to fall, collide, bounce back, but it also allows a manipulator to grasp objects, a conveyor belt to drive parts forward, or a vehicle to roll in a realistic fashion over uneven terrain. Following figures illustrate a dynamic simulation: \n \n \n [Dynamic simulation] \n \n Unlike many other simulation software packages, CoppeliaSim is not a  pure  dynamics simulator. It can rather be seen as a hybrid simulator that combines kinematics and dynamics in order to obtain the best performance for various simulation scenarios. Nowadays, physics engines are still relying on many approximations and are relatively imprecise and slow, and wherever possible you should try to use kinematics instead (e.g. for robotic manipulators) and only rely on dynamics where otherwise not feasible (e.g. a robotic manipulator's gripper). If you are simulating a mobile robot that is not supposed to collide or physically interact with its environment (which most mobile robots are anyway very rarely supposed to do) and that is operating exclusively on flat ground (which groups the vast majority of mobile robots), then try rather using kinematic or geometric calculations to simulate the robot's movement. The result will be faster and more accurate. \n \n \n \n \n \n", 'tags': '', 'url': 'dynamicsModule.html'}, {'title': 'designingDynamicSimulations', 'text': '\n \n \n \n \n Designing dynamic simulations \n In CoppeliaSim, only a limited number of  objects  will be dynamically simulated. Those are  shapes ,  joints  and  force sensors , but it will depend on the  scene  structure and object properties, whether a given object will be dynamically simulated. Dynamically simulated objects can be easily recognized during  simulation , since following icon will appear next to the object\'s alias in the  scene hierarchy : \n \n \n [Icon marking dynamically simulated objects] \n \n Double-clicking the icon in the scene hierarchy (during simulation only) will display some information related to the object\'s dynamic behavior. Objects that are supposed to by dynamically simulated but which, for a reason or another cannot be dynamically simulated, will display following icon instead: \n \n \n [Warning icon when an object cannot be dynamically simulated] \n \n \n Static/non-static,  respondable/non-respondable shapes\n \n \n Shapes  can be classified into 4 types depending on their behavior during dynamic simulation:  \n \n [Dynamic simulation main shape types] \n \n During dynamic simulation, static shapes will not be influenced (i.e. their position relative to their parent object is fixed), whereas non-static shapes will be directly influenced by gravity or other constraints (e.g. dynamically enabled joints, see hereafter). Respondable shapes influence each other during dynamic collision (i.e. they produce a mutual  collision reaction , they will bounce off each other). Following figure illustrates the static/non-static, respondable/non-respondable behaviors: \n \n \n [Static/non-static, respondable/non-respondable shape behaviors and interactions] \n \n Two respondable shapes will always produce a collision reaction, unless their respective collision masks don\'t overlap. Static/non-static, respondable/non-respondable shape properties, as well as collision masks can be set in the  shape dynamics properties  dialog. \n \n \n \n Simple constraints between shapes or force sensors\n \n Non-static shapes will fall (i.e. be influenced by gravity) if they are not otherwise constrained. Dynamic constraints between shapes can be set-up by attaching two shapes together via a  dynamically enabled   joint , a  dynamically enabled   force sensor , or via a  dummy -dummy  dynamic overlap constraint .  \n Following represent a simple constraint between two shapes: \n \n [Dynamically enabled joint or force sensor] \n \n Above joint is considered to be dynamically enabled. \n \n \n Loop closures and other constraints\n \n Sometimes a mechanism displays loops, e.g. in parallel machines, and other times additional rigid constraints between shapes are required. In those situations, special dummy-dummy  dynamic overlap constraints  can be introduced:  \n \n [Dynamic overlap constraint involving a joint or force sensor] \n \n Above joint is also considered to be dynamically enabled.  \n Following represents a rigid constraint between two shapes, that do not have to be in the same hierarchy tree/branch: \n \n \n [Dynamic overlap constraint, that rigidly binds two shapes] \n \n \n Rigid compounds\n \n Two non-static  shapes  that are not linked through dynamically enabled joints or force sensors will move independently from each other during dynamic simulation. If you want two or more shapes to behave as one single shape, you will have to group them (Menu Bar --> Edit --> Grouping/Merging --> Group selected shapes). Make sure you adjust the moment of inertia of the final shape appropriately. Make sure you also read the  section about pure shapes  further down: \n \n \n [Compound of several non-static shapes to obtain a single non-static shape] \n \n Compound shapes will behave as a rigid entity and also share identical dynamic properties (e.g. friction coefficient). Sometimes a rigid entity with differentiated dynamic properties is needed. In that case, shapes can be rigidly linked via a force sensor. \n \n \n Design consideration 1\n \n Use pure shapes.  Whenever possible, try using  pure shapes  as respondable shapes: pure shapes are much more stable and faster during dynamic simulation. Instead of using the complicated triangular mesh of a robot model as respondable shape, or its slightly better convex representation, try approximating the triangular mesh with several pure shapes, then grouping them [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes] (beware that if you merge pure shapes instead of grouping them, the resulting shape will not be a pure shape anymore). Following figure illustrates a robot\'s hidden respondable pure shapes: \n \n \n [Dynamic robot model (left) and underlying pure non-static shapes used for dynamic simulation (right)] \n \n A convenient way to extract pure shapes from complex non-pure shapes, is to enter the  triangle edit mode  for the complex shape, then selecting regions of interest and extracting rectangular, spherical or cylindrical pure shapes. Refer to the  Extract cuboid ,  Extract cylinder , and  Extract sphere  buttons in the triangle edit mode. It is also always good practice to visualize and verify a scene\'s dynamic content using the dynamic content visualization toolbar button (see the  design consideration 3 ).  \n When a body can collide, but not constantly, or does not play a important role in the stability of a mechanism/robot, then it is not absolutely necessary to use pure shapes, and convex shapes could be a viable alternative too: \n \n \n Design consideration 2\n \n Use convex shapes instead of random shapes.  Whenever possible, try using  pure shapes  as respondable shapes (see  design consideration 1 ). This is however not always easy to do, or practical (think of a torus for instance). In that case, you can generate a convex shape, or a convex decomposed shape (i.e. a simple/compound shape containing only convex meshes). Convex shapes perform faster and are more stable than random shapes (but they are still not as fast and stable as pure shapes!). \n Select the shapes you wish to simplify as convex shapes, then select [Menu bar --> Edit --> Morph selected shapes into convex shapes...].  Refer also to the item [Menu bar --> Add --> Convex decomposition of selected shapes...]. Following figure illustrates a convex decomposition: \n \n \n [Non-convex model (left) and corresponding convex-decomposed model (right)] \n \n \n Design consideration 3\n \n Carefully inspect the dynamic content of a scene . It can sometimes be a little bit confusing to work with hidden shapes meant to play an active role in the simulation. This is often the case with dynamically enabled shapes, joints or force sensors: indeed, they are most of the time hidden to the viewer\'s eye. The dynamic content can however always be inspected DURING a simulation, by activating the dynamic content visualization button:  \n \n [Dynamic content visualization button] \n \n \n [Normal and "dynamic content" scene visualization] \n \n Dynamic objects will appear in various colors, depending on their function or settings. Refer to following figure:\n \n \n [Color coding for dynamic objects (in dynamic content visualization mode)] \n \n Notice in above\'s figure the appearance of non-pure shapes: they have their triangular mesh contour represented in green or grey color. Dynamically simulated non-pure shapes should be avoided at all cost, since they require much longer calculation times, and present a not very stable behaviour (convex shapes are however faster and more stable than non-convex shapes). Refer also to the  design consideration 1  here above.  \n \n \n Design consideration 4\n \n Use a simple hierarchical structure . When building a model that is meant to be simulated dynamically, attach all non-dynamic objects to the dynamic objects (non-static shapes and dynamically enabled joints). Above\'s wheeled robot model is illustrated in following figure: \n \n \n [Dynamic elements in a robot model] \n \n \n \n Design consideration 5\n \n Carefully chose the model base object . When building a dynamic  model , actually also when building a static model, always carefulls consider what role the model will be playing. Will it be used on its own? Can it be built on top of another model or object? Or can it accept other models or objects to be built on top of it? Consider following example: \n You have created a model of a mobile robot. You have also created a model of a gripper. Clearly you want to be able to easily attach the gripper model on top of the robot model. The other way round will never make sense (attaching the robot model on top of the gripper model). You might also want to use the robot model and the gripper model on their own. Following is the view of the  scene hierarchy  of a possible model definition: \n \n [Example model definition of a robot and a gripper] \n \n \nNotice the model icon next to the \'robot\' and \'gripper\' shape objects. This indicates that all objects built on top of them are part of the same model definition. The two models operate well on their own. However if you try to attach the gripper on top of the robot (by selecting the gripper model, then the robot model, then clicking [Menu bar --> Edit --> Make last selected object parent]), the gripper will not be staying fixed on the robot during simulation. Following is the scene hierarchy of above two models, where the gripper has been attached to the robot:\n \n \n [Non-functional robot-gripper model assembly] \n \n \nNotice in above scene hierarchy how the  pure shape  "gripper" is built on top of the pure shape "robot". And remember that non-static shapes will fall if not otherwise constrained by a  joint  of  force sensor ... exactly, we need a force sensor in-between "gripper" and "robot" in order to have a rigid connection between both! \n The correct model definition of the robot would have to include an attachment point (or several of them) for the gripper as illustrated in following figure: \n \n [Example model definition of a robot with an attachment point] \n \n \nThe attachment point is a simple force sensor. Assembling the gripper model with the robot model above  results in a gripper that stays fixed relative to the robot: \n \n [Functional robot-gripper model assembly] \n \n  To simplify the assembly procedure even more, you can customize the behaviour of the  assembling  toolbar button , in order to automatically put the gripper onto the attachment point, with the correct relative position/orientation. For further details refer to the  section on models  and the dialog item  Assembling  in the  object common properties . \n \n \n Design consideration 6\n \n Use reasonable sizes . Shapes that are very long and thin, or that are too small might behave strangely (jittering, jumping). Try keeping sizes above 3 centimeters if possible. Otherwise you can adjust the internal scaling parameter in the  dynamics engines general properties  dialog. \n This requirement can be loosened by using a different engine, or by selecting a more precise  dynamics configuration mode . \n \n \n \n Design consideration 7\n \n Keep masses similar and not too light . When linking two shapes with a dynamically enabled joint or a dynamically enabled force sensor, make sure the two shape\'s masses are not too different (m1<10*m2 and m2<10*m1), otherwise the joint or force sensor might be very  soft  and  wobbly  and present large positional/orientational errors (this effect can however also be used as a  natural damping  sometimes). Additionally, very low mass shapes should be avoided since they won\'t be able to exert very large forces onto other shapes (even if propelled by high force actuators!). \n This requirement can be loosened by using a different engine, or by selecting a more precise  dynamics configuration mode . \n \n \n \n Design consideration 8\n \n Keep principal moments of inertia* relatively large . Try keeping the  principal moments of inertia / mass  (*refer to the  shape dynamics properties  dialog) relatively large, otherwise mechanical chains might be difficult to control and/or might behave in a strange way. \n This requirement can be loosened by using a different engine, or by selecting a more precise  dynamics configuration mode . \n \n \n \n Design consideration 9\n \n Assign dynamic shapes to layer 9 . Assign all dynamic shapes which are supposed to be hidden to layer 9 (refer to the  object common properties ): in CoppeliaSim, by default, all layers are visible, except for layers 9-16. When editing or testing a  scene , you can then quickly visualize all hidden  shapes in the scene by temporarily enabling layer 9 (refer also to the  layer selection dialog ). \n \n \n \n Design consideration 10\n \n Never have a static shape between two dynamic items . The static shape will interrupt the logical behaviour of the dynamic chain: \n \n [Wrong and correct construction] \n \n \n Design consideration 11\n \n Never have a static respondable shape on top of a dynamic item . Static means the shape\'s trajectory cannot be influenced by any collision, but if at the same time it is respondable, this means that it can itself influence other shapes\' trajectories via collision. The simulation result would be unpredictable. \n \n \n \n \n \n', 'tags': '', 'url': 'designingDynamicSimulations.html'}, {'title': 'dynamicsDialog', 'text': "\n \n \n \n \n General dynamics properties \n The general dynamics properties  dialog is ocated at [Menu bar --> Tools --> Dynamics properties]. You can also open the dialog with a click on its  toolbar  button: \n \n \n [Dynamics properties toolbar button] \n \n \n [Dynamics properties dialog] \n \n Dynamics enabled : allows enabling/disabling dynamics calculations for the entire  scene . \n \n Engine to use : the dynamics engine to use. Bullet stands for the  Bullet physics library , ODE for the  Open Dynamics Engine , Vortex for the  Vortex Studio engine  and Newton for the  Newton Dynamics engine . Each engine has specific strengths and weaknesses. A  simulation  running fine with one engine doesn't always mean that it will also run fine with the other engines. Each engine has specific parameters that can be set globally (see  Adjust engine parameters  hereafter) or locally (in the  material properties  or in the  dynamics engines properties dialog related to joints ). Make sure you read the respective engine documentations to achieve best parameter settings. \n \n Display contact points : allows displaying contact points between respondable  shapes . \n \n Adjust engine parameters : opens the  dynamics engines general properties  dialog, which allows adjusting engine-specific global parameters. \n \n Gravity : the amplitude and direction of a constant force applied to all non-static shapes (e.g. gravity). \n \n \n \n \n \n", 'tags': '', 'url': 'dynamicsDialog.html'}, {'title': 'dynamicsEngineDialog', 'text': "\n \n \n \n \n Dynamics engines general properties \n The dynamics engines general properties dialog is part of the  general dynamics properties  dialog. The dialog displays the engine configurations and various engine specific global properties. In the  general dynamics properties  dialog, click the  Adjust engine parameters  button to open following dialog: \n \n [Dynamics engines general properties dialog] \n \n Each engine has specific parameters that can be set globally (see hereafter) or locally (in the  material properties  or in the  dynamics engines properties related to joints ).  \n Configuration mode : allows to quickly switch between predefined or custom configurations for the dynamics engines. It is however recommended to keep the default configuration to avoid possible compatibility issues between models requiring different modes to run properly. \n \n \n \n Bullet properties\n \n Properties related to the  Bullet physics library . Make sure to also refer to the  Bullet user manual  for details. \n Bullet time step : specifies the desired time step for dynamics calculations. It is highly recommended to keep a time step of 5ms (default). Combined with a  simulation time step  of 50ms, this results in 10 dynamics calculation steps per  simulation pass . \n Constraint solver type : the type of solver to be used. \n Constraint solving iterations : specifies the number of iterations that will be used to solve constraints (large values usually result in slower but more precise simulations (generally)). \n Internal scaling : specifies how dimensions are handled internally. If your dynamic scene is composed by small (<3 cm) or very large shapes, you can improve simulation stability by adjusting the scaling factor. This is particularly true for the Bullet engine. When  Full scaling  is enabled, dimension-related values as well as mass-related values are scaled, otherwise, only dimension-related values are scaled. \n Collision margin scaling : specifies how collision margins are scaled in relation to the internal scaling parameter. Following relationship is applied: new collision margin = Bullet collision margin * internal scaling * collision margin scaling. This setting can be overridden on a shape-basis (refer to the  material properties ). \n \n \n \n ODE properties\n \n Properties related to the  Open Dynamics Engine . Make sure to also refer to the  ODE user manual  for details. \n ODE time step : specifies the desired time step for dynamics calculations. It is highly recommended to keep a time step of 5ms (default). Combined with a  simulation time step  of 50ms, this results in 10 dynamics calculation steps per  simulation pass . \n Use 'quickStep' : when selected, a fast iterative solving method will be used. The larger the  QuickStep iterations  property, the more precise the calculations (generally). When the quickStep method is not selected, calculations can be more precise and faster for small systems. Larger systems can however be very slow, unstable and can lead to sudden crashes! \n Internal scaling : specifies how dimensions are handled internally. If your dynamic scene is composed by small (<3 cm) or very large shapes, you can improve simulation stability by adjusting the scaling factor. When  Full scaling  is enabled, dimension-related values as well as mass-related values are scaled, otherwise, only dimension-related values are scaled. \n Global ERP : the global Error Reduction Parameter, refer to the ODE documentation for more details. \n Global CFM : the global Constraint Force Mixing, refer to the ODE documentation for more details. \n \n \n \n Vortex properties\n \n Properties related to the  Vortex Studio engine . Make sure to also refer to the  Vortex user manual  for details. \n Vortex time step : specifies the desired time step for dynamics calculations. It is highly recommended to keep a time step of 5ms (default). Combined with a  simulation time step  of 50ms, this results in 10 dynamics calculation steps per  simulation pass . \n Contact tolerance : epsilon distance considered during collision    detection. \n Auto-sleep :  if enabled, non-moving rigid bodies will be disabled until an event wakes them    up again. \n Multithreading : enables multi-threaded algorithms for dynamics and collision processes. \n Constraint properties : provides threshold values for constraint compliance,    damping and viscosity for each constraint equation. \n Linear compliance : threshold compliance (1/stiffness) for linear position-based    equation like a spring. \n Linear damping : threshold damping for linear position-based equation    like a spring. \n Linear kinetic loss : threshold viscosity for linear velocity-based    equation (like friction).  \n Angular compliance : threshold compliance (1/stiffness) for orientation-based    equation. \n Angular damping : threshold damping for orientation-based equation. \n Angular kinetic loss : threshold viscosity for orientation velocity-based equation. \n \n \n \n Newton properties\n \n Properties related to the  Newton Dynamics Engine . Make sure to also refer to the  Newton user manual  for details. \n Newton time step : specifies the desired time step for dynamics calculations. It is highly recommended to keep a time step of 5ms (default). Combined with a  simulation time step  of 50ms, this results in 10 dynamics calculation steps per  simulation pass . \n Constraint solving iterations : specifies the number of iterations that will be used to solve constraints (large values usually result in slower but more precise simulations (generally)). \n Multithreading : enables multi-threaded algorithms for dynamics and collision processes. \n Exact solver :  if enabled, a more precise solver will be used, which might however induce instabilities. \n High joint accuracy :  if enabled, a more precise joint solver will be used, which might however induce instabilities. \n Contact merge tolerance : the distance threshold where close contact points will be merged into one single contact point. \n \n \n \n Vortex additional information\n \n Use the engine constraint properties to make all the constraints softer and consequently help avoiding numerical instability. For simulation involving very large masses, it is possible that the constraint relaxation has to be reduced. Those parameters are global and affect all constraints and collision contacts. For individual constraint relaxation you can refer to the constraint parameters directly where each constraint equation may be relaxed independently. For instability due to collision, it is possible to use skin thickness to smooth normal response or to increase the slip parameters in order to add viscosity in the contact friction. For chains of light rigid bodies and constraints subjected to large tension such as an hand mechanism grasping objects order of magnitude larger than the fingers, the use of angular velocity damping will help increasing the simulation robustness. \n \n \n \n \n", 'tags': '', 'url': 'dynamicsEngineDialog.html'}, {'title': 'dataVisualizationAndOutput', 'text': '\n \n \n \n \n Data visualization/output \n Data in CoppeliaSim can be visualized or output/logged in various ways: \n web-browser based front-end \n visualizing data in  graphs \n displaying data in  custom user interfaces \n augmenting the scene with visual items \n logging data to the status bar via the simple  print  command \n logging data to the status bar and/or terminal via the  sim.addLog  API function \n logging data to a file \n Following example illustrates how to display a joint angle in a simple custom user interface: \n \nfunction sysCall_init()\n    jointHandle=sim.getObject(\'/Joint\')\n    local xml =[[<ui title="Example" closeable="false" layout="form">\n        <label text="joint angle:" />\n        <label id="1" text="-" />\n        </ui>]]\n    ui=simUI.create(xml)\nend\n\nfunction sysCall_sensing()\n    local v=180*sim.getJointPosition(jointHandle)/math.pi\n    simUI.setLabelText(ui,1,string.format(\'%.3f\',v))\nend\n\nfunction sysCall_cleanup()\n    simUI.destroy(ui)\nend \n \n Augmenting the scene with visual items\n \n Simple visual items such as points, lines, spheres or individual triangles can easily be added to the scene via API functions  sim.addDrawingObject  and  sim.addDrawingObjectItem , for example: \n \nfunction sysCall_init()\n    local drawingObject=sim.addDrawingObject(sim.drawing_spherepts,0.005,0,-1,1000,{1,0,0})\n    for i=0,359,1 do\n        local coord={math.cos(i*math.pi/180),math.sin(i*math.pi/180),0.01}\n        sim.addDrawingObjectItem(drawingObject,coord)\n    end\nend \n More complex items, such as random meshes can be created on the fly via  sim.loadModel ,  simAssimp.importShapes ,  sim.createPrimitiveShape ,  sim.createMeshShape  and/or  sim.copyPasteObjects . To avoid surcharching the scene with too many additional objects, make sure to group them with  sim.groupShapes . For example: \n \nfunction sysCall_init()\n    local individualShapes={}\n    for i=0,359,1 do\n        local shape=sim.createPrimitiveShape(sim.primitiveshape_cylinder,{0.005,0.005,0.02})\n        local coord={math.cos(i*math.pi/180),math.sin(i*math.pi/180),0.01}\n        sim.setObjectPosition(shape,-1,coord)\n        sim.setShapeColor(shape,nil,sim.colorcomponent_ambient_diffuse,{1,0,0})\n        individualShapes[i+1]=shape\n    end\n    -- Group individual shapes:\n    local masterShape=sim.groupShapes(individualShapes,true)\n    -- Make it invisible to collision detection, sensors, etc.:\n    sim.setObjectSpecialProperty(masterShape,0)\nend \n \n \n Logging data to a file\n \n Following example illustrates how to log a joint angle to a file: \n \nfunction sysCall_init()\n    jointHandle=sim.getObject(\'/Joint\')\n    file=io.open(\'jointAngles.txt\',\'w+\')\n    file:write(\'Joint angles for each simulation step:\\n\\n\')\nend\n\nfunction sysCall_sensing()\n    local v=180*sim.getJointPosition(jointHandle)/math.pi\n    file:write(string.format(\'time: %.3f [s]\',sim.getSimulationTime()+sim.getSimulationTimeStep()))\n    file:write(string.format(\', joint angle: %.1f [deg]\\n\',v))\nend\n\nfunction sysCall_cleanup()\n    file:close()\nend \n \n \n \n \n', 'tags': '', 'url': 'dataVisualizationAndOutput.html'}, {'title': 'externalFrontEnd', 'text': '\n \n \n \n \n Web-browser based front-end \n  The callback function  sysCall_event  and the  sim.getGenesisEvents  API function allow tracking most changes that happen in CoppeliaSim, and by correctly publishing and interpreting them, one can easily implement an external front-end for CoppeliaSim. This is what the  Three.js front-end for CoppeliaSim  does: \n \n [Three.js front-end, and corresponding CoppeliaSim instance] \n \n To enabled it, enable first the visualization stream add-on via [Menu bar --> Modules --> Connectivity --> Visualization stream], then open a web-browser and type http://127.0.0.1:23020 \n \n \n \n \n', 'tags': '', 'url': 'externalFrontEnd.html'}, {'title': 'dataTransformation', 'text': "\n \n \n \n \n Data manipulation/transformation \n Data in CoppeliaSim can transformed in various ways: \n data packing/unpacking \n linear algebra functionality \n image processing \n path data transformation \n sim.transformBuffer \n other  matrix/transformation related functions \n Following example illustrates how to pack/unpack data. Other functions can be found here: \n \n-- Packing/unpacking specific type of data:\nlocal data={1,2,3}\nlocal binaryPackedData=sim.packDoubleTable(data) -- binary packing\ndata=sim.unpackDoubleTable(binaryPackedData) -- binary unpacking\n\nbase16=require('base16')\nlocal base16PackedData=base16.encode(binaryPackedData) -- base16 encoding\nbinaryPackedData=base16.decode(base16PackedData) -- base16 decoding\n\nbase64=require('base64')\nlocal base64PackedData=base64.encode(binaryPackedData) -- base64 encoding\nbinaryPackedData=base64.decode(base64PackedData) -- base64 decoding\n\nlocal base64Buffer=sim.transformBuffer(binaryPackedData,sim.buffer_uint8,1,0,sim.buffer_base64)\nlocal originalBuffer=sim.transformBuffer(base64Buffer,sim.buffer_base64,1,0,sim.buffer_uint8)\n\n\n-- Packing/unpacking random data:\nlocal data={1,'hello',{value='world'},{1,{2,3}}}\nlocal binaryPackedData=sim.packTable(data) -- binary packing\ndata=sim.unpackTable(binaryPackedData) -- binary unpacking\n\ncbor=require('cbor')\nlocal cborPackedData=cbor.encode(data) -- cbor encoding\ndata=cbor.decode(cborPackedData) -- cbor decoding\n\n \n More packing/unpacking functions can be found  here . \n \n Following example illustrates usage of the linear algebra functionality: \n \n-- Get the absolute transformation matrices of an object and its parent:\nlocal absObj=Matrix4x4:frompose(sim.getObjectPose(objectHandle,-1))\nlocal absParentObj=Matrix4x4:frompose(sim.getObjectPose(parentHandle,-1))\n\n-- Compute the relative transformation matrix of the object:\nlocal relObj=Matrix4x4:inv(absParentObj)*absObj\n\n-- Get the relative transformation matrix of the object directly:\nlocal relObj2=Matrix4x4:frompose(sim.getObjectPose(objectHandle,parentHandle))\n\n-- Check that both matrices are same:\nprint(relObj:sub(relObj2):abs():max()) \n The documentation for the linear algebra functionality can be found  here . \n \n \n \n \n", 'tags': '', 'url': 'dataTransformation.html'}, {'title': 'meansOfCommunication', 'text': '\n \n \n \n \n Messaging/interfaces/connectivity \n There are several ways messages or data can be exchanged/transmitted/received in and around CoppeliaSim. \n  One can exchange data within CoppeliaSim, via: \n signals \n custom data blocks \n calling plugin functions \n calling script functions \n broadcasting a message \n Data can also be exchanged with an external application, other computer, machine, etc., via: \n calling script functions \n broadcasting a message \n Remote API \n ROS \n ZeroMQ \n WebSocket \n serial port \n sockets \n other \n \n \n Signals \n Signals  can be seen as global variables. They can be defined, redefined, read and cleared. For example: \n \n-- script 1 writes the data to string signal  mySignalName :\n\nlocal myData={1,2,{"Hello","world",true,{value1=63,value2="aString"}}}\nsim.setStringSignal("mySignalName",sim.packTable(myData)) \n \n-- script 2 reads the data from string signal  mySignalName :\n\nlocal myData=sim.getStringSignal("mySignalName")\nif myData then\n    myData=sim.unpackTable(myData)\nend \n \n Custom data blocks \n Custom data blocks  is data that is stored inside of a  scene object , or inside a  scene . It can be used to store custom data to be saved together with a  model  or scene, but also as a means of communication. For example: \n \n-- script 1 writes the data to the scene:\n\nlocal myData={1,2,{"Hello","world",true,{value1=63,value2="aString"}}}\nsim.writeCustomDataBlock(sim.handle_scene,"myTag",sim.packTable(myData)) \n \n-- script 2 reads the data from the scene:\n\nlocal myData=sim.readCustomDataBlock(sim.handle_scene,"myTag")\nif myData then\n    myData=sim.unpackTable(myData)\nend \n \n \n Calling plugin functions\n \n Scripts  can call specific  plugin  functions, so-called callback functions: in order to be able to do this, the plugin must  first register its callback functions via  simRegisterScriptFunction . This is a convenient mechanism to extend CoppeliaSim\'s functionality, but can also be used for complex data exchange between scripts and plugins. Following illustrates a very simple plugin function and its registration: \n void myCallbackFunc(SScriptCallBack* p)\n{\n    int stack=p->stackID;\n    CStackArray inArguments;\n    inArguments.buildFromStack(stack);\n    \n    if ( (inArguments.getSize()>0)&&inArguments.isString(0) )\n    {\n        std::string tmp("we received a string: ");\n        tmp+=inArguments.getString(0);\n        simAddLog("ABC",sim_verbosity_msgs,tmp.c_str());\n        \n        CStackArray outArguments;\n        outArguments.pushString("Hello to you too!");\n        outArguments.buildOntoStack(stack);\n    }\n    else\n        simSetLastError("simABC.func","Not enough arguments or wrong arguments.");\n}\n\n// Somewhere in the plugin\'s initialization code:\nsimRegisterScriptCallbackFunction("simABC.func@ABC","string reply=simABC.func(string inputStr)",myCallbackFunc); \n \n Calling script functions\n \n A  script  function can obviously be called from within the same script, but also: \n across scripts (via  sim.callScriptFunction ) \n from a plugin (via  simCallScriptFunctionEx ) \n from a  ROS  client (via a callback mechanism)\n or from a  remote API  client \n The called script function can perform various tasks, then send back data to the caller. This is also a simple way to extend the functionality of an external application in a quick manner. It is however important that the called script doesn\'t perform lengthly tasks, otherwise everything will come to a halt (lengthly tasks should rather be triggered externally, and processed at an appropriate moment by the script itself when called from the regular  system callbacks ). \n \n Broadcasting messages\n \n A  script  or a  remote API  client can broadcast a message to all scripts at once, via the  sim.broadcastMsg  function. For instance, following will constantly broadcast a message to all scripts, including to itself: \n \nfunction sysCall_init()\n    scriptHandle=sim.getScriptInt32Param(sim.handle_self,sim.scriptintparam_handle)\nend\n\nfunction sysCall_sensing()\n    local message={id=\'greetingMessage\',data={msg=\'Hello!\'}}\n    sim.broadcastMsg(message)\nend\n\nfunction sysCall_msg(msg,origin)\n    if origin~=scriptHandle and msg.id==\'greetingMessage\' then\n        print(string.format("Received following message from script %i:",origin))\n        print(msg.data.msg)\n    end\nend \n \n ZMQ\n \n The  ZeroMQ library , wrapped inside the  ZMQ plugin , offers several  API functions related to ZeroMQ messaging . Following illustrates a simple requester: \n \nfunction sysCall_init()\n    corout=coroutine.create(coroutineMain)\nend\n\nfunction sysCall_actuation()\n    if coroutine.status(corout)~=\'dead\' then\n        local ok,errorMsg=coroutine.resume(corout)\n        if errorMsg then\n            error(debug.traceback(corout,errorMsg),2)\n        end\n    end\nend\n\nfunction coroutineMain()\n    printf(\'Connecting to hello world server...\')\n    context=simZMQ.ctx_new()\n    requester=simZMQ.socket(context,simZMQ.REQ)\n    simZMQ.connect(requester,\'tcp://localhost:5555\')\n\n    for request_nbr=0,10 do\n        print(\'-----------------------------------------\')\n        local data=\'Hello\'\n        printf(\'[requester] Sending "%s"...\',data)\n        simZMQ.send(requester,data,0)\n        local rc,data=simZMQ.recv(requester,0)\n        printf(\'[requester] Received "%s"\',data)\n    end\nend\n\nfunction sysCall_cleanup()\n    simZMQ.close(requester)\n    simZMQ.ctx_term(context)\nend \n And following would be the corresponding responder: \n \nfunction sysCall_init()\n    corout=coroutine.create(coroutineMain)\nend\n\nfunction sysCall_actuation()\n    if coroutine.status(corout)~=\'dead\' then\n        local ok,errorMsg=coroutine.resume(corout)\n        if errorMsg then\n            error(debug.traceback(corout,errorMsg),2)\n        end\n    end\nend\n\nfunction coroutineMain()\n    context=simZMQ.ctx_new()\n    responder=simZMQ.socket(context,simZMQ.REP)\n    local rc=simZMQ.bind(responder,\'tcp://*:5555\')\n    if rc~=0 then error(\'failed bind\') end\n    \n    while true do\n        local rc,data=simZMQ.recv(responder,0)\n        printf(\'[responder] Received "%s"\',data)\n        data=\'World\'\n        printf(\'[responder] Sending "%s"...\',data)\n        simZMQ.send(responder,data,0)\n    end\nend\n\nfunction sysCall_cleanup()\n    simZMQ.close(responder)\n    simZMQ.ctx_term(context)\nend \n \n WebSocket\n \n The  WebSocket plugin , offers several  API functions allowing to interact with a web browser . Following is a simple echo server: \n \nfunction onMessage(server,connection,data)\n    simWS.send(server,connection,data)\nend\n\nfunction sysCall_init()\n    server=simWS.start(9000)\n    simWS.setMessageHandler(server,\'onMessage\')\nend \n And following is a simple broadcaster: \n \nfunction onOpen(server,connection)\n    clients[server]=clients[server] or {}\n    clients[server][connection]=1\nend\n\nfunction onClose(server,connection)\n    clients[server][connection]=nil\nend\n\nfunction broadcast(server,data)\n    for connection,_ in pairs(clients[server] or {}) do\n        simWS.send(server,connection,data)\n    end\nend\n\nfunction sysCall_init()\n    clients={}\n    server=simWS.start(9000)\n    simWS.setOpenHandler(server,\'onOpen\')\n    simWS.setCloseHandler(server,\'onClose\')\nend \n \n \n Serial port\n \n CoppeliaSim implements several  serial port API functions  for Lua. With Python, use the  Python serial port extension . \n \n \n Sockets\n \n CoppeliaSim ships with the  LuaSocket  extension library for Lua. Following illustrates how to fetch a webpage: \n \nhttp=require(\'socket.http\')\npage=http.request(\'http://www.google.com\') \n With Python, use the socket module: \n \nimport socket \n \n \n Other\n \n Many other means of communication can be directly supported from within a script, via a Lua extension library or via a Python extension. Indirectly, by passing via a  plugin , there are even more possibilities, since a plugin can virtually link to any type of c/c++ communication library. \n \n \n \n \n', 'tags': '', 'url': 'meansOfCommunication.html'}, {'title': 'remoteApiOverview', 'text': "\n \n \n \n \n Remote API \n The remote API is one of  several ways an application can connect with CoppeliaSim . It allows communication between CoppeliaSim and an external application (i.e. an application running in a different process, or on a different machine), is cross-platform, and supports the exact same API function calls as from within a CoppeliaSim script. It comes in two distinct versions/frameworks: \n The ZeroMQ remote API : with support of Python,  C++, Matlab, Octave, Java and Lua clients. \n The WebSocket remote API : with support of JavaScript clients. \n As an example, a Python ZeroMQ remote API client receiving and applying back a  vision sensor  image could look like: \n from time import sleep\nfrom zmqRemoteApi import RemoteAPIClient\nclient = RemoteAPIClient('localhost',23000)\nsim = client.getobject('sim')\nsensor1Handle=sim.getObject('/VisionSensor')\nsensor2Handle=sim.getObject('/PassiveVisionSensor')\n\nsim.startSimulation()\nwhile True:\n    image,resolution=sim.getVisionSensorImg(sensor1Handle)\n    sim.setVisionSensorImg(sensor2Handle,image)\n    sleep(0.01)\nsim.stopSimulation() \n \n (for backward compatibility, see  here  for the deprecated legacy remote API) \n \n \n \n \n", 'tags': '', 'url': 'remoteApiOverview.html'}, {'title': 'zmqRemoteApiOverview', 'text': '\n \n \n \n \n ZeroMQ remote API \n The ZeroMQ remote API is one of  several ways an application can connect with CoppeliaSim . \n The ZeroMQ remote API allows to control a simulation (or the simulator itself) from an external application or a remote hardware (e.g. real robot, remote computer, etc.). It offers all API functions also available via a CoppeliaSim script: this includes all  regular API functions  (i.e. sim.* -type functions), but also all API functions provided by  plugins  (e.g. simOMPL.*, simUI.*, simIK.*, etc.), if enabled. \n The ZeroMQ remote API functions are interacting with CoppeliaSim via  ZeroMQ  and its  interface plugin  to CoppeliaSim and the ZMQ remote API  add-on . All this happens in a hidden fashion to the user. The remote API can let one or several external applications interact with CoppeliaSim in a  stepped  (i.e.  synchronized  with each simulation step) or non-stepped way (i.e. the normal operation mode), and even remote control of the simulator is supported (e.g. remotely loading a scene, starting, pausing or stopping a simulation for instance). \n Note: the Python ZeroMQ remote API also runs on CoppeliaSim V4.2, if you follow this procedure: clone the  ZeroMQ remote API repository  into your  CoppeliaSim/programming  folder. Then use the  simAddOnZMQ remote API.lua   compatibility add-on and the  cbor.lua  script, and place them into your  CoppeliaSim/  and  CoppeliaSim/Lua  folders respectively. \n See programming/zmqRemoteApi folder or  its related repository  for examples. \n \n Python client \n ZeroMQ and CBOR are required packages: \n $ /path/to/python -m pip install pyzmq\n$ /path/to/python -m pip install cbor \n It is also helpful to have the location of the Python remote API items in either Python\'s sys.path, or in the PYTHONPATH environment variable: \n $ export PYTHONPATH=/path/to/zmqRemoteApi/clients/python \n Following is a very simple example ZeroMQ remote API client code, which starts then runs a  stepped  simulation for 3 seconds: \n import time\nfrom zmqRemoteApi import RemoteAPIClient\n\nclient = RemoteAPIClient()\nsim = client.getObject(\'sim\')\n\nclient.setStepping(True)\n\nsim.startSimulation()\nwhile (t := sim.getSimulationTime()) < 3:\n    s = f\'Simulation time: {t:.2f} [s]\'\n    print(s)\n    client.step()\nsim.stopSimulation() \n \n C++ client \n Any C++ client requires the  jsoncons  and  cppzmq  package: those are automatically downloaded and used when compiling via cmake. For details see  programming/zmqRemoteApi/clients/cpp/ , which contains several examples. \n  Build them with: \n $ mkdir build\n$ cd build\n$ cmake -DGENERATE=OFF ..\n$ cmake --build . --config Release \n \n Following is a very simple C++ ZeroMQ remote API client code, which starts then runs a  stepped  simulation for 3 seconds: \n #include "RemoteAPIClient.h"\n\nint main(int argc,char* argv[])\n{\n    RemoteAPIClient client;\n    auto sim = client.getObject().sim();\n    \n    client.setStepping(true);\n\n    sim.startSimulation();\n    double t=0.0;\n    do\n    {\n        t=sim.getSimulationTime();\n        printf("Simulation time: %.2f [s]\\n",t);\n        client.step();\n    } while (t<3.0);\n    sim.stopSimulation();\n    return(0);\n} \n \n Matlab & Octave clients \n Matlab clients require the bundled  JeroMQ , which installs automatically if not yet present. \n Octave clients require Octave 6.4+, the octave communications and zeromq packages. Those can be installed with: \n pkg install -forge communications\npkg install -forge zeromq \n \n Following is a very simple Matlab/Octave ZeroMQ remote API client code, which starts then runs a  stepped  simulation for 3 seconds: \n client = RemoteAPIClient();\nsim = client.getObject(\'sim\');\n\nclient.setStepping(true);\n\nsim.startSimulation();\nwhile true\n    t = sim.getSimulationTime();\n    if t >= 3; break; end\n    fprintf(\'Simulation time: %.2f [s]\\n\', t);\n    client.step();\nend\nsim.stopSimulation(); \n \n Lua client \n Currently, a Lua client is only supported from within a CoppeliaSim script, e.g. in order to connect 2 or more CoppeliaSim instances. \n Following is a very simple Lua ZeroMQ remote API client code, which synchronizes the simulation steps with another CoppeliaSim instance: \n function sysCall_init()\n    remoteApiClient=require\'luaZmqRemoteApi\'\n    remoteApiClient.init(\'127.0.0.1\',23002)\n    simx=remoteApiClient.getObject(\'sim\')\n    \n    remoteApiClient.setStepping(true)\n    simx.startSimulation()\nend\n\nfunction sysCall_sensing()\n    remoteApiClient.step()\nend\n\nfunction sysCall_cleanup()\n    simx.stopSimulation()\n    remoteApiClient.cleanup()\nend \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'zmqRemoteApiOverview.html'}, {'title': 'wsRemoteApiOverview', 'text': '\n \n \n \n \n WebSocket remote API \n The WebSocket remote API is one of  several ways an application can connect with CoppeliaSim . \n The WebSocket remote API allows to control a simulation (or the simulator itself) from an external JavaScript application or remote client/server, via WebSocket. It offers all API functions also available via a CoppeliaSim script: this includes all  regular API functions  (i.e. sim.* -type functions), but also all API functions provided by  plugins  (e.g. simOMPL.*, simUI.*, simIK.*, etc.). The WebSocket remoteAPI represents a very thin wrapper around mentioned API functions, and can be used in a very similar way as from within a CoppeliaSim script. \n The WebSocket remote API functions are interacting with CoppeliaSim via WebSocket and its  interface plugin  to CoppeliaSim and the WS remote API  add-on . All this happens in a hidden fashion to the user. The remote API can let one or several external applications interact with CoppeliaSim in a  stepped  (i.e.  synchronized  with each simulation step) or non-stepped way (i.e. the normal operation mode), and even remote control of the simulator is supported (e.g. remotely loading a scene, starting, pausing or stopping a simulation for instance). \n Here a very simple WebSocket remote API example: \n const log = (what) => $(\'#log\').append(`${what}\\n`);\n(async () => {\n    var client = new RemoteAPIClient(\'localhost\', 23050, \'json\');\n    log(\'Connecting...\');\n    await client.websocket.open();\n    log(\'Getting proxy object "sim"...\');\n    var sim = await client.getObject(\'sim\');\n    log(\'Calling sim.getObject("/Floor")...\');\n    var [h] = await sim.getObject(\'/Floor\');\n    log(`Result: ${h}`);\n})();\n \n See programming/wsRemoteApi folder or  its related repository  for examples. \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'wsRemoteApiOverview.html'}, {'title': 'rosInterfaces', 'text': "\n \n \n \n \n ROS Interfaces \n There are several ROS interfaces available for CoppeliaSim. Each one offers a specific behaviour, feature, or a way to operate: \n The ROS Interface : the ROS Interface duplicates the C++ ROS API with a good fidelity. This makes it the ideal choice for very flexible communication via ROS, but might require a little bit more insight on the various messages and the way ROS operates. \n The ROS 2 Interface : the ROS 2 Interface duplicates the C++ ROS 2 API with a good fidelity. This makes it the ideal choice for very flexible communication via ROS 2, but might require a little bit more insight on the various messages and the way ROS 2 operates. \n ROS interfaces developed by others: those are not directly supported by us. For instance, the  CoppeliaSim ROS bridge . \n All ROS interfaces can normally operate side-by-side, but we highly recommend you to first try your hands on the  ROS Interface , since this is the most flexible and natural approach. The packages to the first two above listed ROS interfaces are located  here  and  here . Use the  catkin tools  to build those packages, otherwise you might run into difficulties. \n As an example, a  vision sensor  ROS2 publisher could look like: \n \nfunction sysCall_init()\n    visionSensor=sim.getObject('/Vision_sensor')\n\n    -- Enable an image publisher:\n    pub=simROS2.createPublisher('/image', 'sensor_msgs/msg/Image')\n    simROS2.publisherTreatUInt8ArrayAsString(pub)\nend\n\nfunction sysCall_sensing()\n    -- Publish the image of the vision sensor:\n    local img,resolution=sim.getVisionSensorImg(visionSensor)\n    data={}\n    data.header={stamp=simROS2.getTime(), frame_id='a'}\n    data.height=resolution[2]\n    data.width=resolution[1]\n    data.encoding='rgb8'\n    data.is_bigendian=1\n    data.step=resolution[1]*3\n    data.data=img\n    simROS2.publish(pub,data)\nend\n\nfunction sysCall_cleanup()\n    simROS2.shutdownPublisher(pub)\nend \n The subscriber on the other hand could look like: \n \nfunction sysCall_init()\n    -- Enable an image subscriber:\n    sub=simROS2.createSubscription('/image', 'sensor_msgs/msg/Image', 'image_callback')\n    simROS2.subscriptionTreatUInt8ArrayAsString(sub)\nend\n\nfunction image_callback(msg)\n    -- Here we have received an image\nend\n\nfunction sysCall_cleanup()\n    simROS2.shutdownSubscription(sub)\nend \n \n Also have a look at the  ROS tutorial  and the  external controller tutorial . \n \n \n \n \n", 'tags': '', 'url': 'rosInterfaces.html'}, {'title': 'rosInterf', 'text': "\n \n \n \n \n ROS Interface \n The ROS Interface is part of the  CoppeliaSim API framework  and  is courtesy of Federico Ferri. Make sure not to mix up the ROS Interface with the  RosPlugin , which is an older, deprecated interface in CoppeliaSim. The ROS Interface duplicates the C/C++ ROS API with a good fidelity. This makes it the ideal choice for very flexible communication via ROS. You can recognize ROS Interface API functions from the  simROS - prefix. \n ROS is a distributed pseudo operating system allowing for easy management and communication between multiple computers connected in a network. Please refer to the  official ROS documentation  for details about ROS. \n CoppeliaSim can act as a ROS node that other nodes can communicate with via ROS services, ROS publishers and ROS subscribers. \n The ROS Interface functionality in CoppeliaSim is enabled via a plugin:  libsimExtROS .* . The plugin can easily be adapted to your own needs. The plugin is loaded when CoppeliaSim is launched, but the load operation will only be successful if roscore was running at that time. Make sure to inspect CoppeliaSim's console window or terminal for details on plugin load operations. \n Have a look at following simulation scenes/model for a quick start with the ROS Interface: \n rosInterfaceTopicPublisherAndSubscriber.ttt \n controlTypeExamples/controlledViaRos.ttt \n models/tools/rosInterface helper tool.ttm  (model allowing to operate CoppeliaSim in  stepped mode , e.g. in order to manually step the simulation) \n Also have a look at the  ROS tutorial  and the  external controller tutorial . \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'rosInterf.html'}, {'title': 'ROSPluginAPIreference', 'text': '\n ROS Plugin API reference \n This plugin provides an interface with the ROS API \n simROS.advertise \n simROS.advertiseService \n simROS.call \n simROS.deleteParam \n simROS.getParamBool \n simROS.getParamDouble \n simROS.getParamInt \n simROS.getParamString \n simROS.getTime \n simROS.hasParam \n simROS.imageTransportAdvertise \n simROS.imageTransportPublish \n simROS.imageTransportShutdownPublisher \n simROS.imageTransportShutdownSubscriber \n simROS.imageTransportSubscribe \n simROS.publish \n simROS.publisherTreatUInt8ArrayAsString \n simROS.searchParam \n simROS.sendTransform \n simROS.sendTransforms \n simROS.serviceClient \n simROS.serviceClientTreatUInt8ArrayAsString \n simROS.serviceServerTreatUInt8ArrayAsString \n simROS.setParamBool \n simROS.setParamDouble \n simROS.setParamInt \n simROS.setParamString \n simROS.shutdownPublisher \n simROS.shutdownServiceClient \n simROS.shutdownServiceServer \n simROS.shutdownSubscriber \n simROS.subscribe \n simROS.subscriberTreatUInt8ArrayAsString \n \n \n \n simROS.advertise\n \n \n \n                                                    Description\n                                                 \n Advertise a topic and create a topic publisher. \n \n \n Lua synopsis \n string publisherHandle=simROS.advertise(string topicName, string topicType, int queueSize=1, bool latch=false) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n topicType  (string): topic type, e.g.: \'geometry_msgs::Twist\' \n \n queueSize  (int, default: 1): (optional) queue size \n \n latch  (bool, default: false): (optional) latch topic \n \n \n \n Lua return values \n \n publisherHandle  (string): a handle to the ROS publisher \n \n \n Python synopsis \n string publisherHandle=simROS.advertise(string topicName, string topicType, int queueSize=1, bool latch=false) \n \n \n \n \n                                                See also\n                                             \n   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString \n \n \n \n \n simROS.advertiseService\n \n \n \n                                                    Description\n                                                 \n Advertise a service and create a service server. \n \n \n Lua synopsis \n string serviceServerHandle=simROS.advertiseService(string serviceName, string serviceType, string serviceCallback) \n \n \n \n Lua parameters \n \n \n serviceName  (string): topic name, e.g.: \'/cmd_vel\' \n \n serviceType  (string): topic type, e.g.: \'geometry_msgs::Twist\' \n \n serviceCallback  (string): name of the callback \nfunction, which will be called with a single argument of type table \ncontaining the service request payload; it must return another table \ncontaining the response \n \n \n \n Lua return values \n \n serviceServerHandle  (string): a handle to the ROS service server \n \n \n Python synopsis \n string serviceServerHandle=simROS.advertiseService(string serviceName, string serviceType, string serviceCallback) \n \n \n \n \n                                                See also\n                                             \n   simROS.call   simROS.serviceClient   simROS.serviceClientTreatUInt8ArrayAsString   simROS.serviceServerTreatUInt8ArrayAsString   simROS.shutdownServiceClient   simROS.shutdownServiceServer \n \n \n \n \n simROS.call\n \n \n \n                                                    Description\n                                                 \n Call the service associated with this service client. \n \n \n Lua synopsis \n table result=simROS.call(string serviceClientHandle, table request) \n \n \n \n Lua parameters \n \n \n serviceClientHandle  (string): the service client handle \n \n request  (table): the message to publish \n \n \n \n Lua return values \n \n result  (table): the response message, if the call succeeded \n \n \n Python synopsis \n list result=simROS.call(string serviceClientHandle, list request) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertiseService   simROS.serviceClient   simROS.serviceClientTreatUInt8ArrayAsString   simROS.serviceServerTreatUInt8ArrayAsString   simROS.shutdownServiceClient   simROS.shutdownServiceServer \n \n \n \n \n simROS.deleteParam\n \n \n \n                                                    Description\n                                                 \n Delete a parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS.deleteParam(string name) \n \n \n \n Lua parameters \n \n name  (string): name of the parameter \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.deleteParam(string name) \n \n \n \n \n                                                See also\n                                             \n   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.getParamBool\n \n \n \n                                                    Description\n                                                 \n Retrieve a boolean parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, bool value=simROS.getParamBool(string name, bool defaultValue=false) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (bool, default: false): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (bool): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, bool value=simROS.getParamBool(string name, bool defaultValue=false) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.getParamDouble\n \n \n \n                                                    Description\n                                                 \n Retrieve a double parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, double value=simROS.getParamDouble(string name, double defaultValue=0.0) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (double, default: 0.0): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (double): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, double value=simROS.getParamDouble(string name, double defaultValue=0.0) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.getParamInt\n \n \n \n                                                    Description\n                                                 \n Retrieve an integer parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, int value=simROS.getParamInt(string name, int defaultValue=0) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (int, default: 0): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (int): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, int value=simROS.getParamInt(string name, int defaultValue=0) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.getParamString\n \n \n \n                                                    Description\n                                                 \n Retrieve a string parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, string value=simROS.getParamString(string name, string defaultValue="") \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (string, default: ""): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (string): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, string value=simROS.getParamString(string name, string defaultValue="") \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.getTime\n \n \n \n                                                    Description\n                                                 \n Return the current ROS time (i.e. the time returned by ros::Time::now()). \n \n \n Lua synopsis \n double time=simROS.getTime(int flag=0) \n \n \n \n Lua parameters \n \n flag  (int, default: 0): unused: set to zero \n \n \n Lua return values \n \n time  (double): ROS time expressed in seconds \n \n \n Python synopsis \n double time=simROS.getTime(int flag=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simROS.hasParam\n \n \n \n                                                    Description\n                                                 \n Check wether a parameter exists in the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists=simROS.hasParam(string name) \n \n \n \n Lua parameters \n \n name  (string): name of the parameter \n \n \n Lua return values \n \n exists  (bool): true if the parameter exists, false otherwise \n \n \n Python synopsis \n bool exists=simROS.hasParam(string name) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.imageTransportAdvertise\n \n \n \n                                                    Description\n                                                 \n Advertise a topic and create a topic publisher using ImageTransport. \n \n \n Lua synopsis \n string publisherHandle=simROS.imageTransportAdvertise(string topicName, int queueSize=1) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n queueSize  (int, default: 1): (optional) queue size \n \n \n \n Lua return values \n \n publisherHandle  (string): a handle to the ROS publisher \n \n \n Python synopsis \n string publisherHandle=simROS.imageTransportAdvertise(string topicName, int queueSize=1) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe \n \n \n \n \n simROS.imageTransportPublish\n \n \n \n                                                    Description\n                                                 \n Publish a message on the topic associated with this publisher using ImageTransport. \n \n \n Lua synopsis \n simROS.imageTransportPublish(string publisherHandle, string data, int width, int height, string frame_id) \n \n \n \n Lua parameters \n \n \n publisherHandle  (string): the publisher handle \n \n data  (string): the image data \n \n width  (int): image width \n \n height  (int): image height \n \n frame_id  (string): frame id \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.imageTransportPublish(string publisherHandle, string data, int width, int height, string frame_id) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString   simROS.imageTransportAdvertise   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe \n \n \n \n \n simROS.imageTransportShutdownPublisher\n \n \n \n                                                    Description\n                                                 \n Shutdown the advertisement associated with this publisher using ImageTransport. \n \n \n Lua synopsis \n simROS.imageTransportShutdownPublisher(string publisherHandle) \n \n \n \n Lua parameters \n \n publisherHandle  (string): the publisher handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.imageTransportShutdownPublisher(string publisherHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe \n \n \n \n \n simROS.imageTransportShutdownSubscriber\n \n \n \n                                                    Description\n                                                 \n Unsubscribe the callback associated with this subscriber using ImageTransport. \n \n \n Lua synopsis \n simROS.imageTransportShutdownSubscriber(string subscriberHandle) \n \n \n \n Lua parameters \n \n subscriberHandle  (string): the subscriber handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.imageTransportShutdownSubscriber(string subscriberHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportSubscribe \n \n \n \n \n simROS.imageTransportSubscribe\n \n \n \n                                                    Description\n                                                 \n Subscribe to a topic using ImageTransport. \n \n \n Lua synopsis \n string subscriberHandle=simROS.imageTransportSubscribe(string topicName, string topicCallback, int queueSize=1) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n topicCallback  (string): name of the callback function, which will be called as: topicCallback(string data, number width, number height) \n \n queueSize  (int, default: 1): (optional) queue size \n \n \n \n Lua return values \n \n subscriberHandle  (string): a handle to the ROS subscriber \n \n \n Python synopsis \n string subscriberHandle=simROS.imageTransportSubscribe(string topicName, string topicCallback, int queueSize=1) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber \n \n \n \n \n simROS.publish\n \n \n \n                                                    Description\n                                                 \n Publish a message on the topic associated with this publisher. \n \n \n Lua synopsis \n simROS.publish(string publisherHandle, table message) \n \n \n \n Lua parameters \n \n \n publisherHandle  (string): the publisher handle \n \n message  (table): the message to publish \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.publish(string publisherHandle, list message) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString \n \n \n \n \n simROS.publisherTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this \npublisher will treat uint8 arrays as string. Using strings should be in \ngeneral much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS.publisherTreatUInt8ArrayAsString(string publisherHandle) \n \n \n \n Lua parameters \n \n publisherHandle  (string): the publisher handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.publisherTreatUInt8ArrayAsString(string publisherHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString \n \n \n \n \n simROS.searchParam\n \n \n \n                                                    Description\n                                                 \n Search a parameter in the ROS Parameter Server, looking in the closest namespace. \n \n \n Lua synopsis \n bool found, string name=simROS.searchParam(string name) \n \n \n \n Lua parameters \n \n name  (string): name of the parameter \n \n \n Lua return values \n \n \n found  (bool): true if the parameter has been found \n \n name  (string): name of the parameter which has been found \n \n \n \n Python synopsis \n bool found, string name=simROS.searchParam(string name) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.sendTransform\n \n \n \n                                                    Description\n                                                 \n Publish a TF transformation between frames. \n \n \n Lua synopsis \n simROS.sendTransform(table transform) \n \n \n \n Lua parameters \n \n transform  (table): the transformation expressed as a \ngeometry_msgs/TransformStamped message, i.e. {header={stamp=timeStamp, \nframe_id=\'...\'}, child_frame_id=\'...\', transform={translation={x=..., \ny=..., z=...}, rotation={x=..., y=..., z=..., w=...}}} \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.sendTransform(list transform) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString   simROS.sendTransforms \n \n \n \n \n simROS.sendTransforms\n \n \n \n                                                    Description\n                                                 \n Publish several TF transformations between frames. \n \n \n Lua synopsis \n simROS.sendTransforms(table transforms) \n \n \n \n Lua parameters \n \n transforms  (table): an array of geometry_msgs/TransformStamped messages \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.sendTransforms(list transforms) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString   simROS.sendTransform \n \n \n \n \n simROS.serviceClient\n \n \n \n                                                    Description\n                                                 \n Create a service client. \n \n \n Lua synopsis \n string serviceClientHandle=simROS.serviceClient(string serviceName, string serviceType) \n \n \n \n Lua parameters \n \n \n serviceName  (string): topic name, e.g.: \'/cmd_vel\' \n \n serviceType  (string): topic type, e.g.: \'geometry_msgs::Twist\' \n \n \n \n Lua return values \n \n serviceClientHandle  (string): a handle to the ROS service client \n \n \n Python synopsis \n string serviceClientHandle=simROS.serviceClient(string serviceName, string serviceType) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertiseService   simROS.call   simROS.serviceClientTreatUInt8ArrayAsString   simROS.serviceServerTreatUInt8ArrayAsString   simROS.shutdownServiceClient   simROS.shutdownServiceServer \n \n \n \n \n simROS.serviceClientTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this service\n client will treat uint8 arrays as string. Using strings should be in \ngeneral much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS.serviceClientTreatUInt8ArrayAsString(string serviceClientHandle) \n \n \n \n Lua parameters \n \n serviceClientHandle  (string): the service client handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.serviceClientTreatUInt8ArrayAsString(string serviceClientHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertiseService   simROS.call   simROS.serviceClient   simROS.serviceServerTreatUInt8ArrayAsString   simROS.shutdownServiceClient   simROS.shutdownServiceServer \n \n \n \n \n simROS.serviceServerTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this service\n server will treat uint8 arrays as string. Using strings should be in \ngeneral much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS.serviceServerTreatUInt8ArrayAsString(string serviceServerHandle) \n \n \n \n Lua parameters \n \n serviceServerHandle  (string): the service server handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.serviceServerTreatUInt8ArrayAsString(string serviceServerHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertiseService   simROS.call   simROS.serviceClient   simROS.serviceClientTreatUInt8ArrayAsString   simROS.shutdownServiceClient   simROS.shutdownServiceServer \n \n \n \n \n simROS.setParamBool\n \n \n \n                                                    Description\n                                                 \n Set a boolean parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS.setParamBool(string name, bool value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (bool): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.setParamBool(string name, bool value) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamDouble   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.setParamDouble\n \n \n \n                                                    Description\n                                                 \n Set a double parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS.setParamDouble(string name, double value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (double): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.setParamDouble(string name, double value) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamInt   simROS.setParamString \n \n \n \n \n simROS.setParamInt\n \n \n \n                                                    Description\n                                                 \n Set a integer parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS.setParamInt(string name, int value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (int): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.setParamInt(string name, int value) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamString \n \n \n \n \n simROS.setParamString\n \n \n \n                                                    Description\n                                                 \n Set a string parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS.setParamString(string name, string value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (string): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.setParamString(string name, string value) \n \n \n \n \n                                                See also\n                                             \n   simROS.deleteParam   simROS.getParamBool   simROS.getParamDouble   simROS.getParamInt   simROS.getParamString   simROS.hasParam   simROS.searchParam   simROS.setParamBool   simROS.setParamDouble   simROS.setParamInt \n \n \n \n \n simROS.shutdownPublisher\n \n \n \n                                                    Description\n                                                 \n Shutdown the advertisement associated with this publisher. \n \n \n Lua synopsis \n simROS.shutdownPublisher(string publisherHandle) \n \n \n \n Lua parameters \n \n publisherHandle  (string): the publisher handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.shutdownPublisher(string publisherHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownSubscriber   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString \n \n \n \n \n simROS.shutdownServiceClient\n \n \n \n                                                    Description\n                                                 \n Shutdown the service client. \n \n \n Lua synopsis \n simROS.shutdownServiceClient(string serviceClientHandle) \n \n \n \n Lua parameters \n \n serviceClientHandle  (string): the service client handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.shutdownServiceClient(string serviceClientHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertiseService   simROS.call   simROS.serviceClient   simROS.serviceClientTreatUInt8ArrayAsString   simROS.serviceServerTreatUInt8ArrayAsString   simROS.shutdownServiceServer \n \n \n \n \n simROS.shutdownServiceServer\n \n \n \n                                                    Description\n                                                 \n Shutdown the service server. \n \n \n Lua synopsis \n simROS.shutdownServiceServer(string serviceServerHandle) \n \n \n \n Lua parameters \n \n serviceServerHandle  (string): the service server handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.shutdownServiceServer(string serviceServerHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertiseService   simROS.call   simROS.serviceClient   simROS.serviceClientTreatUInt8ArrayAsString   simROS.serviceServerTreatUInt8ArrayAsString   simROS.shutdownServiceClient \n \n \n \n \n simROS.shutdownSubscriber\n \n \n \n                                                    Description\n                                                 \n Unsubscribe the callback associated with this subscriber. \n \n \n Lua synopsis \n simROS.shutdownSubscriber(string subscriberHandle) \n \n \n \n Lua parameters \n \n subscriberHandle  (string): the subscriber handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.shutdownSubscriber(string subscriberHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.subscribe   simROS.subscriberTreatUInt8ArrayAsString \n \n \n \n \n simROS.subscribe\n \n \n \n                                                    Description\n                                                 \n Subscribe to a topic. \n \n \n Lua synopsis \n string \nsubscriberHandle=simROS.subscribe(string topicName, string topicType, \nstring topicCallback, int queueSize=1, transport_hints \ntransportHints={}) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n topicType  (string): topic type, e.g.: \'geometry_msgs::Twist\' \n \n topicCallback  (string): name of the callback function, \nwhich will be called with a single argument of type table containing the\n message payload, e.g.: {linear={x=1.5, y=0.0, z=0.0}, angular={x=0.0, \ny=0.0, z=-2.3}} \n \n queueSize  (int, default: 1): (optional) queue size \n \n transportHints  (transport_hints, default: {}): (optional) transport hints \n \n \n \n Lua return values \n \n subscriberHandle  (string): a handle to the ROS subscriber \n \n \n Python synopsis \n string \nsubscriberHandle=simROS.subscribe(string topicName, string topicType, \nstring topicCallback, int queueSize=1, transport_hints \ntransportHints={}) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscriberTreatUInt8ArrayAsString \n \n \n \n \n simROS.subscriberTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this \nsubscriber will treat uint8 arrays as string. Using strings should be in\n general much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS.subscriberTreatUInt8ArrayAsString(string subscriberHandle) \n \n \n \n Lua parameters \n \n subscriberHandle  (string): the subscriber handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.subscriberTreatUInt8ArrayAsString(string subscriberHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS.advertise   simROS.imageTransportAdvertise   simROS.imageTransportPublish   simROS.imageTransportShutdownPublisher   simROS.imageTransportShutdownSubscriber   simROS.imageTransportSubscribe   simROS.publish   simROS.publisherTreatUInt8ArrayAsString   simROS.sendTransform   simROS.sendTransforms   simROS.shutdownPublisher   simROS.shutdownSubscriber   simROS.subscribe \n \n \n \n \n \n \n \n Data structures \n Data structures are used to pass complex data around. Create data structures in Lua in the form of a map, e.g.:  {line_size=3, add_to_legend=false, selectable=true} \n \n transport_hints\n \n \n \n                                                Description\n                                             \n \n \n \n Fields \n \n \n transports  (table of string, default: {}): the list of \ntransports to use. allowed values are \'reliable\', \'unreliable\', \'tcp\', \n\'udp\' (the last two being synonyms of the first two respectively). \ntransports appearing earlier in the list have higher priority. e.g.: \n{\'unreliable\',\'reliable\'} specifies that you would prefer an unreliable \ntransport, followed by a reliable one. \n \n tcpNoDelay  (bool, default: false):  \n \n maxDatagramSize  (int, default: 0):  \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Script functions \n Script functions are used to call some lua code from the plugin side (tipically used for event handlers). \n \n subscriberCallback\n \n \n \n                                                    Description\n                                                 \n Callback for ROS subscriber. \n \n \n Lua synopsis \n simROS.subscriberCallback(table message) \n \n \n \n Lua parameters \n \n message  (table): the topic payload (i.e. the message) \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.subscriberCallback(list message) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n imageTransportCallback\n \n \n \n                                                    Description\n                                                 \n Callback for ROS ImageTransport subscriber. \n \n \n Lua synopsis \n simROS.imageTransportCallback(string data, int width, int height) \n \n \n \n Lua parameters \n \n \n data  (string): the image data \n \n width  (int): image width \n \n height  (int): image height \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS.imageTransportCallback(string data, int width, int height) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'ROSPluginAPIreference.html'}, {'title': 'ros2Interface', 'text': "\n \n \n \n \n ROS 2 Interface \n The ROS 2 Interface is part of the  CoppeliaSim API framework  and is courtesy of Federico Ferri. The ROS 2 Interface duplicates the C++ ROS 2 API with a good fidelity. This makes it the ideal choice for very flexible communication via ROS 2. You can recognize ROS 2 Interface API functions from the  simROS2 - prefix. \n ROS 2 is a distributed pseudo operating system allowing for easy management and communication between multiple computers connected in a network. Please refer to the  official ROS 2 documentation  for details about ROS 2. \n CoppeliaSim can act as a ROS 2 node that other nodes can communicate with via services, topics and actions. \n The ROS 2 Interface functionality in CoppeliaSim is enabled via a plugin:  libsimExtROS2 .* . The plugin can easily be adapted to your own needs. The plugin is loaded when CoppeliaSim is launched. Make sure to inspect CoppeliaSim's console window or terminal for details on plugin load operations. \n Have a look at following simulation scenes/model for a quick start with the ROS Interface: \n ros2InterfaceTopicPublisherAndSubscriber.ttt \n controlTypeExamples/controlledViaRos2.ttt \n models/tools/ros2Interface helper tool.ttm  (model allowing to operate CoppeliaSim in  stepped mode , e.g. in order to manually step the simulation) \n Also have a look at the  ROS 2 tutorial  and the  external controller tutorial . \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'ros2Interface.html'}, {'title': 'ROS2PluginAPIreference', 'text': '\n ROS2 Plugin API reference \n This plugin provides an interface with the ROS2 API \n simROS2.actionClientTreatUInt8ArrayAsString \n simROS2.actionServerActionAbort \n simROS2.actionServerActionCanceled \n simROS2.actionServerActionExecute \n simROS2.actionServerActionIsActive \n simROS2.actionServerActionIsCanceling \n simROS2.actionServerActionIsExecuting \n simROS2.actionServerActionSucceed \n simROS2.actionServerPublishFeedback \n simROS2.actionServerTreatUInt8ArrayAsString \n simROS2.call \n simROS2.cancelLastGoal \n simROS2.clientTreatUInt8ArrayAsString \n simROS2.createActionClient \n simROS2.createActionServer \n simROS2.createClient \n simROS2.createInterface \n simROS2.createPublisher \n simROS2.createService \n simROS2.createSubscription \n simROS2.deleteParam \n simROS2.getInterfaceConstants \n simROS2.getParamBool \n simROS2.getParamDouble \n simROS2.getParamInt \n simROS2.getParamString \n simROS2.getSimulationTime \n simROS2.getSystemTime \n simROS2.getTime \n simROS2.hasParam \n simROS2.imageTransportCreatePublisher \n simROS2.imageTransportCreateSubscription \n simROS2.imageTransportPublish \n simROS2.imageTransportShutdownPublisher \n simROS2.imageTransportShutdownSubscription \n simROS2.importInterface \n simROS2.publish \n simROS2.publisherTreatUInt8ArrayAsString \n simROS2.sendGoal \n simROS2.sendTransform \n simROS2.sendTransforms \n simROS2.serviceTreatUInt8ArrayAsString \n simROS2.setParamBool \n simROS2.setParamDouble \n simROS2.setParamInt \n simROS2.setParamString \n simROS2.shutdownActionClient \n simROS2.shutdownActionServer \n simROS2.shutdownClient \n simROS2.shutdownPublisher \n simROS2.shutdownService \n simROS2.shutdownSubscription \n simROS2.subscriptionTreatUInt8ArrayAsString \n simROS2.supportedInterfaces \n simROS2.timeFromFloat \n simROS2.timeToFloat \n simROS2.waitForService \n \n \n \n simROS2.actionClientTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this action \nclient will treat uint8 arrays as string. Using strings should be in \ngeneral much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS2.actionClientTreatUInt8ArrayAsString(string actionClientHandle) \n \n \n \n Lua parameters \n \n actionClientHandle  (string): the action client handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionClientTreatUInt8ArrayAsString(string actionClientHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerActionAbort\n \n \n \n                                                    Description\n                                                 \n Indicate that a goal could not be reached\n and has been aborted. Only call this if the goal was executing but \ncannot be completed. This is a terminal state, no more methods should be\n called on a goal after this is called. \n \n \n Lua synopsis \n simROS2.actionServerActionAbort(string actionServerHandle, string goalUUID, table result) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n result  (table): the result message \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionServerActionAbort(string actionServerHandle, string goalUUID, list result) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerActionCanceled\n \n \n \n                                                    Description\n                                                 \n Indicate that a goal has been canceled. \nOnly call this if the goal is executing or pending, but has been \ncanceled. This is a terminal state, no more methods should be called on a\n goal after this is called. \n \n \n Lua synopsis \n simROS2.actionServerActionCanceled(string actionServerHandle, string goalUUID, table result) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n result  (table): the result message \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionServerActionCanceled(string actionServerHandle, string goalUUID, list result) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerActionExecute\n \n \n \n                                                    Description\n                                                 \n Indicate that the server is starting to execute a goal. Only call this if the goal is pending. \n \n \n Lua synopsis \n simROS2.actionServerActionExecute(string actionServerHandle, string goalUUID) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionServerActionExecute(string actionServerHandle, string goalUUID) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerActionIsActive\n \n \n \n                                                    Description\n                                                 \n Check if goal is pending or executing \n \n \n Lua synopsis \n bool result=simROS2.actionServerActionIsActive(string actionServerHandle, string goalUUID) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n \n \n Lua return values \n \n result  (bool): false if the goal has reached a terminal state \n \n \n Python synopsis \n bool result=simROS2.actionServerActionIsActive(string actionServerHandle, string goalUUID) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerActionIsCanceling\n \n \n \n                                                    Description\n                                                 \n Check if there is a cancel request \n \n \n Lua synopsis \n bool result=simROS2.actionServerActionIsCanceling(string actionServerHandle, string goalUUID) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n \n \n Lua return values \n \n result  (bool): true if a cancelation request has been accepted for this goal \n \n \n Python synopsis \n bool result=simROS2.actionServerActionIsCanceling(string actionServerHandle, string goalUUID) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerActionIsExecuting\n \n \n \n                                                    Description\n                                                 \n Check if the goal is executing \n \n \n Lua synopsis \n bool result=simROS2.actionServerActionIsExecuting(string actionServerHandle, string goalUUID) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n \n \n Lua return values \n \n result  (bool): true if the goal is in an executing state \n \n \n Python synopsis \n bool result=simROS2.actionServerActionIsExecuting(string actionServerHandle, string goalUUID) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerActionSucceed\n \n \n \n                                                    Description\n                                                 \n Indicate that a goal has succeeded. Only \ncall this if the goal is executing and has reached the desired final \nstate. This is a terminal state, no more methods should be called on a \ngoal after this is called. \n \n \n Lua synopsis \n simROS2.actionServerActionSucceed(string actionServerHandle, string goalUUID, table result) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n result  (table): the result message \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionServerActionSucceed(string actionServerHandle, string goalUUID, list result) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerPublishFeedback\n \n \n \n                                                    Description\n                                                 \n Send an update about the progress of this\n goal. This must be only called when the goal is executing. If execution\n of a goal is deferred then  simROS2.actionServerActionExecute  must be called first. \n \n \n Lua synopsis \n simROS2.actionServerPublishFeedback(string actionServerHandle, string goalUUID, table feedback) \n \n \n \n Lua parameters \n \n \n actionServerHandle  (string): the action server handle \n \n goalUUID  (string): the goal unique identifier \n \n feedback  (table): the feedback message \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionServerPublishFeedback(string actionServerHandle, string goalUUID, list feedback) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.actionServerTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this action \nserver will treat uint8 arrays as string. Using strings should be in \ngeneral much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS2.actionServerTreatUInt8ArrayAsString(string actionServerHandle) \n \n \n \n Lua parameters \n \n actionServerHandle  (string): the action server handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionServerTreatUInt8ArrayAsString(string actionServerHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.call\n \n \n \n                                                    Description\n                                                 \n Call the service associated with this service client. \n \n \n Lua synopsis \n table result=simROS2.call(string clientHandle, table request) \n \n \n \n Lua parameters \n \n \n clientHandle  (string): the service client handle \n \n request  (table): the message to publish \n \n \n \n Lua return values \n \n result  (table): the response message, if the call succeeded \n \n \n Python synopsis \n list result=simROS2.call(string clientHandle, list request) \n \n \n \n \n                                                See also\n                                             \n   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService \n \n \n \n \n simROS2.cancelLastGoal\n \n \n \n                                                    Description\n                                                 \n Cancel last submitted goal on the specified action client. \n \n \n Lua synopsis \n bool success=simROS2.cancelLastGoal(string actionClientHandle) \n \n \n \n Lua parameters \n \n actionClientHandle  (string): the action client handle \n \n \n Lua return values \n \n success  (bool): false if canceling the goal to the action server has failed \n \n \n Python synopsis \n bool success=simROS2.cancelLastGoal(string actionClientHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.clientTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this service\n client will treat uint8 arrays as string. Using strings should be in \ngeneral much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS2.clientTreatUInt8ArrayAsString(string clientHandle) \n \n \n \n Lua parameters \n \n clientHandle  (string): the service client handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.clientTreatUInt8ArrayAsString(string clientHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.call   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService \n \n \n \n \n simROS2.createActionClient\n \n \n \n                                                    Description\n                                                 \n Create a action client. \n \n \n Lua synopsis \n string \nactionClientHandle=simROS2.createActionClient(string actionName, string \nactionType, string goalResponseCallback, string feedbackCallback, string\n resultCallback) \n \n \n \n Lua parameters \n \n \n actionName  (string): action name, e.g.: \'/fibonacci\' \n \n actionType  (string): action type, e.g.: \'example_interfaces/action/Fibonacci\' \n \n goalResponseCallback  (string): the goal response callback, will be called with arguments (goal_id,accepted) where accepted is a boolean value \n \n feedbackCallback  (string): the feedback callback, will \nbe called with arguments (goal_id,feedback) where feedback is a table \nrepresenting the Feedback message of the action type \n \n resultCallback  (string): the result callback, will be called with arguments (goal_id,code,result) where code is a value from  simROS2.action_result_code , and result is a table representing the Result message of the action type \n \n \n \n Lua return values \n \n actionClientHandle  (string): a handle to the ROS action client \n \n \n Python synopsis \n string \nactionClientHandle=simROS2.createActionClient(string actionName, string \nactionType, string goalResponseCallback, string feedbackCallback, string\n resultCallback) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.createActionServer\n \n \n \n                                                    Description\n                                                 \n Create an action server. \n \n \n Lua synopsis \n string \nactionServerHandle=simROS2.createActionServer(string actionName, string \nactionType, string handleGoalCallback, string handleCancelCallback, \nstring handleAcceptedCallback) \n \n \n \n Lua parameters \n \n \n actionName  (string): action name, e.g.: \'/fibonacci\' \n \n actionType  (string): action type, e.g.: \'example_interfaces/action/Fibonacci\' \n \n handleGoalCallback  (string): name of callback function,\n which will be called with arguments (goal_id, goal) where goal is a \ntable representing the Goal message of the action type. the callback \nmust return a valid  simROS2.goal_response \n \n \n handleCancelCallback  (string): name of callback \nfunction, which will be called with arguments (goal_id, goal) where goal\n is a table representing the Goal message of the action type. the \ncallback must return a valid  simROS2.cancel_response \n \n \n handleAcceptedCallback  (string): name of callback \nfunction, which will be called with arguments (goal_id, goal) where goal\n is a table representing the Goal message of the action type. it will be\n called after the goal is accepted, and is responsible of executing the \ngoal, but must return immediately. \n \n \n \n Lua return values \n \n actionServerHandle  (string): a handle to the action server \n \n \n Python synopsis \n string \nactionServerHandle=simROS2.createActionServer(string actionName, string \nactionType, string handleGoalCallback, string handleCancelCallback, \nstring handleAcceptedCallback) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.createClient\n \n \n \n                                                    Description\n                                                 \n Create a service client. \n \n \n Lua synopsis \n string clientHandle=simROS2.createClient(string serviceName, string serviceType) \n \n \n \n Lua parameters \n \n \n serviceName  (string): service name, e.g.: \'/trigger\' \n \n serviceType  (string): service type, e.g.: \'std_srvs/srv/Trigger\' \n \n \n \n Lua return values \n \n clientHandle  (string): a handle to the ROS service client \n \n \n Python synopsis \n string clientHandle=simROS2.createClient(string serviceName, string serviceType) \n \n \n \n \n                                                See also\n                                             \n   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService \n \n \n \n \n simROS2.createInterface\n \n \n \n                                                    Description\n                                                 \n Construct an interface of the specified type, initialized with the default values. \n \n \n Lua synopsis \n table result=simROS2.createInterface(string type) \n \n \n \n Lua parameters \n \n type  (string): type, e.g.: \'geometry_msgs/msg/Twist\' \n \n \n Lua return values \n \n result  (table): the interface object \n \n \n Python synopsis \n list result=simROS2.createInterface(string type) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.createPublisher\n \n \n \n                                                    Description\n                                                 \n Create a topic publisher. \n \n \n Lua synopsis \n string publisherHandle=simROS2.createPublisher(string topicName, string topicType, int queueSize=1, bool latch=false) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n topicType  (string): topic type, e.g.: \'geometry_msgs/msg/Twist\' \n \n queueSize  (int, default: 1): (optional) queue size \n \n latch  (bool, default: false): (optional) latch topic \n \n \n \n Lua return values \n \n publisherHandle  (string): a handle to the ROS publisher \n \n \n Python synopsis \n string publisherHandle=simROS2.createPublisher(string topicName, string topicType, int queueSize=1, bool latch=false) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces \n \n \n \n \n simROS2.createService\n \n \n \n                                                    Description\n                                                 \n Create a service. \n \n \n Lua synopsis \n string serviceHandle=simROS2.createService(string serviceName, string serviceType, string serviceCallback) \n \n \n \n Lua parameters \n \n \n serviceName  (string): service name, e.g.: \'/trigger\' \n \n serviceType  (string): service type, e.g.: \'std_srvs/srv/Trigger\' \n \n serviceCallback  (string): name of the callback \nfunction, which will be called with a single argument of type table \ncontaining the service request payload; it must return another table \ncontaining the response \n \n \n \n Lua return values \n \n serviceHandle  (string): a handle to the ROS service \n \n \n Python synopsis \n string serviceHandle=simROS2.createService(string serviceName, string serviceType, string serviceCallback) \n \n \n \n \n                                                See also\n                                             \n   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService \n \n \n \n \n simROS2.createSubscription\n \n \n \n                                                    Description\n                                                 \n Create a subscription to a topic. \n \n \n Lua synopsis \n string subscriptionHandle=simROS2.createSubscription(string topicName, string topicType, string topicCallback, int queueSize=1) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n topicType  (string): topic type, e.g.: \'geometry_msgs/msg/Twist\' \n \n topicCallback  (string): name of the callback function, \nwhich will be called with a single argument of type table containing the\n message payload, e.g.: {linear={x=1.5, y=0.0, z=0.0}, angular={x=0.0, \ny=0.0, z=-2.3}} \n \n queueSize  (int, default: 1): (optional) queue size \n \n \n \n Lua return values \n \n subscriptionHandle  (string): a handle to the ROS subscription \n \n \n Python synopsis \n string subscriptionHandle=simROS2.createSubscription(string topicName, string topicType, string topicCallback, int queueSize=1) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces \n \n \n \n \n simROS2.deleteParam\n \n \n \n                                                    Description\n                                                 \n Delete a parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS2.deleteParam(string name) \n \n \n \n Lua parameters \n \n name  (string): name of the parameter \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.deleteParam(string name) \n \n \n \n \n                                                See also\n                                             \n   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamInt   simROS2.getParamString   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.getInterfaceConstants\n \n \n \n                                                    Description\n                                                 \n Get an object with the constants defined in the specified interface. \n \n \n Lua synopsis \n table result=simROS2.getInterfaceConstants(string type) \n \n \n \n Lua parameters \n \n type  (string): type, e.g.: \'geometry_msgs/msg/Twist\' \n \n \n Lua return values \n \n result  (table): the constants object \n \n \n Python synopsis \n list result=simROS2.getInterfaceConstants(string type) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.getParamBool\n \n \n \n                                                    Description\n                                                 \n Retrieve a boolean parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, bool value=simROS2.getParamBool(string name, bool defaultValue=false) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (bool, default: false): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (bool): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, bool value=simROS2.getParamBool(string name, bool defaultValue=false) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamDouble   simROS2.getParamInt   simROS2.getParamString   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.getParamDouble\n \n \n \n                                                    Description\n                                                 \n Retrieve a double parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, double value=simROS2.getParamDouble(string name, double defaultValue=0.0) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (double, default: 0.0): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (double): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, double value=simROS2.getParamDouble(string name, double defaultValue=0.0) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamInt   simROS2.getParamString   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.getParamInt\n \n \n \n                                                    Description\n                                                 \n Retrieve an integer parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, int value=simROS2.getParamInt(string name, int defaultValue=0) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (int, default: 0): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (int): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, int value=simROS2.getParamInt(string name, int defaultValue=0) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamString   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.getParamString\n \n \n \n                                                    Description\n                                                 \n Retrieve a string parameter from the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists, string value=simROS2.getParamString(string name, string defaultValue="") \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n defaultValue  (string, default: ""): default value returned when parameter does not exist \n \n \n \n Lua return values \n \n \n exists  (bool): true if the param exists otherwise false \n \n value  (string): the value of the requested parameter \n \n \n \n Python synopsis \n bool exists, string value=simROS2.getParamString(string name, string defaultValue="") \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamInt   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.getSimulationTime\n \n \n Lua synopsis \n simROS2.getSimulationTime() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.getSimulationTime() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simROS2.getSystemTime\n \n \n Lua synopsis \n simROS2.getSystemTime() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.getSystemTime() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simROS2.getTime\n \n \n \n                                                    Description\n                                                 \n Return the current time according to the specified clock. \n \n \n Lua synopsis \n sim_ros2_time time=simROS2.getTime(int clock_type=sim_ros2_clock_ros) \n \n \n \n Lua parameters \n \n clock_type  (int, default: sim_ros2_clock_ros): type of clock. see  simROS2.clock_type . \n \n \n Lua return values \n \n time  (sim_ros2_time): ROS time \n \n \n Python synopsis \n sim_ros2_time time=simROS2.getTime(int clock_type=sim_ros2_clock_ros) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simROS2.hasParam\n \n \n \n                                                    Description\n                                                 \n Check wether a parameter exists in the ROS Parameter Server. \n \n \n Lua synopsis \n bool exists=simROS2.hasParam(string name) \n \n \n \n Lua parameters \n \n name  (string): name of the parameter \n \n \n Lua return values \n \n exists  (bool): true if the parameter exists, false otherwise \n \n \n Python synopsis \n bool exists=simROS2.hasParam(string name) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamInt   simROS2.getParamString   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.imageTransportCreatePublisher\n \n \n \n                                                    Description\n                                                 \n Create a publisher using ImageTransport. \n \n \n Lua synopsis \n string publisherHandle=simROS2.imageTransportCreatePublisher(string topicName, int queueSize=1) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n queueSize  (int, default: 1): (optional) queue size \n \n \n \n Lua return values \n \n publisherHandle  (string): a handle to the ROS publisher \n \n \n Python synopsis \n string publisherHandle=simROS2.imageTransportCreatePublisher(string topicName, int queueSize=1) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription \n \n \n \n \n simROS2.imageTransportCreateSubscription\n \n \n \n                                                    Description\n                                                 \n Create a subscription using ImageTransport. \n \n \n Lua synopsis \n string subscriptionHandle=simROS2.imageTransportCreateSubscription(string topicName, string topicCallback, int queueSize=1) \n \n \n \n Lua parameters \n \n \n topicName  (string): topic name, e.g.: \'/cmd_vel\' \n \n topicCallback  (string): name of the callback function, which will be called as: topicCallback(string data, number width, number height) \n \n queueSize  (int, default: 1): (optional) queue size \n \n \n \n Lua return values \n \n subscriptionHandle  (string): a handle to the ROS subscription \n \n \n Python synopsis \n string subscriptionHandle=simROS2.imageTransportCreateSubscription(string topicName, string topicCallback, int queueSize=1) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.imageTransportCreatePublisher   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription \n \n \n \n \n simROS2.imageTransportPublish\n \n \n \n                                                    Description\n                                                 \n Publish a message on the topic associated with this publisher using ImageTransport. \n \n \n Lua synopsis \n simROS2.imageTransportPublish(string publisherHandle, string data, int width, int height, string frame_id) \n \n \n \n Lua parameters \n \n \n publisherHandle  (string): the publisher handle \n \n data  (string): the image data \n \n width  (int): image width \n \n height  (int): image height \n \n frame_id  (string): frame id \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.imageTransportPublish(string publisherHandle, string data, int width, int height, string frame_id) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription \n \n \n \n \n simROS2.imageTransportShutdownPublisher\n \n \n \n                                                    Description\n                                                 \n Shutdown the publisher using ImageTransport. \n \n \n Lua synopsis \n simROS2.imageTransportShutdownPublisher(string publisherHandle) \n \n \n \n Lua parameters \n \n publisherHandle  (string): the publisher handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.imageTransportShutdownPublisher(string publisherHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownSubscription \n \n \n \n \n simROS2.imageTransportShutdownSubscription\n \n \n \n                                                    Description\n                                                 \n Shutdown the subscription using ImageTransport. \n \n \n Lua synopsis \n simROS2.imageTransportShutdownSubscription(string subscriptionHandle) \n \n \n \n Lua parameters \n \n subscriptionHandle  (string): the subscription handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.imageTransportShutdownSubscription(string subscriptionHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher \n \n \n \n \n simROS2.importInterface\n \n \n Lua synopsis \n simROS2.importInterface(string name) \n \n \n \n Lua parameters \n \n name  (string): the name of the interface to import, e.g.: geometry_msgs/msg/Vector3 \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.importInterface(string name) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simROS2.publish\n \n \n \n                                                    Description\n                                                 \n Publish a message on the topic associated with this publisher. \n \n \n Lua synopsis \n simROS2.publish(string publisherHandle, table message) \n \n \n \n Lua parameters \n \n \n publisherHandle  (string): the publisher handle \n \n message  (table): the message to publish \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.publish(string publisherHandle, list message) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces \n \n \n \n \n simROS2.publisherTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this \npublisher will treat uint8 arrays as string. Using strings should be in \ngeneral much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS2.publisherTreatUInt8ArrayAsString(string publisherHandle) \n \n \n \n Lua parameters \n \n publisherHandle  (string): the publisher handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.publisherTreatUInt8ArrayAsString(string publisherHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces \n \n \n \n \n simROS2.sendGoal\n \n \n \n                                                    Description\n                                                 \n Send a goal using the specified action client. \n \n \n Lua synopsis \n bool success=simROS2.sendGoal(string actionClientHandle, table goal) \n \n \n \n Lua parameters \n \n \n actionClientHandle  (string): the action client handle \n \n goal  (table): the goal to send \n \n \n \n Lua return values \n \n success  (bool): false if sending the goal to the action server has failed \n \n \n Python synopsis \n bool success=simROS2.sendGoal(string actionClientHandle, list goal) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.shutdownActionClient   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.sendTransform\n \n \n \n                                                    Description\n                                                 \n Publish a TF transformation between frames. \n \n \n Lua synopsis \n simROS2.sendTransform(table transform) \n \n \n \n Lua parameters \n \n transform  (table): the transformation expressed as a \ngeometry_msgs/msg/TransformStamped message, i.e. \n{header={stamp=timeStamp, frame_id=\'...\'}, child_frame_id=\'...\', \ntransform={translation={x=..., y=..., z=...}, rotation={x=..., y=..., \nz=..., w=...}}} \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.sendTransform(list transform) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.sendTransforms \n \n \n \n \n simROS2.sendTransforms\n \n \n \n                                                    Description\n                                                 \n Publish several TF transformations between frames. \n \n \n Lua synopsis \n simROS2.sendTransforms(table transforms) \n \n \n \n Lua parameters \n \n transforms  (table): an array of geometry_msgs/msg/TransformStamped messages \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.sendTransforms(list transforms) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces   simROS2.sendTransform \n \n \n \n \n simROS2.serviceTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this service\n will treat uint8 arrays as string. Using strings should be in general \nmuch faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS2.serviceTreatUInt8ArrayAsString(string serviceHandle) \n \n \n \n Lua parameters \n \n serviceHandle  (string): the service handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.serviceTreatUInt8ArrayAsString(string serviceHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService \n \n \n \n \n simROS2.setParamBool\n \n \n \n                                                    Description\n                                                 \n Set a boolean parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS2.setParamBool(string name, bool value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (bool): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.setParamBool(string name, bool value) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamInt   simROS2.getParamString   simROS2.hasParam   simROS2.setParamDouble   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.setParamDouble\n \n \n \n                                                    Description\n                                                 \n Set a double parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS2.setParamDouble(string name, double value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (double): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.setParamDouble(string name, double value) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamInt   simROS2.getParamString   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamInt   simROS2.setParamString \n \n \n \n \n simROS2.setParamInt\n \n \n \n                                                    Description\n                                                 \n Set a integer parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS2.setParamInt(string name, int value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (int): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.setParamInt(string name, int value) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamInt   simROS2.getParamString   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamString \n \n \n \n \n simROS2.setParamString\n \n \n \n                                                    Description\n                                                 \n Set a string parameter in the ROS Parameter Server. \n \n \n Lua synopsis \n simROS2.setParamString(string name, string value) \n \n \n \n Lua parameters \n \n \n name  (string): name of the parameter \n \n value  (string): value of the parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.setParamString(string name, string value) \n \n \n \n \n                                                See also\n                                             \n   simROS2.deleteParam   simROS2.getParamBool   simROS2.getParamDouble   simROS2.getParamInt   simROS2.getParamString   simROS2.hasParam   simROS2.setParamBool   simROS2.setParamDouble   simROS2.setParamInt \n \n \n \n \n simROS2.shutdownActionClient\n \n \n \n                                                    Description\n                                                 \n Shutdown the action client. \n \n \n Lua synopsis \n simROS2.shutdownActionClient(string actionClientHandle) \n \n \n \n Lua parameters \n \n actionClientHandle  (string): the action client handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.shutdownActionClient(string actionClientHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionServer   simROS2.supportedInterfaces \n \n \n \n \n simROS2.shutdownActionServer\n \n \n \n                                                    Description\n                                                 \n Shutdown the action server. \n \n \n Lua synopsis \n simROS2.shutdownActionServer(string actionServerHandle) \n \n \n \n Lua parameters \n \n actionServerHandle  (string): the action server handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.shutdownActionServer(string actionServerHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.supportedInterfaces \n \n \n \n \n simROS2.shutdownClient\n \n \n \n                                                    Description\n                                                 \n Shutdown the service client. \n \n \n Lua synopsis \n simROS2.shutdownClient(string clientHandle) \n \n \n \n Lua parameters \n \n clientHandle  (string): the service client handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.shutdownClient(string clientHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownService   simROS2.supportedInterfaces   simROS2.waitForService \n \n \n \n \n simROS2.shutdownPublisher\n \n \n \n                                                    Description\n                                                 \n Shutdown the specified publisher. \n \n \n Lua synopsis \n simROS2.shutdownPublisher(string publisherHandle) \n \n \n \n Lua parameters \n \n publisherHandle  (string): the publisher handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.shutdownPublisher(string publisherHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces \n \n \n \n \n simROS2.shutdownService\n \n \n \n                                                    Description\n                                                 \n Shutdown the service. \n \n \n Lua synopsis \n simROS2.shutdownService(string serviceHandle) \n \n \n \n Lua parameters \n \n serviceHandle  (string): the service handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.shutdownService(string serviceHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.supportedInterfaces   simROS2.waitForService \n \n \n \n \n simROS2.shutdownSubscription\n \n \n \n                                                    Description\n                                                 \n Shutdown the subscription. \n \n \n Lua synopsis \n simROS2.shutdownSubscription(string subscriptionHandle) \n \n \n \n Lua parameters \n \n subscriptionHandle  (string): the subscription handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.shutdownSubscription(string subscriptionHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.supportedInterfaces \n \n \n \n \n simROS2.subscriptionTreatUInt8ArrayAsString\n \n \n \n                                                    Description\n                                                 \n After calling this function, this \nsubscription will treat uint8 arrays as string. Using strings should be \nin general much faster that using int arrays in Lua. \n \n \n Lua synopsis \n simROS2.subscriptionTreatUInt8ArrayAsString(string subscriptionHandle) \n \n \n \n Lua parameters \n \n subscriptionHandle  (string): the subscription handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.subscriptionTreatUInt8ArrayAsString(string subscriptionHandle) \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.supportedInterfaces \n \n \n \n \n simROS2.supportedInterfaces\n \n \n \n                                                    Description\n                                                 \n Retrieve a list of supported interfaces. \n \n \n Lua synopsis \n string[] result=simROS2.supportedInterfaces() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n result  (table of string): the list of supported interfaces \n \n \n Python synopsis \n list result=simROS2.supportedInterfaces() \n \n \n \n \n                                                See also\n                                             \n   simROS2.createInterface   simROS2.createPublisher   simROS2.createSubscription   simROS2.getInterfaceConstants   simROS2.imageTransportCreatePublisher   simROS2.imageTransportCreateSubscription   simROS2.imageTransportPublish   simROS2.imageTransportShutdownPublisher   simROS2.imageTransportShutdownSubscription   simROS2.publish   simROS2.publisherTreatUInt8ArrayAsString   simROS2.sendTransform   simROS2.sendTransforms   simROS2.shutdownPublisher   simROS2.shutdownSubscription   simROS2.subscriptionTreatUInt8ArrayAsString   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.waitForService   simROS2.actionClientTreatUInt8ArrayAsString   simROS2.actionServerActionAbort   simROS2.actionServerActionCanceled   simROS2.actionServerActionExecute   simROS2.actionServerActionIsActive   simROS2.actionServerActionIsCanceling   simROS2.actionServerActionIsExecuting   simROS2.actionServerActionSucceed   simROS2.actionServerPublishFeedback   simROS2.actionServerTreatUInt8ArrayAsString   simROS2.cancelLastGoal   simROS2.createActionClient   simROS2.createActionServer   simROS2.createInterface   simROS2.getInterfaceConstants   simROS2.sendGoal   simROS2.shutdownActionClient   simROS2.shutdownActionServer \n \n \n \n \n simROS2.timeFromFloat\n \n \n Lua synopsis \n simROS2.timeFromFloat(float t) \n \n \n \n Lua parameters \n \n t  (float): the time as a floating point number \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.timeFromFloat(float t) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simROS2.timeToFloat\n \n \n Lua synopsis \n simROS2.timeToFloat(table t) \n \n \n \n Lua parameters \n \n t  (table): the time as a table with integer sec and nanosec fields \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.timeToFloat(list t) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simROS2.waitForService\n \n \n \n                                                    Description\n                                                 \n Wait for the service associated with this service client. \n \n \n Lua synopsis \n bool result=simROS2.waitForService(string clientHandle, float timeout) \n \n \n \n Lua parameters \n \n \n clientHandle  (string): the service client handle \n \n timeout  (float): the amount of time to wait in seconds \n \n \n \n Lua return values \n \n result  (bool): false if the service is not found after the specified timeout \n \n \n Python synopsis \n bool result=simROS2.waitForService(string clientHandle, float timeout) \n \n \n \n \n                                                See also\n                                             \n   simROS2.call   simROS2.clientTreatUInt8ArrayAsString   simROS2.createClient   simROS2.createInterface   simROS2.createService   simROS2.getInterfaceConstants   simROS2.serviceTreatUInt8ArrayAsString   simROS2.shutdownClient   simROS2.shutdownService   simROS2.supportedInterfaces \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simROS2.clock_type\n \n ros \n system \n steady \n \n \n simROS2.action_result_code\n \n succeeded \n aborted \n canceled \n unknown \n \n \n simROS2.goal_response\n \n reject \n accept_and_execute \n accept_and_defer \n \n \n simROS2.cancel_response\n \n reject \n accept \n \n \n \n Data structures \n Data structures are used to pass complex data around. Create data structures in Lua in the form of a map, e.g.:  {line_size=3, add_to_legend=false, selectable=true} \n \n sim_ros2_time\n \n \n \n                                                Description\n                                             \n Time data structure, equivalent of builtin_interfaces/msg/Time \n \n \n \n Fields \n \n \n sec  (int): seconds \n \n nanosec  (int): nanoseconds \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Script functions \n Script functions are used to call some lua code from the plugin side (tipically used for event handlers). \n \n subscriptionCallback\n \n \n \n                                                    Description\n                                                 \n Callback for ROS subscription. \n \n \n Lua synopsis \n simROS2.subscriptionCallback(table message) \n \n \n \n Lua parameters \n \n message  (table): the topic payload (i.e. the message) \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.subscriptionCallback(list message) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n imageTransportCallback\n \n \n \n                                                    Description\n                                                 \n Callback for ROS ImageTransport subscription. \n \n \n Lua synopsis \n simROS2.imageTransportCallback(string data, int width, int height) \n \n \n \n Lua parameters \n \n \n data  (string): the image data \n \n width  (int): image width \n \n height  (int): image height \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.imageTransportCallback(string data, int width, int height) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n actionGoalResponseCallback\n \n \n \n                                                    Description\n                                                 \n Callback for action client goal response. \n \n \n Lua synopsis \n simROS2.actionGoalResponseCallback(string goalID, bool accepted) \n \n \n \n Lua parameters \n \n \n goalID  (string): the goal id \n \n accepted  (bool): true if the goal was accepted by the action server \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simROS2.actionGoalResponseCallback(string goalID, bool accepted) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'ROS2PluginAPIreference.html'}, {'title': 'ZMQPluginAPIreference', 'text': '\n ZMQ Plugin API reference \n ZeroMQ plugin. Description of ZeroMQ API functions is not provided. Please refer to  http://api.zeromq.org . \n simZMQ.bind \n simZMQ.close \n simZMQ.connect \n simZMQ.ctx_get \n simZMQ.ctx_new \n simZMQ.ctx_set \n simZMQ.ctx_shutdown \n simZMQ.ctx_singleton \n simZMQ.ctx_term \n simZMQ.disconnect \n simZMQ.errnum \n simZMQ.getsockopt \n simZMQ.has \n simZMQ.msg_close \n simZMQ.msg_copy \n simZMQ.msg_data \n simZMQ.msg_destroy \n simZMQ.msg_get \n simZMQ.msg_gets \n simZMQ.msg_init \n simZMQ.msg_init_size \n simZMQ.msg_more \n simZMQ.msg_move \n simZMQ.msg_new \n simZMQ.msg_recv \n simZMQ.msg_send \n simZMQ.msg_set \n simZMQ.msg_size \n simZMQ.poll \n simZMQ.proxy \n simZMQ.proxy_steerable \n simZMQ.recv \n simZMQ.send \n simZMQ.setsockopt \n simZMQ.socket \n simZMQ.socket_monitor \n simZMQ.strerror \n simZMQ.unbind \n simZMQ.version \n \n \n \n simZMQ.bind\n \n \n Lua synopsis \n int result=simZMQ.bind(string socket, string endpoint) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n endpoint  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.bind(string socket, string endpoint) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.close\n \n \n Lua synopsis \n int result=simZMQ.close(string socket) \n \n \n \n Lua parameters \n \n socket  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.close(string socket) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.connect\n \n \n Lua synopsis \n int result=simZMQ.connect(string socket, string endpoint) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n endpoint  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.connect(string socket, string endpoint) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.ctx_get\n \n \n Lua synopsis \n int result=simZMQ.ctx_get(string context, int option_name) \n \n \n \n Lua parameters \n \n \n context  (string):  \n \n option_name  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.ctx_get(string context, int option_name) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.ctx_new\n \n \n \n                                                    Description\n                                                 \n Use  simZMQ.ctx_singleton  for sharing a global context. \n \n \n Lua synopsis \n string context=simZMQ.ctx_new() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n context  (string):  \n \n \n Python synopsis \n string context=simZMQ.ctx_new() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.ctx_set\n \n \n Lua synopsis \n int result=simZMQ.ctx_set(string context, int option_name, int option_value) \n \n \n \n Lua parameters \n \n \n context  (string):  \n \n option_name  (int):  \n \n option_value  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.ctx_set(string context, int option_name, int option_value) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.ctx_shutdown\n \n \n Lua synopsis \n int result=simZMQ.ctx_shutdown(string context) \n \n \n \n Lua parameters \n \n context  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.ctx_shutdown(string context) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.ctx_singleton\n \n \n \n                                                    Description\n                                                 \n This function, not part of the libzmq \nAPI, return a singleton context instance, useful for sharing a single \ncontext across different parts of the application. \n \n \n Lua synopsis \n string context=simZMQ.ctx_singleton() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n context  (string):  \n \n \n Python synopsis \n string context=simZMQ.ctx_singleton() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.ctx_term\n \n \n Lua synopsis \n int result=simZMQ.ctx_term(string context) \n \n \n \n Lua parameters \n \n context  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.ctx_term(string context) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.disconnect\n \n \n Lua synopsis \n int result=simZMQ.disconnect(string socket, string endpoint) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n endpoint  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.disconnect(string socket, string endpoint) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.errnum\n \n \n Lua synopsis \n int result=simZMQ.errnum() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.errnum() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.getsockopt\n \n \n Lua synopsis \n int result, string value=simZMQ.getsockopt(string socket, int option_name, int option_len) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n option_name  (int):  \n \n option_len  (int):  \n \n \n \n Lua return values \n \n \n result  (int):  \n \n value  (string):  \n \n \n \n Python synopsis \n int result, string value=simZMQ.getsockopt(string socket, int option_name, int option_len) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.has\n \n \n Lua synopsis \n int result=simZMQ.has(string capability) \n \n \n \n Lua parameters \n \n capability  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.has(string capability) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_close\n \n \n Lua synopsis \n int result=simZMQ.msg_close(string msg) \n \n \n \n Lua parameters \n \n msg  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_close(string msg) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_copy\n \n \n Lua synopsis \n int result=simZMQ.msg_copy(string dest, string src) \n \n \n \n Lua parameters \n \n \n dest  (string):  \n \n src  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_copy(string dest, string src) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_data\n \n \n Lua synopsis \n string data=simZMQ.msg_data(string msg) \n \n \n \n Lua parameters \n \n msg  (string):  \n \n \n Lua return values \n \n data  (string):  \n \n \n Python synopsis \n string data=simZMQ.msg_data(string msg) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_destroy\n \n \n Lua synopsis \n simZMQ.msg_destroy(string msg) \n \n \n \n Lua parameters \n \n msg  (string):  \n \n \n Lua return values \n - \n \n \n Python synopsis \n simZMQ.msg_destroy(string msg) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_get\n \n \n Lua synopsis \n int result=simZMQ.msg_get(string msg, int property) \n \n \n \n Lua parameters \n \n \n msg  (string):  \n \n property  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_get(string msg, int property) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_gets\n \n \n Lua synopsis \n int result, string value=simZMQ.msg_gets(string msg, string property) \n \n \n \n Lua parameters \n \n \n msg  (string):  \n \n property  (string):  \n \n \n \n Lua return values \n \n \n result  (int):  \n \n value  (string):  \n \n \n \n Python synopsis \n int result, string value=simZMQ.msg_gets(string msg, string property) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_init\n \n \n Lua synopsis \n int result=simZMQ.msg_init(string msg) \n \n \n \n Lua parameters \n \n msg  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_init(string msg) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_init_size\n \n \n Lua synopsis \n int result=simZMQ.msg_init_size(string msg, int size) \n \n \n \n Lua parameters \n \n \n msg  (string):  \n \n size  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_init_size(string msg, int size) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_more\n \n \n Lua synopsis \n int result=simZMQ.msg_more(string msg) \n \n \n \n Lua parameters \n \n msg  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_more(string msg) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_move\n \n \n Lua synopsis \n int result=simZMQ.msg_move(string dest, string src) \n \n \n \n Lua parameters \n \n \n dest  (string):  \n \n src  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_move(string dest, string src) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_new\n \n \n Lua synopsis \n string msg=simZMQ.msg_new() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n msg  (string):  \n \n \n Python synopsis \n string msg=simZMQ.msg_new() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_recv\n \n \n Lua synopsis \n int result=simZMQ.msg_recv(string msg, string socket, int flags) \n \n \n \n Lua parameters \n \n \n msg  (string):  \n \n socket  (string):  \n \n flags  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_recv(string msg, string socket, int flags) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_send\n \n \n Lua synopsis \n int result=simZMQ.msg_send(string msg, string socket, int flags) \n \n \n \n Lua parameters \n \n \n msg  (string):  \n \n socket  (string):  \n \n flags  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_send(string msg, string socket, int flags) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_set\n \n \n Lua synopsis \n int result=simZMQ.msg_set(string msg, int property, int value) \n \n \n \n Lua parameters \n \n \n msg  (string):  \n \n property  (int):  \n \n value  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_set(string msg, int property, int value) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.msg_size\n \n \n Lua synopsis \n int result=simZMQ.msg_size(string msg) \n \n \n \n Lua parameters \n \n msg  (string):  \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.msg_size(string msg) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.poll\n \n \n Lua synopsis \n int result, int[] revents=simZMQ.poll(string[] sockets, int[] events, int timeout=0) \n \n \n \n Lua parameters \n \n \n sockets  (table of string):  \n \n events  (table of int):  \n \n timeout  (int, default: 0):  \n \n \n \n Lua return values \n \n \n result  (int):  \n \n revents  (table of int):  \n \n \n \n Python synopsis \n int result, list revents=simZMQ.poll(list sockets, list events, int timeout=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.proxy\n \n \n Lua synopsis \n int result=simZMQ.proxy(string frontend, string backend, string capture) \n \n \n \n Lua parameters \n \n \n frontend  (string):  \n \n backend  (string):  \n \n capture  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.proxy(string frontend, string backend, string capture) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.proxy_steerable\n \n \n Lua synopsis \n int result=simZMQ.proxy_steerable(string frontend, string backend, string capture, string control) \n \n \n \n Lua parameters \n \n \n frontend  (string):  \n \n backend  (string):  \n \n capture  (string):  \n \n control  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.proxy_steerable(string frontend, string backend, string capture, string control) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.recv\n \n \n \n                                                    Description\n                                                 \n simZMQ implementation detail: if \nmax_buf_size is nil, a temporary zmq_msg_t data structure will be used \nto retrieve the full length message. \n \n \n Lua synopsis \n int result, string data=simZMQ.recv(string socket, int flags, int max_buf_size=nil) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n flags  (int):  \n \n max_buf_size  (int, default: nil):  \n \n \n \n Lua return values \n \n \n result  (int):  \n \n data  (string):  \n \n \n \n Python synopsis \n int result, string data=simZMQ.recv(string socket, int flags, int max_buf_size=nil) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.send\n \n \n Lua synopsis \n int result=simZMQ.send(string socket, string data, int flags) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n data  (string):  \n \n flags  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.send(string socket, string data, int flags) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.setsockopt\n \n \n Lua synopsis \n int result=simZMQ.setsockopt(string socket, int option_name, string option_value) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n option_name  (int):  \n \n option_value  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.setsockopt(string socket, int option_name, string option_value) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.socket\n \n \n Lua synopsis \n string socket=simZMQ.socket(string context, int type) \n \n \n \n Lua parameters \n \n \n context  (string):  \n \n type  (int):  \n \n \n \n Lua return values \n \n socket  (string):  \n \n \n Python synopsis \n string socket=simZMQ.socket(string context, int type) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.socket_monitor\n \n \n Lua synopsis \n int result=simZMQ.socket_monitor(string socket, string endpoint, int events) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n endpoint  (string):  \n \n events  (int):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.socket_monitor(string socket, string endpoint, int events) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.strerror\n \n \n Lua synopsis \n string message=simZMQ.strerror(int errnum) \n \n \n \n Lua parameters \n \n errnum  (int):  \n \n \n Lua return values \n \n message  (string):  \n \n \n Python synopsis \n string message=simZMQ.strerror(int errnum) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.unbind\n \n \n Lua synopsis \n int result=simZMQ.unbind(string socket, string endpoint) \n \n \n \n Lua parameters \n \n \n socket  (string):  \n \n endpoint  (string):  \n \n \n \n Lua return values \n \n result  (int):  \n \n \n Python synopsis \n int result=simZMQ.unbind(string socket, string endpoint) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simZMQ.version\n \n \n Lua synopsis \n int major, int minor, int patch=simZMQ.version() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n \n major  (int):  \n \n minor  (int):  \n \n patch  (int):  \n \n \n \n Python synopsis \n int major, int minor, int patch=simZMQ.version() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'ZMQPluginAPIreference.html'}, {'title': 'WSPluginAPIreference', 'text': "\n WS Plugin API reference \n WebSocket plugin. \n simWS.send \n simWS.setCloseHandler \n simWS.setFailHandler \n simWS.setHTTPHandler \n simWS.setMessageHandler \n simWS.setOpenHandler \n simWS.start \n simWS.stop \n \n \n \n simWS.send\n \n \n \n                                                    Description\n                                                 \n \n            Send data over the socket.\n         \n \n \n Lua synopsis \n simWS.send(string serverHandle, string connectionHandle, string data, int opcode=sim_ws_opcode_text) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n connectionHandle  (string):  \n \n data  (string):  \n \n opcode  (int, default: sim_ws_opcode_text):  \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simWS.send(string serverHandle, string connectionHandle, string data, int opcode=sim_ws_opcode_text) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simWS.setCloseHandler\n \n \n \n                                                    Description\n                                                 \n \n            The close handler is called once for every successfully \nestablished connection after it is no longer capable of sending or \nreceiving new messages.\n         \n \n \n Lua synopsis \n simWS.setCloseHandler(string serverHandle, string callbackFn) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n callbackFn  (string):  \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simWS.setCloseHandler(string serverHandle, string callbackFn) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simWS.setFailHandler\n \n \n \n                                                    Description\n                                                 \n \n            The fail handler is called once for every unsuccessful \nWebSocket connection attempt. Either the fail handler or the open \nhandler will be called for each WebSocket connection attempt. HTTP \nConnections that did not attempt to upgrade the connection to the \nWebSocket protocol will trigger the http handler instead of fail/open.\n         \n \n \n Lua synopsis \n simWS.setFailHandler(string serverHandle, string callbackFn) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n callbackFn  (string):  \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simWS.setFailHandler(string serverHandle, string callbackFn) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simWS.setHTTPHandler\n \n \n \n                                                    Description\n                                                 \n \n            The http handler is called when an HTTP connection is made \nthat does not attempt to upgrade the connection to the WebSocket \nprotocol. This allows to deliver error pages and static files such as \nthe base HTML and JavaScript for an otherwise single page WebSocket \napplication. Note: The HTTP handler is appropriate only for low volume \nHTTP traffic. If you expect to serve high volumes of HTTP traffic a \ndedicated HTTP web server is strongly recommended.\n         \n \n \n Lua synopsis \n simWS.setHTTPHandler(string serverHandle, string callbackFn) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n callbackFn  (string):  \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simWS.setHTTPHandler(string serverHandle, string callbackFn) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simWS.setMessageHandler\n \n \n \n                                                    Description\n                                                 \n \n            The message handler is called after a new message has been received.\n         \n \n \n Lua synopsis \n simWS.setMessageHandler(string serverHandle, string callbackFn) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n callbackFn  (string):  \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simWS.setMessageHandler(string serverHandle, string callbackFn) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simWS.setOpenHandler\n \n \n \n                                                    Description\n                                                 \n \n            The open handler is called once for every successful \nWebSocket connection attempt. Either the fail handler or the open \nhandler will be called for each WebSocket connection attempt. HTTP \nConnections that did not attempt to upgrade the connection to the \nWebSocket protocol will trigger the http handler instead of fail/open.\n         \n \n \n Lua synopsis \n simWS.setOpenHandler(string serverHandle, string callbackFn) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n callbackFn  (string):  \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simWS.setOpenHandler(string serverHandle, string callbackFn) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simWS.start\n \n \n \n                                                    Description\n                                                 \n \n            Set up endpoint for listening on a port, and starts the server's async connection acceptance loop.\n         \n \n \n Lua synopsis \n string serverHandle=simWS.start(int listenPort) \n \n \n \n Lua parameters \n \n listenPort  (int):  \n \n \n Lua return values \n \n serverHandle  (string):  \n \n \n Python synopsis \n string serverHandle=simWS.start(int listenPort) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simWS.stop\n \n \n \n                                                    Description\n                                                 \n \n            Stop and destroy the server.\n         \n \n \n Lua synopsis \n simWS.stop(string serverHandle) \n \n \n \n Lua parameters \n \n serverHandle  (string):  \n \n \n Lua return values \n \n \n \n Python synopsis \n simWS.stop(string serverHandle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simWS.opcode\n \n continuation \n text \n binary \n \n \n \n \n Script functions \n Script functions are used to call some lua code from the plugin side (tipically used for event handlers). \n \n openCallback\n \n \n \n                                                    Description\n                                                 \n \n \n \n Lua synopsis \n simWS.openCallback(string serverHandle, string connectionHandle) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n connectionHandle  (string):  \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simWS.openCallback(string serverHandle, string connectionHandle) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n failCallback\n \n \n \n                                                    Description\n                                                 \n \n \n \n Lua synopsis \n simWS.failCallback(string serverHandle, string connectionHandle) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n connectionHandle  (string):  \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simWS.failCallback(string serverHandle, string connectionHandle) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n closeCallback\n \n \n \n                                                    Description\n                                                 \n \n \n \n Lua synopsis \n simWS.closeCallback(string serverHandle, string connectionHandle) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n connectionHandle  (string):  \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simWS.closeCallback(string serverHandle, string connectionHandle) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n messageCallback\n \n \n \n                                                    Description\n                                                 \n \n \n \n Lua synopsis \n simWS.messageCallback(string serverHandle, string connectionHandle, string data) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n connectionHandle  (string):  \n \n data  (string):  \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simWS.messageCallback(string serverHandle, string connectionHandle, string data) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n httpCallback\n \n \n \n                                                    Description\n                                                 \n \n \n \n Lua synopsis \n int status, string data=simWS.httpCallback(string serverHandle, string connectionHandle, string resource, string data) \n \n \n \n Lua parameters \n \n \n serverHandle  (string):  \n \n connectionHandle  (string):  \n \n resource  (string):  \n \n data  (string):  \n \n \n \n Lua return values \n \n \n status  (int):  \n \n data  (string):  \n \n \n \n Python synopsis \n int status, string data=simWS.httpCallback(string serverHandle, string connectionHandle, string resource, string data) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n \n ,  ,  ,  , ", 'tags': '', 'url': 'WSPluginAPIreference.html'}, {'title': 'pathsAndTrajectories', 'text': '\n \n \n \n \n Paths/trajectories \n A path or trajectory is basically just data or a data structure appropriately generated or interpreted. The type of underlying data can be very varied and can represent 1D, 2D or 3D positions, but also orientations, poses, robot configurations/states, etc. For that reason it really depends on the user how that data structure is implemented in code. CoppeliaSim offers several helper  API functions related to paths/trajectories , meant to create, interpret and manipulate basic path/trajectory data. \n There is however one particular type of path data that is often used and that can also be represented in 3D space: poses, i.e. positions and orientations. CoppeliaSim offers for this type of data a  path object , that also allows simple visual creation of such data sets, by allowing to manipulate control points, which act as support of the underlying curve: \n \n [Simple path object, composed of 100 pose data points] \n \n \n \n \n', 'tags': '', 'url': 'pathsAndTrajectories.html'}, {'title': 'pathAndMotionPlanningModules', 'text': "\n \n \n \n \n Path/motion planning \n CoppeliaSim offers path/motion planning functionality via a plugin wrapping the  OMPL library . The plugin, courtesy of Federico Ferri, exports several  API functions related to OMPL . Its source code can be found  here . \n Following points should be considered when preparing a path/motion planning task: \n Decide of a start and goal state. When the path planning object is a serial manipulator, a goal pose (or end-effector position/orientation) is often provided instead of a goal state. In that case function  simIK.getConfigForTipPose  can be used to find one or several goal states that satisfy the provided goal pose. \n Create a path planning task with  simOMPL.createTask . \n Select an algorithm with  simOMPL.setAlgorithm . \n Create the required state space, which can be composed as a compound object:  simOMPL.createStateSpace  and  simOMPL.setStateSpace . \n Specify which entities are not allowed to collide with  simOMPL.setCollisionPairs . \n Specify the start and goal state with  simOMPL.setStartState  and  simOMPL.setGoalState . \n Call  simOMPL.setup  once to initialize OMPL's data structures. \n Compute one (or more) paths with  simOMPL.compute ; when called multiple times it will reuse previously computed data, if the chosen algorithm supports it, e.g.: multi-query planners such as PRM. \n Destroy the path planning task with  simOMPL.destroyTask . \n Often, path planning is used in combination with  inverse kinematics : in a pick-and-place task for instance, the final approach should usually be a straight-line path, which can be generated with  simIK.generatePath . \n Above procedure is the  regular  approach, which sometimes lacks flexibility. Additionally, following callback functions can be set-up: \n simOMPL.setStateValidationCallback \n simOMPL.setProjectionEvaluationCallback \n simOMPL.setGoalCallback \n Path optimality \n Most of the planners use randomized algorithms, which don't provide optimal (i.e. shortest) paths. Some of those are  optimizing  planners, meaning that they are still randomized, but will use the remaining planning time to improve the first solution found, thus giving an  asymptotic optimality  guarantee. \n If a short path is preferable, then an optimizing planner (such as RRT*, PRM*, ...) should be used. \n Multi-query planners \n When using multi-query planners (PRM, PRM*, ...), just call  simOMPL.setStartState  and  simOMPL.compute  again. Planning will re-use and expand the previously built roadmap. \n \xa0 \n Make sure to refer to following demo scenes for additional details: \n scenes/kinematics/8-computingJointAnglesForRandomPoses.ttt \n scenes/3DoFHolonomicPathPlanning.ttt \n scenes/6DoFHolonomicPathPlanning.ttt \n motionPlanningDemo1 \n motionPlanningAndGraspingDemo.ttt \n \n \n \n \n", 'tags': '', 'url': 'pathAndMotionPlanningModules.html'}, {'title': 'OMPLPluginAPIreference', 'text': "\n OMPL Plugin API reference \n The list of API functions below allows you to define and solve a motion planning problem with OMPL. \n simOMPL.addGoalState \n simOMPL.compute \n simOMPL.createStateSpace \n simOMPL.createTask \n simOMPL.destroyStateSpace \n simOMPL.destroyTask \n simOMPL.drawPath \n simOMPL.drawPlannerData \n simOMPL.enforceBounds \n simOMPL.getGoalDistance \n simOMPL.getPath \n simOMPL.getPathState \n simOMPL.getPathStateCount \n simOMPL.getPlannerData \n simOMPL.getProjectedPathLength \n simOMPL.getReversedPath \n simOMPL.getStateSpaceDimension \n simOMPL.hasApproximateSolution \n simOMPL.hasExactSolution \n simOMPL.hasSolution \n simOMPL.interpolatePath \n simOMPL.isStateValid \n simOMPL.isStateWithinBounds \n simOMPL.printTaskInfo \n simOMPL.projectStates \n simOMPL.projectionSize \n simOMPL.readState \n simOMPL.removeDrawingObjects \n simOMPL.setAlgorithm \n simOMPL.setCollisionPairs \n simOMPL.setDubinsParams \n simOMPL.setGoal \n simOMPL.setGoalCallback \n simOMPL.setGoalState \n simOMPL.setGoalStates \n simOMPL.setProjectionEvaluationCallback \n simOMPL.setStartState \n simOMPL.setStateSpace \n simOMPL.setStateValidationCallback \n simOMPL.setStateValidityCheckingResolution \n simOMPL.setValidStateSamplerCallback \n simOMPL.setVerboseLevel \n simOMPL.setup \n simOMPL.simplifyPath \n simOMPL.solve \n simOMPL.stateDistance \n simOMPL.writeState \n \n \n \n simOMPL.addGoalState\n \n \n \n                                                    Description\n                                                 \n Add a goal state, without clearing previously set goal state(s), if any. \n \n \n Lua synopsis \n simOMPL.addGoalState(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): a table of numbers, whose size must be consistent with the robot's state space specified in this task object \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.addGoalState(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates \n \n \n \n \n simOMPL.compute\n \n \n \n                                                    Description\n                                                 \n Use OMPL to find a solution for this motion planning task.\n             \n            It is equivalent to executing:\n             \n if  simOMPL.solve(task, maxTime)  then \n    simOMPL.simplifyPath(task, maxSimplificationTime)\n    simOMPL.interpolatePath(task, stateCnt)\n     path  = simOMPL.getPath(task)\n end \n \n \n \n \n Lua synopsis \n bool solved, float[] states=simOMPL.compute(string taskHandle, float maxTime, float maxSimplificationTime=-1.0, int stateCnt=0) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n maxTime  (float): maximum time used for the path searching procedure, in seconds. \n \n maxSimplificationTime  (float, default: -1.0): maximum \ntime used for the path simplification procedure, in seconds. -1 for a \ndefault simplification procedure. \n \n stateCnt  (int, default: 0): minimum number of states to be returned. 0 for a default behaviour. \n \n \n \n Lua return values \n \n \n solved  (bool): true if a solution has been found. \n \n states  (table of float): a table of states, representing the solution, from start to goal. States are specified linearly. \n \n \n \n Python synopsis \n bool solved, list states=simOMPL.compute(string taskHandle, float maxTime, float maxSimplificationTime=-1.0, int stateCnt=0) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve   simOMPL.drawPath   simOMPL.getPath   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.getProjectedPathLength   simOMPL.getReversedPath   simOMPL.projectStates \n \n \n \n \n simOMPL.createStateSpace\n \n \n \n                                                    Description\n                                                 \n Create a component of the state space for the motion planning problem.\n             \n            In case of a dubins state space, set additional parameters with  simOMPL.setDubinsParams \n \n \n \n Lua synopsis \n string \nstateSpaceHandle=simOMPL.createStateSpace(string name, int type, int \nobjectHandle, float[] boundsLow, float[] boundsHigh, int \nuseForProjection, float weight=1.0, int refObjectHandle=-1) \n \n \n \n Lua parameters \n \n \n name  (string): a name for this state space \n \n type  (int): type of this state space component (see  simOMPL.StateSpaceType ) \n \n objectHandle  (int): the object handle (a joint object \nif type is simOMPL.StateSpaceType.joint_position or \n.cyclic_joint_position, otherwise a shape) \n \n boundsLow  (table of float): lower bounds (if type is pose, specify only the 3 position components) \n \n boundsHigh  (table of float): upper bounds (if type is pose, specify only the 3 position components) \n \n useForProjection  (int): if true, this object position or joint value will be used for computing a default projection \n \n weight  (float, default: 1.0): the weight of this state \nspace component, used for computing distance between states. Default \nvalue is 1.0 \n \n refObjectHandle  (int, default: -1): an object handle \nrelative to which reference frame position/orientations will be \nevaluated. Default value is -1, for the absolute reference frame \n \n \n \n Lua return values \n \n stateSpaceHandle  (string): a handle to the created state space component \n \n \n Python synopsis \n string \nstateSpaceHandle=simOMPL.createStateSpace(string name, int type, int \nobjectHandle, list boundsLow, list boundsHigh, int useForProjection, \nfloat weight=1.0, int refObjectHandle=-1) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.destroyStateSpace   simOMPL.getStateSpaceDimension   simOMPL.setDubinsParams   simOMPL.setStateSpace \n \n \n \n \n simOMPL.createTask\n \n \n \n                                                    Description\n                                                 \n Create a task object, used to represent the motion planning task.\n             \n            A task object contains informations about:\n             \n collision pairs (used by the default state validity checker) \n state spaces \n start state \n goal state, or goal specification (e.g. pair of dummies, Lua callback, ...) \n various Lua callbacks (projection evaluation, state validation, goal satisfaction) \n \n \n \n \n Lua synopsis \n string taskHandle=simOMPL.createTask(string name) \n \n \n \n Lua parameters \n \n name  (string): a name for this task object \n \n \n Lua return values \n \n taskHandle  (string): a handle to the created task object \n \n \n Python synopsis \n string taskHandle=simOMPL.createTask(string name) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.destroyStateSpace\n \n \n \n                                                    Description\n                                                 \n Destroy the spacified state space component.\n             \n \n            Note: state space components created during simulation are automatically destroyed when simulation ends.\n         \n \n \n Lua synopsis \n simOMPL.destroyStateSpace(string stateSpaceHandle) \n \n \n \n Lua parameters \n \n stateSpaceHandle  (string): handle to state space component \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.destroyStateSpace(string stateSpaceHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.createStateSpace   simOMPL.getStateSpaceDimension   simOMPL.setDubinsParams   simOMPL.setStateSpace \n \n \n \n \n simOMPL.destroyTask\n \n \n \n                                                    Description\n                                                 \n Destroy the specified task object.\n             \n \n            Note: task objects created during simulation are automatically destroyed when simulation ends.\n         \n \n \n Lua synopsis \n simOMPL.destroyTask(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.destroyTask(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.drawPath\n \n \n \n                                                    Description\n                                                 \n draw a solution path for the specified motion planning task (as lines) \n \n \n Lua synopsis \n int[] dwos=simOMPL.drawPath(string taskHandle, float[] path, float lineSize, float[3] color, int extraAttributes) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): the handle of the task \n \n path  (table of float): the path, as returned by simOMPL.getPath \n \n lineSize  (float): size of the line (in pixels) \n \n color  (table of float, size 3): color of the lines \n \n extraAttributes  (int): extra attributes to pass to sim.addDrawingObject \n \n \n \n Lua return values \n \n dwos  (table of int): a table of handles of new drawing objects \n \n \n Python synopsis \n list dwos=simOMPL.drawPath(string taskHandle, list path, float lineSize, list color, int extraAttributes) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getPath   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.getProjectedPathLength   simOMPL.getReversedPath   simOMPL.projectStates   simOMPL.drawPlannerData   simOMPL.removeDrawingObjects \n \n \n \n \n simOMPL.drawPlannerData\n \n \n \n                                                    Description\n                                                 \n draw planner data (graph) extracted from the specified motion planning task \n \n \n Lua synopsis \n int[] dwos=simOMPL.drawPlannerData(string \ntaskHandle, float pointSize, float lineSize, float[3] color, float[3] \nstartColor, float[3] goalColor) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): handle of the task \n \n pointSize  (float): size of nodes (in meters) \n \n lineSize  (float): size of lines (in pixels) \n \n color  (table of float, size 3): color of nodes and lines \n \n startColor  (table of float, size 3): color of start nodes \n \n goalColor  (table of float, size 3): color of goal nodes \n \n \n \n Lua return values \n \n dwos  (table of int): a table of handles of new drawing objects \n \n \n Python synopsis \n list dwos=simOMPL.drawPlannerData(string \ntaskHandle, float pointSize, float lineSize, list color, list \nstartColor, list goalColor) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.drawPath   simOMPL.removeDrawingObjects \n \n \n \n \n simOMPL.enforceBounds\n \n \n \n                                                    Description\n                                                 \n Bring the state within the bounds of the state space. \n \n \n Lua synopsis \n float[] state=simOMPL.enforceBounds(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): state vector \n \n \n \n Lua return values \n \n state  (table of float): state vector \n \n \n Python synopsis \n list state=simOMPL.enforceBounds(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.isStateValid   simOMPL.isStateWithinBounds   simOMPL.projectStates   simOMPL.readState   simOMPL.stateDistance   simOMPL.writeState \n \n \n \n \n simOMPL.getGoalDistance\n \n \n \n                                                    Description\n                                                 \n Get the distance to the desired goal for the top solution. \n \n \n Lua synopsis \n float distance=simOMPL.getGoalDistance(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n \n distance  (float): distance to the desired goal for the top solution, or -1.0 if there are no solutions available \n \n \n Python synopsis \n float distance=simOMPL.getGoalDistance(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve \n \n \n \n \n simOMPL.getPath\n \n \n \n                                                    Description\n                                                 \n Return the top solution path, if one is found.\n             \n            The top path is the shortest one that was found, preference being given to solutions that are not approximate.\n         \n \n \n Lua synopsis \n float[] states=simOMPL.getPath(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n \n states  (table of float): a table of states, representing the solution, from start to goal. States are specified linearly. \n \n \n Python synopsis \n list states=simOMPL.getPath(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve   simOMPL.compute   simOMPL.drawPath   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.getProjectedPathLength   simOMPL.getReversedPath   simOMPL.projectStates \n \n \n \n \n simOMPL.getPathState\n \n \n \n                                                    Description\n                                                 \n extract the state at specified index from the given path \n \n \n Lua synopsis \n float[] state=simOMPL.getPathState(string taskHandle, float[] path, int index) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): the handle of the task \n \n path  (table of float): the path, as returned by simOMPL.getPath \n \n index  (int): the index, starting from 1 \n \n \n \n Lua return values \n \n state  (table of float): a state extracted from the path \n \n \n Python synopsis \n list state=simOMPL.getPathState(string taskHandle, list path, int index) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.drawPath   simOMPL.getPath   simOMPL.getPathStateCount   simOMPL.getProjectedPathLength   simOMPL.getReversedPath   simOMPL.projectStates   simOMPL.enforceBounds   simOMPL.getPathStateCount   simOMPL.isStateValid   simOMPL.isStateWithinBounds   simOMPL.projectStates   simOMPL.readState   simOMPL.stateDistance   simOMPL.writeState \n \n \n \n \n simOMPL.getPathStateCount\n \n \n \n                                                    Description\n                                                 \n get the number of states in the given path \n \n \n Lua synopsis \n int count=simOMPL.getPathStateCount(string taskHandle, float[] path) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): the handle of the task \n \n path  (table of float): the path, as returned by simOMPL.getPath \n \n \n \n Lua return values \n \n count  (int): the number of states in the path \n \n \n Python synopsis \n int count=simOMPL.getPathStateCount(string taskHandle, list path) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.drawPath   simOMPL.getPath   simOMPL.getPathState   simOMPL.getProjectedPathLength   simOMPL.getReversedPath   simOMPL.projectStates   simOMPL.enforceBounds   simOMPL.getPathState   simOMPL.isStateValid   simOMPL.isStateWithinBounds   simOMPL.projectStates   simOMPL.readState   simOMPL.stateDistance   simOMPL.writeState \n \n \n \n \n simOMPL.getPlannerData\n \n \n \n                                                    Description\n                                                 \n Get planner data for this motion planning task.\n             \n            Data is represented as a graph. For each graph vertex, a \nstate and a tag are returned. A list of edges is returned as well, as \npairs of vertex indices, describing connectivity of vertices. Some \nvertices are marked start or goal.\n         \n \n \n Lua synopsis \n float[] states, int[] tags, float[] \ntagsReal, int[] edges, float[] edgeWeights, int[] startVertices, int[] \ngoalVertices=simOMPL.getPlannerData(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask . \n \n \n Lua return values \n \n \n states  (table of float): a table of states, \nrepresenting the configurations in the constructed search graph. States \nare specified linearly. \n \n tags  (table of int): a table of tags (one integer for every vertex) \n \n tagsReal  (table of float): a table of tags (one float for every vertex) \n \n edges  (table of int): the pairs of vertex indices describing vertex connectivity \n \n edgeWeights  (table of float): the weight (cost) associated to each edge \n \n startVertices  (table of int): the indices of vertices marked 'start' \n \n goalVertices  (table of int): the indices of vertices marked 'goal' \n \n \n \n Python synopsis \n list states, list tags, list tagsReal, \nlist edges, list edgeWeights, list startVertices, list \ngoalVertices=simOMPL.getPlannerData(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve \n \n \n \n \n simOMPL.getProjectedPathLength\n \n \n \n                                                    Description\n                                                 \n get the length of the path projected onto the default projection \n \n \n Lua synopsis \n simOMPL.getProjectedPathLength(string taskHandle, float[] path) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): the handle of the task \n \n path  (table of float): the path, as returned by simOMPL.getPath \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.getProjectedPathLength(string taskHandle, list path) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.drawPath   simOMPL.getPath   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.getReversedPath   simOMPL.projectStates   simOMPL.projectStates   simOMPL.projectionSize   simOMPL.setProjectionEvaluationCallback \n \n \n \n \n simOMPL.getReversedPath\n \n \n \n                                                    Description\n                                                 \n reverse the given path \n \n \n Lua synopsis \n float[] reversedPath=simOMPL.getReversedPath(string taskHandle, float[] path) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): the handle of the task \n \n path  (table of float): the path, as returned by simOMPL.getPath \n \n \n \n Lua return values \n \n reversedPath  (table of float): the reversed path \n \n \n Python synopsis \n list reversedPath=simOMPL.getReversedPath(string taskHandle, list path) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.drawPath   simOMPL.getPath   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.getProjectedPathLength   simOMPL.projectStates \n \n \n \n \n simOMPL.getStateSpaceDimension\n \n \n \n                                                    Description\n                                                 \n Get the dimension of the state space, i.e. the number of elements of a state. \n \n \n Lua synopsis \n int dim=simOMPL.getStateSpaceDimension(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n \n dim  (int): dimension of the state space \n \n \n Python synopsis \n int dim=simOMPL.getStateSpaceDimension(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.createStateSpace   simOMPL.destroyStateSpace   simOMPL.setDubinsParams   simOMPL.setStateSpace \n \n \n \n \n simOMPL.hasApproximateSolution\n \n \n \n                                                    Description\n                                                 \n Return true if the top found solution is approximate.\n             \n            An approximate solution does not actually reach the desired goal, but hopefully is closer to it.\n         \n \n \n Lua synopsis \n bool result=simOMPL.hasApproximateSolution(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n \n result  (bool): true if the top found solution is approximate \n \n \n Python synopsis \n bool result=simOMPL.hasApproximateSolution(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve \n \n \n \n \n simOMPL.hasExactSolution\n \n \n \n                                                    Description\n                                                 \n Returns true if an exact solution path has been found.\n             \n            Specifically returns hasSolution() and not hasApproximateSolution()\n         \n \n \n Lua synopsis \n bool result=simOMPL.hasExactSolution(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n \n result  (bool): true if an exact solution path has been found \n \n \n Python synopsis \n bool result=simOMPL.hasExactSolution(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve \n \n \n \n \n simOMPL.hasSolution\n \n \n \n                                                    Description\n                                                 \n Returns true if a solution path has been found (could be approximate). \n \n \n Lua synopsis \n bool result=simOMPL.hasSolution(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n \n result  (bool): true if a solution path has been found (could be approximate) \n \n \n Python synopsis \n bool result=simOMPL.hasSolution(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve \n \n \n \n \n simOMPL.interpolatePath\n \n \n \n                                                    Description\n                                                 \n Interpolate the path found by planner to obtain a minimum number of states. \n \n \n Lua synopsis \n simOMPL.interpolatePath(string taskHandle, int stateCnt=0) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n stateCnt  (int, default: 0): minimum number of states to be returned. 0 for a default behaviour. \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.interpolatePath(string taskHandle, int stateCnt=0) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.setAlgorithm   simOMPL.simplifyPath   simOMPL.solve \n \n \n \n \n simOMPL.isStateValid\n \n \n \n                                                    Description\n                                                 \n Check if the specified state is valid.\n             \n            If a state validation callback has been specified, that will\n be used to determine the validity of the state, otherwise the default \nstate validation method will be used.\n         \n \n \n Lua synopsis \n bool valid=simOMPL.isStateValid(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): state vector \n \n \n \n Lua return values \n \n valid  (bool): true if the state is valid \n \n \n Python synopsis \n bool valid=simOMPL.isStateValid(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.enforceBounds   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.isStateWithinBounds   simOMPL.projectStates   simOMPL.readState   simOMPL.stateDistance   simOMPL.writeState \n \n \n \n \n simOMPL.isStateWithinBounds\n \n \n \n                                                    Description\n                                                 \n Check if the specified state is inside the bounding box. \n \n \n Lua synopsis \n bool valid=simOMPL.isStateWithinBounds(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): state vector \n \n \n \n Lua return values \n \n valid  (bool): true if the state is within the bounding box \n \n \n Python synopsis \n bool valid=simOMPL.isStateWithinBounds(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.enforceBounds   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.isStateValid   simOMPL.projectStates   simOMPL.readState   simOMPL.stateDistance   simOMPL.writeState \n \n \n \n \n simOMPL.printTaskInfo\n \n \n \n                                                    Description\n                                                 \n Print a summary of the specified task object.\n             \n            Useful for debugging and submitting bug reports.\n         \n \n \n Lua synopsis \n simOMPL.printTaskInfo(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.printTaskInfo(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.projectStates\n \n \n \n                                                    Description\n                                                 \n Project a state using the task's projection evaluation routine.\n             \n            If multiple states are specified (e.g. a path) multiple projections will be returned.\n         \n \n \n Lua synopsis \n float[] projection=simOMPL.projectStates(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): state vector(s) \n \n \n \n Lua return values \n \n projection  (table of float): state projection vector(s) \n \n \n Python synopsis \n list projection=simOMPL.projectStates(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.enforceBounds   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.isStateValid   simOMPL.isStateWithinBounds   simOMPL.readState   simOMPL.stateDistance   simOMPL.writeState   simOMPL.getProjectedPathLength   simOMPL.projectionSize   simOMPL.setProjectionEvaluationCallback   simOMPL.compute   simOMPL.drawPath   simOMPL.getPath   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.getProjectedPathLength   simOMPL.getReversedPath \n \n \n \n \n simOMPL.projectionSize\n \n \n \n                                                    Description\n                                                 \n return the dimension of the projection \n \n \n Lua synopsis \n int size=simOMPL.projectionSize(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): the handle of the task \n \n \n Lua return values \n \n size  (int): of the projection \n \n \n Python synopsis \n int size=simOMPL.projectionSize(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.getProjectedPathLength   simOMPL.projectStates   simOMPL.setProjectionEvaluationCallback \n \n \n \n \n simOMPL.readState\n \n \n \n                                                    Description\n                                                 \n Read a state vector from current simulator state. \n \n \n Lua synopsis \n float[] state=simOMPL.readState(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n \n state  (table of float): state vector \n \n \n Python synopsis \n list state=simOMPL.readState(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.enforceBounds   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.isStateValid   simOMPL.isStateWithinBounds   simOMPL.projectStates   simOMPL.stateDistance   simOMPL.writeState \n \n \n \n \n simOMPL.removeDrawingObjects\n \n \n \n                                                    Description\n                                                 \n remove the drawing objects created with related functions \n \n \n Lua synopsis \n simOMPL.removeDrawingObjects(string taskHandle, int[] dwos) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): handle of the task \n \n dwos  (table of int): table of handles to drawing objects, as returned by the functions \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.removeDrawingObjects(string taskHandle, list dwos) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.drawPath   simOMPL.drawPlannerData \n \n \n \n \n simOMPL.setAlgorithm\n \n \n \n                                                    Description\n                                                 \n Set the search algorithm for the specified task. Default algorithm used is KPIECE1. \n \n \n Lua synopsis \n simOMPL.setAlgorithm(string taskHandle, int algorithm) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n algorithm  (int): see  simOMPL.Algorithm \n \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setAlgorithm(string taskHandle, int algorithm) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.simplifyPath   simOMPL.solve \n \n \n \n \n simOMPL.setCollisionPairs\n \n \n \n                                                    Description\n                                                 \n Set the collision pairs for the specified task object. \n \n \n Lua synopsis \n simOMPL.setCollisionPairs(string taskHandle, int[] collisionPairHandles) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n collisionPairHandles  (table of int): a table containing\n 2 entity handles for each collision pair. A collision pair is \nrepresented by a collider and a collidee, that will be tested against \neach other. The collider can be an object or a collection handle. The \ncollidee can be an object or collection handle, or sim_handle_all, in \nwhich case the collider will be checked agains all other collidable \nobjects in the scene. \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setCollisionPairs(string taskHandle, list collisionPairHandles) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.setDubinsParams\n \n \n \n                                                    Description\n                                                 \n Set extra state space parameters of a dubins state space. \n \n \n Lua synopsis \n simOMPL.setDubinsParams(string stateSpaceHandle, float turningRadius, bool isSymmetric) \n \n \n \n Lua parameters \n \n \n stateSpaceHandle  (string): handle to state space component \n \n turningRadius  (float): turning radius \n \n isSymmetric  (bool): true if it is symmetric, otherwise false \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setDubinsParams(string stateSpaceHandle, float turningRadius, bool isSymmetric) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.createStateSpace   simOMPL.destroyStateSpace   simOMPL.getStateSpaceDimension   simOMPL.setStateSpace \n \n \n \n \n simOMPL.setGoal\n \n \n \n                                                    Description\n                                                 \n Set the goal for the specificed task object by a dummy pair.\n             \n            One of the two dummies is part of the robot. The other dummy\n is fixed in the environment. When the task is solved, the position or \npose of the two dummies will (approximatively) be the same. Dummy-dummy \ndistances are relative to an optional reference dummy, and are evaluated\n using an optional metric\n         \n \n \n Lua synopsis \n simOMPL.setGoal(string taskHandle, int \nrobotDummy, int goalDummy, float tolerance=0.001f, float[] metric={1.0, \n1.0, 1.0, 0.1}, int refDummy=-1) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n robotDummy  (int): a dummy attached to the robot \n \n goalDummy  (int): a dummy fixed in the environment, representing the goal pose/position \n \n tolerance  (float, default: 0.001f): tolerated dummy-dummy distance \n \n metric  (table of float, default: {1.0, 1.0, 1.0, 0.1}): a metric (x,y,z,angle) used to evaluate the dummy-dummy distance \n \n refDummy  (int, default: -1): an reference dummy, relative to which the metric will be used \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setGoal(string taskHandle, int \nrobotDummy, int goalDummy, float tolerance=0.001f, list metric={1.0, \n1.0, 1.0, 0.1}, int refDummy=-1) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup   simOMPL.addGoalState   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates \n \n \n \n \n simOMPL.setGoalCallback\n \n \n \n                                                    Description\n                                                 \n Set a custom goal callback for the specified task.\n            See  goalCallback  for the arguments and the return values of the callback.\n             \n            If a distance to the goal is not known, a constant value can\n be used, but the performance of the algorithm will be worse.\n         \n \n \n Lua synopsis \n simOMPL.setGoalCallback(string taskHandle, string callback) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n callback  (string): name of the Lua callback \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setGoalCallback(string taskHandle, string callback) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup   simOMPL.addGoalState   simOMPL.setGoal   simOMPL.setGoalState   simOMPL.setGoalStates \n \n \n \n \n simOMPL.setGoalState\n \n \n \n                                                    Description\n                                                 \n Set the goal state for the specified task object. \n \n \n Lua synopsis \n simOMPL.setGoalState(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): a table of numbers, whose size must be consistent with the robot's state space specified in this task object \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setGoalState(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup   simOMPL.addGoalState   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalStates \n \n \n \n \n simOMPL.setGoalStates\n \n \n \n                                                    Description\n                                                 \n set multiple goal states at once, equivalent to calling simOMPL.setGoalState, simOMPL.addGoalState, simOMPL.addGoalState... \n \n \n Lua synopsis \n simOMPL.setGoalStates(string taskHandle, table states) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): the handle of the task \n \n states  (table, size 1..*): a table of tables, one element for each goal state \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setGoalStates(string taskHandle, list states) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup   simOMPL.addGoalState   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState \n \n \n \n \n simOMPL.setProjectionEvaluationCallback\n \n \n \n                                                    Description\n                                                 \n Set a custom projection evaluation.\n            See  projectionEvaluationCallback  for the arguments and the return values of the callback.\n         \n \n \n Lua synopsis \n simOMPL.setProjectionEvaluationCallback(string taskHandle, string callback, int projectionSize) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n callback  (string): name of the Lua callback \n \n projectionSize  (int): size of the projection (usually 2 or 3) \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setProjectionEvaluationCallback(string taskHandle, string callback, int projectionSize) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.getProjectedPathLength   simOMPL.projectStates   simOMPL.projectionSize   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.setStartState\n \n \n \n                                                    Description\n                                                 \n Set the start state for the specified task object. \n \n \n Lua synopsis \n simOMPL.setStartState(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): a table of numbers, whose size must be consistent with the robot's state space specified in this task object \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setStartState(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.setStateSpace\n \n \n \n                                                    Description\n                                                 \n Set the state space of this task object. \n \n \n Lua synopsis \n simOMPL.setStateSpace(string taskHandle, string[] stateSpaceHandles) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n stateSpaceHandles  (table of string): a table of handles to state space components, created with  simOMPL.createStateSpace \n \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setStateSpace(string taskHandle, list stateSpaceHandles) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.createStateSpace   simOMPL.destroyStateSpace   simOMPL.getStateSpaceDimension   simOMPL.setDubinsParams   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.setStateValidationCallback\n \n \n \n                                                    Description\n                                                 \n Set a custom state validation.\n            See  stateValidationCallback  for the arguments and the return values of the callback.\n             \n            By default state validation is performed by collision \nchecking, between robot's collision objects and environment's objects. \nBy specifying a custom state validation, it is possible to perform any \narbitrary check on a state to determine wether it is valid or not.\n         \n \n \n Lua synopsis \n simOMPL.setStateValidationCallback(string taskHandle, string callback) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n callback  (string): name of the Lua callback \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setStateValidationCallback(string taskHandle, string callback) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.setStateValidityCheckingResolution\n \n \n \n                                                    Description\n                                                 \n Set the resolution of state validity checking, expressed as fraction of state space's extent.\n             \n            Default resolution is 0.01 which is 1% of the state space's extent.\n         \n \n \n Lua synopsis \n simOMPL.setStateValidityCheckingResolution(string taskHandle, float resolution) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n resolution  (float): resolution of state validity checking, expressed as fraction of state space's extent \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setStateValidityCheckingResolution(string taskHandle, float resolution) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.setValidStateSamplerCallback\n \n \n \n                                                    Description\n                                                 \n Set a valid state sampler callbacks for the specified task.\n            See  validStateSamplerCallback  and  validStateSamplerCallbackNear  for the arguments and the return values of the callbacks.\n             \n            The valid state sampler callbacks must generate valid states.\n         \n \n \n Lua synopsis \n simOMPL.setValidStateSamplerCallback(string taskHandle, string callback, string callbackNear) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n callback  (string): the name of the Lua callback for sampling a state \n \n callbackNear  (string): the name of the Lua callback for sampling near a given state within the given distance \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setValidStateSamplerCallback(string taskHandle, string callback, string callbackNear) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setVerboseLevel   simOMPL.setup \n \n \n \n \n simOMPL.setVerboseLevel\n \n \n \n                                                    Description\n                                                 \n Set the verbosity level for messages printed to application console. \n \n \n Lua synopsis \n simOMPL.setVerboseLevel(string taskHandle, int verboseLevel) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n verboseLevel  (int): level of verbosity (positive integer), 0 to suppress any message \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setVerboseLevel(string taskHandle, int verboseLevel) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setup \n \n \n \n \n simOMPL.setup\n \n \n \n                                                    Description\n                                                 \n Setup the OMPL classes with the information contained in the task. \n \n \n Lua synopsis \n simOMPL.setup(string taskHandle) \n \n \n \n Lua parameters \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.setup(string taskHandle) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.addGoalState   simOMPL.createTask   simOMPL.destroyTask   simOMPL.printTaskInfo   simOMPL.setAlgorithm   simOMPL.setCollisionPairs   simOMPL.setGoal   simOMPL.setGoalCallback   simOMPL.setGoalState   simOMPL.setGoalStates   simOMPL.setProjectionEvaluationCallback   simOMPL.setStartState   simOMPL.setStateSpace   simOMPL.setStateValidationCallback   simOMPL.setStateValidityCheckingResolution   simOMPL.setValidStateSamplerCallback   simOMPL.setVerboseLevel \n \n \n \n \n simOMPL.simplifyPath\n \n \n \n                                                    Description\n                                                 \n Simplify the path found by planner. \n \n \n Lua synopsis \n simOMPL.simplifyPath(string taskHandle, float maxSimplificationTime=-1.0) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n maxSimplificationTime  (float, default: -1.0): maximum \ntime used for the path simplification procedure, in seconds. -1 for a \ndefault simplification procedure. \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.simplifyPath(string taskHandle, float maxSimplificationTime=-1.0) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.solve \n \n \n \n \n simOMPL.solve\n \n \n \n                                                    Description\n                                                 \n Run the planning algorithm to search for a solution. \n \n \n Lua synopsis \n bool solved=simOMPL.solve(string taskHandle, float maxTime) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n maxTime  (float): maximum time used for the path searching procedure, in seconds. \n \n \n \n Lua return values \n \n solved  (bool): true if a solution is found. \n \n \n Python synopsis \n bool solved=simOMPL.solve(string taskHandle, float maxTime) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.compute   simOMPL.getGoalDistance   simOMPL.getPath   simOMPL.getPlannerData   simOMPL.hasApproximateSolution   simOMPL.hasExactSolution   simOMPL.hasSolution   simOMPL.interpolatePath   simOMPL.setAlgorithm   simOMPL.simplifyPath \n \n \n \n \n simOMPL.stateDistance\n \n \n \n                                                    Description\n                                                 \n Compute the distanbce between two states. \n \n \n Lua synopsis \n float distance=simOMPL.stateDistance(string taskHandle, float[] a, float[] b) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n a  (table of float): state vector \n \n b  (table of float): state vector \n \n \n \n Lua return values \n \n distance  (float): computed distance \n \n \n Python synopsis \n float distance=simOMPL.stateDistance(string taskHandle, list a, list b) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.enforceBounds   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.isStateValid   simOMPL.isStateWithinBounds   simOMPL.projectStates   simOMPL.readState   simOMPL.writeState \n \n \n \n \n simOMPL.writeState\n \n \n \n                                                    Description\n                                                 \n Write the specified state to simulator \n \n \n Lua synopsis \n simOMPL.writeState(string taskHandle, float[] state) \n \n \n \n Lua parameters \n \n \n taskHandle  (string): a handle to a task object created with  simOMPL.createTask \n \n \n state  (table of float): state vector \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simOMPL.writeState(string taskHandle, list state) \n \n \n \n \n                                                See also\n                                             \n   simOMPL.enforceBounds   simOMPL.getPathState   simOMPL.getPathStateCount   simOMPL.isStateValid   simOMPL.isStateWithinBounds   simOMPL.projectStates   simOMPL.readState   simOMPL.stateDistance \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simOMPL.Algorithm\n \n BiTRRT \n BITstar \n BKPIECE1 \n CForest \n EST \n FMT \n KPIECE1 \n LazyPRM \n LazyPRMstar \n LazyRRT \n LBKPIECE1 \n LBTRRT \n PDST \n PRM \n PRMstar \n RRT \n RRTConnect \n RRTstar \n SBL \n SPARS \n SPARStwo \n STRIDE \n TRRT \n \n \n simOMPL.StateSpaceType\n \n position2d \n pose2d \n position3d \n pose3d \n joint_position \n dubins \n cyclic_joint_position \n \n \n \n \n Script functions \n Script functions are used to call some lua code from the plugin side (tipically used for event handlers). \n \n goalCallback\n \n \n \n                                                    Description\n                                                 \n Callback for checking if the goal is satisfied. \n \n \n Lua synopsis \n bool satisfied, float distance=simOMPL.goalCallback(float[] state) \n \n \n \n Lua parameters \n \n state  (table of float): the state to test for goal satisfaction \n \n \n Lua return values \n \n \n satisfied  (bool): true if satisfied, false otherwise \n \n distance  (float): distance to goal, if it is known. A \nconstant value can be returned otherwise, but the performance of the \nalgorithm will be worse. \n \n \n \n Python synopsis \n bool satisfied, float distance=simOMPL.goalCallback(list state) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n projectionEvaluationCallback\n \n \n \n                                                    Description\n                                                 \n Callback for computing a (euclidean) projection of states. \n \n \n Lua synopsis \n float[] projection=simOMPL.projectionEvaluationCallback(float[] state) \n \n \n \n Lua parameters \n \n state  (table of float): the state to compute the projection for \n \n \n Lua return values \n \n projection  (table of float): projected state, usualy of size 2 or 3, representing a point in plane or space. \n \n \n Python synopsis \n list projection=simOMPL.projectionEvaluationCallback(list state) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n stateValidationCallback\n \n \n \n                                                    Description\n                                                 \n Callback for checking the validity of states. \n \n \n Lua synopsis \n bool valid=simOMPL.stateValidationCallback(float[] state) \n \n \n \n Lua parameters \n \n state  (table of float): the state to compute the projection for \n \n \n Lua return values \n \n valid  (bool): true if valid, false otherwise \n \n \n Python synopsis \n bool valid=simOMPL.stateValidationCallback(list state) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n validStateSamplerCallback\n \n \n \n                                                    Description\n                                                 \n Callback for sampling valid states from the state space. \n \n \n Lua synopsis \n float[] sampledState=simOMPL.validStateSamplerCallback() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n sampledState  (table of float): a valid state \n \n \n Python synopsis \n list sampledState=simOMPL.validStateSamplerCallback() \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n validStateSamplerCallbackNear\n \n \n \n                                                    Description\n                                                 \n Callback for sampling valid states in the proximity of a given state, within a certain distance. \n \n \n Lua synopsis \n float[] sampledState=simOMPL.validStateSamplerCallbackNear(float[] state, float distance) \n \n \n \n Lua parameters \n \n \n state  (table of float): the center state \n \n distance  (float): distance bound \n \n \n \n Lua return values \n \n sampledState  (table of float): a valid state \n \n \n Python synopsis \n list sampledState=simOMPL.validStateSamplerCallbackNear(list state, float distance) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n \n ,  ,  ,  , ", 'tags': '', 'url': 'OMPLPluginAPIreference.html'}, {'title': 'syntheticVision', 'text': '\n \n \n \n \n Synthetic vision \n Synthetic vision is achieved in CoppeliaSim via  vision sensors : they can perform offscreen rendering of the scene in different modes. The generated image can then be modified/processed in various ways, for instance from within a  vision callback function : \n image processing with OpenCV  (via the  image plugin ) \n simple image processing  via the  vision plugin \n sim.transformImage \n sim.transformBuffer \n Following shows a vision callback function that illustrates 3 different ways to modify an acquired image: \n \nfunction sysCall_vision(inData)\n    -- inData.handle: handle of the vision sensor\n    -- inData.resolution: resolution of the vision sensor\n    -- inData.clippingPlanes: near and far clipping plane of the vision sensor\n    -- inData.viewAngle: the view angle if the vision sensor is in perspective operation\n    -- inData.orthoSize: the size of the view if the vision sensor is in orthogonal operation\n    -- inData.perspectiveOperation: whether the vision sensor is in perspective operation\n\n    -- e.g. use very simple functions from the vision plugin (simExtVision):\n    simVision.sensorImgToWorkImg(inData.handle)\n    simVision.edgeDetectionOnWorkImg(inData.handle,0.2)\n    simVision.swapWorkImgWithBuffer1(inData.handle)\n    simVision.uniformImgToWorkImg(inData.handle,{0.5,0.25,0})\n    simVision.addBuffer1ToWorkImg(inData.handle)\n    simVision.workImgToSensorImg(inData.handle)\n    \n    -- and/or, use more powerful functions from the image plugin (simExtImage):\n    if simIM then\n        local imgHandle=simIM.readFromVisionSensor(inData.handle)\n        local center={inData.resolution[1]/2,inData.resolution[2]/2}\n        local radius=(inData.resolution[1]+inData.resolution[2])/8\n        simIM.circle(imgHandle,center,radius,{255,255,0},4)\n        simIM.writeToVisionSensor(imgHandle,inData.handle)\n        simIM.destroy(imgHandle)\n    end\n\n    -- Or you can directly operate on the image buffer:\n    local image=sim.getVisionSensorImg(inData.handle)\n    sim.transformImage(image,inData.resolution,4)\n    image=sim.transformBuffer(image,sim.buffer_uint8rgb,1,0,sim.buffer_uint8bgr)\n    sim.setVisionSensorImg(inData.handle,image)\n    \n    outData={}\n    outData.trigger=true -- whether the sensor should trigger\n    -- filters may append packets (in packed form, use sim.packFloatTable to pack) to this table:\n    outData.packedPackets={sim.packFloatTable({1,42,57})} \n    return outData\nend \n \n \n \n \n', 'tags': '', 'url': 'syntheticVision.html'}, {'title': 'IMPluginAPIreference', 'text': '\n IM Plugin API reference \n Plugin for processing images \n simIM.abs \n simIM.absdiff \n simIM.absdiffK \n simIM.add \n simIM.addK \n simIM.addWeighted \n simIM.arrowedLine \n simIM.bitwiseAnd \n simIM.bitwiseAndK \n simIM.bitwiseNot \n simIM.bitwiseOr \n simIM.bitwiseOrK \n simIM.bitwiseXor \n simIM.bitwiseXorK \n simIM.cart2polar \n simIM.circle \n simIM.clipLine \n simIM.closeVideoCapture \n simIM.compare \n simIM.compareK \n simIM.convert \n simIM.copy \n simIM.create \n simIM.createFromData \n simIM.dataURL \n simIM.destroy \n simIM.distanceTransform \n simIM.divide \n simIM.divideK \n simIM.ellipse \n simIM.encode \n simIM.exp \n simIM.fillConvexPoly \n simIM.fillPoly \n simIM.flip \n simIM.get \n simIM.gray2rgb \n simIM.hls2rgb \n simIM.hsv2rgb \n simIM.line \n simIM.log \n simIM.magnitude \n simIM.merge \n simIM.mixChannels \n simIM.multiply \n simIM.openVideoCapture \n simIM.phase \n simIM.polar2cart \n simIM.polylines \n simIM.pow \n simIM.read \n simIM.readFromVideoCapture \n simIM.readFromVisionSensor \n simIM.rectangle \n simIM.reduce \n simIM.repeat \n simIM.resize \n simIM.rgb2gray \n simIM.rgb2hls \n simIM.rgb2hsv \n simIM.scaleAdd \n simIM.set \n simIM.size \n simIM.split \n simIM.sqrt \n simIM.subtract \n simIM.subtractK \n simIM.text \n simIM.textSize \n simIM.write \n simIM.writeToVisionSensor \n \n \n \n simIM.abs\n \n \n \n                                                    Description\n                                                 \n Calculates an absolute value of each pixel. \n \n \n Lua synopsis \n string handle=simIM.abs(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.abs(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.absdiff\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element absolute difference between two arrays. \n \n \n Lua synopsis \n string handle=simIM.absdiff(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.absdiff(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.absdiffK\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element absolute difference between an array and a scalar. \n \n \n Lua synopsis \n string handle=simIM.absdiffK(string handle, float[] k, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n k  (table of float): scalar \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.absdiffK(string handle, list k, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.add\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element sum of two arrays. \n \n \n Lua synopsis \n string handle=simIM.add(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.add(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.addK\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element sum of an array and a scalar. \n \n \n Lua synopsis \n string handle=simIM.addK(string handle, float[] k, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n k  (table of float): scalar \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.addK(string handle, list k, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.addWeighted\n \n \n \n                                                    Description\n                                                 \n Calculates the weighted sum of two arrays, i.e. DST(i) = SRC1(i)*alpha + SRC2(i)*beta + gamma. \n \n \n Lua synopsis \n string handle=simIM.addWeighted(string handle1, string handle2, float alpha, float beta, float gamma, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n alpha  (float): alpha coefficient \n \n beta  (float): beta coefficient \n \n gamma  (float): gamma coefficient \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.addWeighted(string handle1, string handle2, float alpha, float beta, float gamma, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.arrowedLine\n \n \n \n                                                    Description\n                                                 \n Draw a arrow segment starting from (x1,y1) and pointing to (x2,y2). \n \n \n Lua synopsis \n simIM.arrowedLine(string handle, int[2] \np1, int[2] p2, int[3] color, int thickness=1, int type=8, int shift=0, \nfloat tipLength=0.1) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n p1  (table of int, size 2): x, y coordinates of first point \n \n p2  (table of int, size 2): x, y coordinates of second point \n \n color  (table of int, size 3): color (red, green, blue values in range 0..255) \n \n thickness  (int, default: 1): line thickness \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n tipLength  (float, default: 0.1): The length of the arrow tip in relation to the arrow length \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.arrowedLine(string handle, list p1, list p2, list color, int thickness=1, int type=8, int shift=0, float tipLength=0.1) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.bitwiseAnd\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element bit-wise conjunction of two arrays. \n \n \n Lua synopsis \n string handle=simIM.bitwiseAnd(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.bitwiseAnd(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.bitwiseAndK\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element bit-wise conjunction of an array and a scalar. \n \n \n Lua synopsis \n string handle=simIM.bitwiseAndK(string handle, float[] k, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n k  (table of float): scalar \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.bitwiseAndK(string handle, list k, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.bitwiseNot\n \n \n \n                                                    Description\n                                                 \n Inverts every bit of an array. \n \n \n Lua synopsis \n string handle=simIM.bitwiseNot(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.bitwiseNot(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.bitwiseOr\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element bit-wise disjunction of two arrays. \n \n \n Lua synopsis \n string handle=simIM.bitwiseOr(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.bitwiseOr(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.bitwiseOrK\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element bit-wise disjunction of an array and a scalar. \n \n \n Lua synopsis \n string handle=simIM.bitwiseOrK(string handle, float[] k, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n k  (table of float): scalar \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.bitwiseOrK(string handle, list k, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.bitwiseXor\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element bit-wise exclusive-or of two arrays. \n \n \n Lua synopsis \n string handle=simIM.bitwiseXor(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.bitwiseXor(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.bitwiseXorK\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element bit-wise exclusive-or of an array and a scalar. \n \n \n Lua synopsis \n string handle=simIM.bitwiseXorK(string handle, float[] k, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n k  (table of float): scalar \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.bitwiseXorK(string handle, list k, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.cart2polar\n \n \n \n                                                    Description\n                                                 \n Calculates magnitude and angle coordinates of 2D vectors from their x and y coordinates. \n \n \n Lua synopsis \n string handle1, string handle2=simIM.cart2polar(string handle1, string handle2, bool angleInDegrees=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image (x) \n \n handle2  (string): handle to second image (y) \n \n angleInDegrees  (bool, default: false): when true, the function calculates the angle in degrees, otherwise, they are measured in radians \n \n \n \n Lua return values \n \n \n handle1  (string): handle of resulting image (magnitude) \n \n handle2  (string): handle of resulting image (angle) \n \n \n \n Python synopsis \n string handle1, string handle2=simIM.cart2polar(string handle1, string handle2, bool angleInDegrees=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.circle\n \n \n \n                                                    Description\n                                                 \n Draw a circle with center (cx,cy) and radius r. \n \n \n Lua synopsis \n simIM.circle(string handle, int[2] center, int radius, int[3] color, int thickness=1, int type=8, int shift=0) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n center  (table of int, size 2): x, y coordinates of center \n \n radius  (int): circle radius \n \n color  (table of int, size 3): color (red, green, blue values in range 0..255) \n \n thickness  (int, default: 1): line thickness (negative values means rect is filled) \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.circle(string handle, list center, int radius, list color, int thickness=1, int type=8, int shift=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.clipLine\n \n \n \n                                                    Description\n                                                 \n Clips the line against the image rectangle. \n \n \n Lua synopsis \n bool valid, int[2] p1, int[2] p2=simIM.clipLine(string handle, int[2] p1, int[2] p2) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n p1  (table of int, size 2): x, y coordinates of first point \n \n p2  (table of int, size 2): x, y coordinates of second point \n \n \n \n Lua return values \n \n \n valid  (bool): false if the line segment is completely outside the image rectangle, otherwise true. \n \n p1  (table of int, size 2): x, y coordinates of first point \n \n p2  (table of int, size 2): x, y coordinates of second point \n \n \n \n Python synopsis \n bool valid, list p1, list p2=simIM.clipLine(string handle, list p1, list p2) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.closeVideoCapture\n \n \n \n                                                    Description\n                                                 \n Close video capture device. \n \n \n Lua synopsis \n simIM.closeVideoCapture(int deviceIndex) \n \n \n \n Lua parameters \n \n deviceIndex  (int): device index (0 based) \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.closeVideoCapture(int deviceIndex) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.compare\n \n \n \n                                                    Description\n                                                 \n Performs the per-element comparison of two arrays. \n \n \n Lua synopsis \n string handle=simIM.compare(string handle1, string handle2, int op, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n op  (int): comparison operator \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.compare(string handle1, string handle2, int op, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.compareK\n \n \n \n                                                    Description\n                                                 \n Performs the per-element comparison of an array and scalar value. \n \n \n Lua synopsis \n string handle=simIM.compareK(string handle, float[] k, int op, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n k  (table of float): scalar \n \n op  (int): comparison operator \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.compareK(string handle, list k, int op, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.convert\n \n \n \n                                                    Description\n                                                 \n Convert the image to a different format. \n \n \n Lua synopsis \n string handle=simIM.convert(string handle, int format, float scale=1.0, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n format  (int): target image format (see  simIM.format ) \n \n scale  (float, default: 1.0): scale factor \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to the converted image \n \n \n Python synopsis \n string handle=simIM.convert(string handle, int format, float scale=1.0, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.copy\n \n \n \n                                                    Description\n                                                 \n Copy a (portion of) image to another image. \n \n \n Lua synopsis \n simIM.copy(string srcHandle, int[2] srcOffset, string dstHandle, int[2] dstOffset, int[2] size) \n \n \n \n Lua parameters \n \n \n srcHandle  (string): handle to source image \n \n srcOffset  (table of int, size 2): x, y offset in the source image \n \n dstHandle  (string): handle to destination image \n \n dstOffset  (table of int, size 2): x, y offset in the destination image \n \n size  (table of int, size 2): size (width, height) of the copied region \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.copy(string srcHandle, list srcOffset, string dstHandle, list dstOffset, list size) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.create\n \n \n \n                                                    Description\n                                                 \n Create an image with given size \n \n \n Lua synopsis \n string handle=simIM.create(int width, int height, int format=sim_im_fmt_8UC3, int initialValue=0) \n \n \n \n Lua parameters \n \n \n width  (int): width \n \n height  (int): height \n \n format  (int, default: sim_im_fmt_8UC3): image format (see  simIM.format ) \n \n initialValue  (int, default: 0): initial value to fill matrix with \n \n \n \n Lua return values \n \n handle  (string): handle to image \n \n \n Python synopsis \n string handle=simIM.create(int width, int height, int format=sim_im_fmt_8UC3, int initialValue=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.createFromData\n \n \n \n                                                    Description\n                                                 \n Create an image from given raw data \n \n \n Lua synopsis \n string handle=simIM.createFromData(int width, int height, string data, int format=sim_im_fmt_8UC3) \n \n \n \n Lua parameters \n \n \n width  (int): width \n \n height  (int): height \n \n data  (string): image data \n \n format  (int, default: sim_im_fmt_8UC3): image format (see  simIM.format ) \n \n \n \n Lua return values \n \n handle  (string): handle to image \n \n \n Python synopsis \n string handle=simIM.createFromData(int width, int height, string data, int format=sim_im_fmt_8UC3) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.dataURL\n \n \n \n                                                    Description\n                                                 \n Encode image data according to "data" URL scheme (RFC 2397) \n \n \n Lua synopsis \n string output=simIM.dataURL(string imgHandle, string format=\'BMP\') \n \n \n \n Lua parameters \n \n \n imgHandle  (string): Handle to the image \n \n format  (string, default: \'BMP\'): Image format (BMP, JPG, or PNG) \n \n \n \n Lua return values \n \n output  (string): Buffer with encoded data \n \n \n Python synopsis \n string output=simIM.dataURL(string imgHandle, string format=\'BMP\') \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.destroy\n \n \n \n                                                    Description\n                                                 \n Destroy (i.e.: free memory) an image with given handle \n \n \n Lua synopsis \n simIM.destroy(string handle) \n \n \n \n Lua parameters \n \n handle  (string): handle to image \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.destroy(string handle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.distanceTransform\n \n \n \n                                                    Description\n                                                 \n Calculates the distance to the closest zero pixel for each pixel of the source image. \n \n \n Lua synopsis \n string \nhandle=simIM.distanceTransform(string handle, int \ndistanceType=sim_im_dist_L2, int maskSize=sim_im_masksize_precise, bool \ninPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n distanceType  (int, default: sim_im_dist_L2): type of distance (see  simIM.dist ) \n \n maskSize  (int, default: sim_im_masksize_precise): mask size (see  simIM.masksize ) \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to image \n \n \n Python synopsis \n string \nhandle=simIM.distanceTransform(string handle, int \ndistanceType=sim_im_dist_L2, int maskSize=sim_im_masksize_precise, bool \ninPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.divide\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element division of two arrays. \n \n \n Lua synopsis \n string handle=simIM.divide(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.divide(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.divideK\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element division of a scalar by an array. \n \n \n Lua synopsis \n string handle=simIM.divideK(float[] k, string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n k  (table of float): scalar \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.divideK(list k, string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.ellipse\n \n \n \n                                                    Description\n                                                 \n Draw an ellipse with center (cx,cy) and axes (rx,ry) points in the image. \n \n \n Lua synopsis \n simIM.ellipse(string handle, int[2] \ncenter, int[2] radius, float angle=0.0, float startAngle=0.0, float \nendAngle=360.0, int[3] color={255,255,255}, int thickness=1, int type=8,\n int shift=0) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n center  (table of int, size 2): x, y coordinates of center \n \n radius  (table of int, size 2): radius along x and y axis \n \n angle  (float, default: 0.0): rotation in degrees \n \n startAngle  (float, default: 0.0): starting angle of the elliptic arc in degrees \n \n endAngle  (float, default: 360.0): ending angle of the elliptic arc in degrees \n \n color  (table of int, size 3, default: {255,255,255}): color (red, green, blue values in range 0..255) \n \n thickness  (int, default: 1): line thickness (negative values means rect is filled) \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.ellipse(string handle, list center, \nlist radius, float angle=0.0, float startAngle=0.0, float \nendAngle=360.0, list color={255,255,255}, int thickness=1, int type=8, \nint shift=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.encode\n \n \n \n                                                    Description\n                                                 \n Encode the image to a memory buffer. \n \n \n Lua synopsis \n string output=simIM.encode(string handle, string format) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n format  (string): image format (e.g. "PNG", "JPG", "BMP") \n \n \n \n Lua return values \n \n output  (string): output buffer \n \n \n Python synopsis \n string output=simIM.encode(string handle, string format) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.exp\n \n \n \n                                                    Description\n                                                 \n Calculates the exponential of every array element. \n \n \n Lua synopsis \n string handle=simIM.exp(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.exp(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.fillConvexPoly\n \n \n \n                                                    Description\n                                                 \n Fills a convex polygon. \n \n \n Lua synopsis \n simIM.fillConvexPoly(string handle, int[] points, int[3] color, int type=8, int shift=0) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n points  (table of int): polygon vertices, i.e. {x1, y1, x2, y2, ..., xN, yN} \n \n color  (table of int, size 3): color (red, green, blue values in range 0..255) \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.fillConvexPoly(string handle, list points, list color, int type=8, int shift=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.fillPoly\n \n \n \n                                                    Description\n                                                 \n Fills the area bounded by one or more polygon. \n \n \n Lua synopsis \n simIM.fillPoly(string handle, int[] points, int[] numPoints, int[2] offset, int[3] color, int type=8, int shift=0) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n points  (table of int): contour points, i.e. {c1x1, \nc1y1, c1x2, c1y2, ..., c1xN1, c1yN1, c2x1, c2y1, ..., c2xN2, c2yN2, ...,\n cMxNM, cMyNM} \n \n numPoints  (table of int): lengths of countours, i.e. \n{N1, N2, ..., NM}. the sum of numPoints items must be equal to the \nnumber of x,y pairs in points. \n \n offset  (table of int, size 2): x, y offset for all points \n \n color  (table of int, size 3): color (red, green, blue values in range 0..255) \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.fillPoly(string handle, list points, list numPoints, list offset, list color, int type=8, int shift=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.flip\n \n \n \n                                                    Description\n                                                 \n Flips an image around vertical, horizontal, or both axes. \n \n \n Lua synopsis \n string handle=simIM.flip(string handle, int op=0, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n op  (int, default: 0): a flag to specify how to flip the array (see  simIM.flipOp ) \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.flip(string handle, int op=0, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.get\n \n \n \n                                                    Description\n                                                 \n Get pixel at specified coordinate. \n \n \n Lua synopsis \n float[] value=simIM.get(string handle, int[2] coord) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n coord  (table of int, size 2): x, y coordinates \n \n \n \n Lua return values \n \n value  (table of float): value \n \n \n Python synopsis \n list value=simIM.get(string handle, list coord) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.gray2rgb\n \n \n \n                                                    Description\n                                                 \n Convert the specified grayscale image to RGB. \n \n \n Lua synopsis \n string handle=simIM.gray2rgb(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to the converted image \n \n \n Python synopsis \n string handle=simIM.gray2rgb(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.hls2rgb\n \n \n \n                                                    Description\n                                                 \n Convert the specified HLS image to RGB. \n \n \n Lua synopsis \n string handle=simIM.hls2rgb(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to the converted image \n \n \n Python synopsis \n string handle=simIM.hls2rgb(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.hsv2rgb\n \n \n \n                                                    Description\n                                                 \n Convert the specified HSV image to RGB. \n \n \n Lua synopsis \n string handle=simIM.hsv2rgb(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to the converted image \n \n \n Python synopsis \n string handle=simIM.hsv2rgb(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.line\n \n \n \n                                                    Description\n                                                 \n Draw a line segment between (x1,y1) and (x2,y2) points in the image. \n \n \n Lua synopsis \n simIM.line(string handle, int[2] p1, int[2] p2, int[3] color, int thickness=1, int type=8, int shift=0) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n p1  (table of int, size 2): x, y coordinates of first point \n \n p2  (table of int, size 2): x, y coordinates of second point \n \n color  (table of int, size 3): color (red, green, blue values in range 0..255) \n \n thickness  (int, default: 1): line thickness \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.line(string handle, list p1, list p2, list color, int thickness=1, int type=8, int shift=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.log\n \n \n \n                                                    Description\n                                                 \n Calculates the natural logarithm of every array element. \n \n \n Lua synopsis \n string handle=simIM.log(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.log(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.magnitude\n \n \n \n                                                    Description\n                                                 \n Calculates the magnitude of 2D vectors, i.e. DST(i) = sqrt(SRC1(i)^2, SRC2(i)^2). \n \n \n Lua synopsis \n string handle=simIM.magnitude(string handle1, string handle2) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.magnitude(string handle1, string handle2) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.merge\n \n \n \n                                                    Description\n                                                 \n Merge many single channel images into a multichannel image. \n \n \n Lua synopsis \n string handle=simIM.merge(string[] handles) \n \n \n \n Lua parameters \n \n handles  (table of string): handles to individual channel images \n \n \n Lua return values \n \n handle  (string): handle to merged image \n \n \n Python synopsis \n string handle=simIM.merge(list handles) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.mixChannels\n \n \n \n                                                    Description\n                                                 \n Mix many single channel images into many multichannel images. \n \n \n Lua synopsis \n simIM.mixChannels(string[] inputHandles, string[] outputHandles, int[] fromTo) \n \n \n \n Lua parameters \n \n \n inputHandles  (table of string): handles to input images \n \n outputHandles  (table of string): handles to output images \n \n fromTo  (table of int): array of index pairs, i.e. {src1,dst1,src2,dst2,...,srcN,dstN}. see  here  for details \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.mixChannels(list inputHandles, list outputHandles, list fromTo) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.multiply\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element product of two arrays. \n \n \n Lua synopsis \n string handle=simIM.multiply(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.multiply(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.openVideoCapture\n \n \n \n                                                    Description\n                                                 \n Open video capture device. \n \n \n Lua synopsis \n simIM.openVideoCapture(int deviceIndex) \n \n \n \n Lua parameters \n \n deviceIndex  (int): device index (0 based) \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.openVideoCapture(int deviceIndex) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.phase\n \n \n \n                                                    Description\n                                                 \n Calculates the rotation angle of 2D vectors, i.e. DST(i) = atan2(SRC2(i), SRC1(i)). \n \n \n Lua synopsis \n string handle=simIM.phase(string handle1, string handle2, bool angleInDegrees=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n angleInDegrees  (bool, default: false): when true, the function calculates the angle in degrees, otherwise, they are measured in radians \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.phase(string handle1, string handle2, bool angleInDegrees=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.polar2cart\n \n \n \n                                                    Description\n                                                 \n Calculates x and y coordinates of 2D vectors from their magnitude and angle. \n \n \n Lua synopsis \n string handle1, string handle2=simIM.polar2cart(string handle1, string handle2, bool angleInDegrees=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image (magnitude) \n \n handle2  (string): handle to second image (angle) \n \n angleInDegrees  (bool, default: false): when true, the function calculates the angle in degrees, otherwise, they are measured in radians \n \n \n \n Lua return values \n \n \n handle1  (string): handle of resulting image (x) \n \n handle2  (string): handle of resulting image (y) \n \n \n \n Python synopsis \n string handle1, string handle2=simIM.polar2cart(string handle1, string handle2, bool angleInDegrees=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.polylines\n \n \n \n                                                    Description\n                                                 \n Draw several polygonal curves. \n \n \n Lua synopsis \n simIM.polylines(string handle, int[] \npoints, int[] numPoints, bool isClosed, int[3] color, int thickness=1, \nint type=8, int shift=0) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n points  (table of int): curve points, i.e. {c1x1, c1y1, \nc1x2, c1y2, ..., c1xN1, c1yN1, c2x1, c2y1, ..., c2xN2, c2yN2, ..., \ncMxNM, cMyNM} \n \n numPoints  (table of int): lengths of curves, i.e. {N1, \nN2, ..., NM}. the sum of numPoints items must be equal to the number of \nx,y pairs in points. \n \n isClosed  (bool): Flag indicating whether the drawn \npolylines are closed or not. If they are closed, the function draws a \nline from the last vertex of each curve to its first vertex. \n \n color  (table of int, size 3): color (red, green, blue values in range 0..255) \n \n thickness  (int, default: 1): line thickness \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.polylines(string handle, list points, list numPoints, bool isClosed, list color, int thickness=1, int type=8, int shift=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.pow\n \n \n \n                                                    Description\n                                                 \n Raises every array element to a power. \n \n \n Lua synopsis \n string handle=simIM.pow(string handle, float power, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n power  (float): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.pow(string handle, float power, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.read\n \n \n \n                                                    Description\n                                                 \n Read an image from the specified file. \n \n \n Lua synopsis \n string handle=simIM.read(string filename) \n \n \n \n Lua parameters \n \n filename  (string): file name \n \n \n Lua return values \n \n handle  (string): handle to image \n \n \n Python synopsis \n string handle=simIM.read(string filename) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.readFromVideoCapture\n \n \n \n                                                    Description\n                                                 \n Read frame from video capture device. \n \n \n Lua synopsis \n string handle=simIM.readFromVideoCapture(int deviceIndex, string handle="") \n \n \n \n Lua parameters \n \n \n deviceIndex  (int): device index (0 based) \n \n handle  (string, default: ""): handle to existing image, or "" to create and return a new image \n \n \n \n Lua return values \n \n handle  (string): handle to new image (or existing image if given) \n \n \n Python synopsis \n string handle=simIM.readFromVideoCapture(int deviceIndex, string handle="") \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.readFromVisionSensor\n \n \n \n                                                    Description\n                                                 \n Read image from vision sensor. \n \n \n Lua synopsis \n string handle=simIM.readFromVisionSensor(int sensorHandle, string handle="") \n \n \n \n Lua parameters \n \n \n sensorHandle  (int): handle to vision sensor \n \n handle  (string, default: ""): handle to existing image, or "" to create and return a new image \n \n \n \n Lua return values \n \n handle  (string): handle to new image (or existing image if given) \n \n \n Python synopsis \n string handle=simIM.readFromVisionSensor(int sensorHandle, string handle="") \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.rectangle\n \n \n \n                                                    Description\n                                                 \n Draw a rectangle with corners (x1,y1) and (x2,y2) points in the image. \n \n \n Lua synopsis \n simIM.rectangle(string handle, int[2] p1, int[2] p2, int[3] color, int thickness=1, int type=8, int shift=0) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n p1  (table of int, size 2): x, y coordinates of top-left corner \n \n p2  (table of int, size 2): x, y coordinates of bottom-right corner \n \n color  (table of int, size 3): color (red, green, blue values in range 0..255) \n \n thickness  (int, default: 1): line thickness (negative values means rect is filled) \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n shift  (int, default: 0): number of fractional bits in the point coordinates \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.rectangle(string handle, list p1, list p2, list color, int thickness=1, int type=8, int shift=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.reduce\n \n \n \n                                                    Description\n                                                 \n Reduces a matrix to a vector. \n \n \n Lua synopsis \n string handle=simIM.reduce(string handle, int dim, int op, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n dim  (int): dimension index along which the matrix is \nreduced. 0 means that the matrix is reduced to a single row. 1 means \nthat the matrix is reduced to a single column. \n \n op  (int): reduction operation (see  simIM.reduceOp ) \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.reduce(string handle, int dim, int op, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.repeat\n \n \n \n                                                    Description\n                                                 \n Fills the output array with repeated copies of the input array. \n \n \n Lua synopsis \n string handle=simIM.repeat(string handle, int nx, int ny, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n nx  (int): how many times the src is repeated along the horizontal axis \n \n ny  (int): how many times the src is repeated along the vertical axis \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.repeat(string handle, int nx, int ny, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.resize\n \n \n \n                                                    Description\n                                                 \n Resize an image and return the resized image (original image is not modified). \n \n \n Lua synopsis \n string handle=simIM.resize(string handle, int width, int height, int interpolation=sim_im_interp_linear, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n width  (int): width of the new image \n \n height  (int): height of the new image \n \n interpolation  (int, default: sim_im_interp_linear): type of interpolation (see  simIM.interp ) \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to resized image \n \n \n Python synopsis \n string handle=simIM.resize(string handle, int width, int height, int interpolation=sim_im_interp_linear, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.rgb2gray\n \n \n \n                                                    Description\n                                                 \n Convert the specified RGB image to gray. \n \n \n Lua synopsis \n string handle=simIM.rgb2gray(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to the converted image \n \n \n Python synopsis \n string handle=simIM.rgb2gray(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.rgb2hls\n \n \n \n                                                    Description\n                                                 \n Convert the specified RGB image to HLS. \n \n \n Lua synopsis \n string handle=simIM.rgb2hls(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to the converted image \n \n \n Python synopsis \n string handle=simIM.rgb2hls(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.rgb2hsv\n \n \n \n                                                    Description\n                                                 \n Convert the specified RGB image to HSV. \n \n \n Lua synopsis \n string handle=simIM.rgb2hsv(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle to the converted image \n \n \n Python synopsis \n string handle=simIM.rgb2hsv(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.scaleAdd\n \n \n \n                                                    Description\n                                                 \n Calculates the sum of a scaled array and another array, i.e. DST(i) = SRC1(i)*scale + SRC2(i). \n \n \n Lua synopsis \n string handle=simIM.scaleAdd(string handle1, string handle2, float alpha, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n alpha  (float): scale coefficient \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.scaleAdd(string handle1, string handle2, float alpha, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.set\n \n \n \n                                                    Description\n                                                 \n Set pixel at specified coordinate. \n \n \n Lua synopsis \n simIM.set(string handle, int[2] coord, float[] value) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n coord  (table of int, size 2): x, y coordinates \n \n value  (table of float): value \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.set(string handle, list coord, list value) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.size\n \n \n \n                                                    Description\n                                                 \n Get the size of an image. \n \n \n Lua synopsis \n int[2] size=simIM.size(string handle) \n \n \n \n Lua parameters \n \n handle  (string): handle to image \n \n \n Lua return values \n \n size  (table of int, size 2): size (width, height) of the image \n \n \n Python synopsis \n list size=simIM.size(string handle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.split\n \n \n \n                                                    Description\n                                                 \n Split a multichannel image. \n \n \n Lua synopsis \n string[] handles=simIM.split(string handle) \n \n \n \n Lua parameters \n \n handle  (string): handle to image \n \n \n Lua return values \n \n handles  (table of string): handles to individual channel images \n \n \n Python synopsis \n list handles=simIM.split(string handle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.sqrt\n \n \n \n                                                    Description\n                                                 \n Calculates the square root of every array element. \n \n \n Lua synopsis \n string handle=simIM.sqrt(string handle, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.sqrt(string handle, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.subtract\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element difference of two arrays. \n \n \n Lua synopsis \n string handle=simIM.subtract(string handle1, string handle2, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle1  (string): handle to first image \n \n handle2  (string): handle to second image \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.subtract(string handle1, string handle2, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.subtractK\n \n \n \n                                                    Description\n                                                 \n Calculates the per-element difference of an array and a scalar. \n \n \n Lua synopsis \n string handle=simIM.subtractK(string handle, float[] k, bool inPlace=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n k  (table of float): scalar \n \n inPlace  (bool, default: false): if true, the original \nimmage will be converted in place. otherwise, the original image will \nnot be modified and a new image is returned. \n \n \n \n Lua return values \n \n handle  (string): handle of resulting image \n \n \n Python synopsis \n string handle=simIM.subtractK(string handle, list k, bool inPlace=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.text\n \n \n \n                                                    Description\n                                                 \n Drawn a text string. \n \n \n Lua synopsis \n simIM.text(string handle, string str, \nint[2] pos, int fontFace=sim_im_fontface_simplex, bool italic=false, \nfloat fontScale=1.0, int[3] color={255,255,255}, int thickness=1, int \ntype=8, bool bottomLeftOrigin=false) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n str  (string): text string to be drawn \n \n pos  (table of int, size 2): x, y coordinates of the origin (bottom-left corner of the string) \n \n fontFace  (int, default: sim_im_fontface_simplex): font face (see  simIM.fontFace ) \n \n italic  (bool, default: false): if true text will have italic style \n \n fontScale  (float, default: 1.0): font scale \n \n color  (table of int, size 3, default: {255,255,255}): color (red, green, blue values in range 0..255) \n \n thickness  (int, default: 1): thickness used to draw a text \n \n type  (int, default: 8): type of the line (8 for 8-connected line, 4 for 4-connected line, or 16 for antialiased line) \n \n bottomLeftOrigin  (bool, default: false): When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.text(string handle, string str, list\n pos, int fontFace=sim_im_fontface_simplex, bool italic=false, float \nfontScale=1.0, list color={255,255,255}, int thickness=1, int type=8, \nbool bottomLeftOrigin=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.textSize\n \n \n \n                                                    Description\n                                                 \n Calculates the width and height of a text string. \n \n \n Lua synopsis \n int width, int height, int \nbaseline=simIM.textSize(string str, int \nfontFace=sim_im_fontface_simplex, bool italic=false, float \nfontScale=1.0, int thickness=1) \n \n \n \n Lua parameters \n \n \n str  (string): text string to be drawn \n \n fontFace  (int, default: sim_im_fontface_simplex): font face (see  simIM.fontFace ) \n \n italic  (bool, default: false): if true text will have italic style \n \n fontScale  (float, default: 1.0): font scale \n \n thickness  (int, default: 1): thickness used to draw a text \n \n \n \n Lua return values \n \n \n width  (int): width of the text \n \n height  (int): height of the text \n \n baseline  (int): y-coordinate of the baseline relative to the bottom-most text point \n \n \n \n Python synopsis \n int width, int height, int \nbaseline=simIM.textSize(string str, int \nfontFace=sim_im_fontface_simplex, bool italic=false, float \nfontScale=1.0, int thickness=1) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.write\n \n \n \n                                                    Description\n                                                 \n Write the image with given handle to a file. \n \n \n Lua synopsis \n simIM.write(string handle, string filename) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n filename  (string): file name \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.write(string handle, string filename) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simIM.writeToVisionSensor\n \n \n \n                                                    Description\n                                                 \n Write image to vision sensor. Make sure the vision sensor is flagged as  external input . \n \n \n Lua synopsis \n simIM.writeToVisionSensor(string handle, int sensorHandle) \n \n \n \n Lua parameters \n \n \n handle  (string): handle to image \n \n sensorHandle  (int): handle to vision sensor \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simIM.writeToVisionSensor(string handle, int sensorHandle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simIM.format\n \n \n _8UC1 : 1 channel, 8 bit unsigned int \n \n _8UC3 : 3 channels, 8 bit unsigned int \n \n _8UC4 : 4 channels, 8 bit unsigned int \n \n _32FC1 : 1 channel, 32 bit float \n \n _32FC3 : 3 channels, 32 bit float \n \n _32FC4 : 4 channels, 32 bit float \n \n \n simIM.interp\n \n \n nearest : nearest-neighbor interpolation \n \n linear : bilinear interpolation \n \n area : resampling using pixel area relation (best for shrinking) \n \n cubic : bicubic interpolation over 4x4 pixel neighborhood \n \n lanczos4 : Lanczos interpolation over 8x8 pixel neighborhood \n \n \n simIM.fontFace\n \n simplex \n plain \n duplex \n complex \n triplex \n complex_small \n script_simplex \n script_complex \n \n \n simIM.cmpOp\n \n eq \n gt \n ge \n lt \n le \n ne \n \n \n simIM.reduceOp\n \n \n sum : the output is the sum of all rows/columns of the matrix. \n \n avg : the output is the mean vector of all rows/columns of the matrix. \n \n max : the output is the maximum (column/row-wise) of all rows/columns of the matrix. \n \n min : the output is the minimum (column/row-wise) of all rows/columns of the matrix. \n \n \n simIM.flipOp\n \n \n x : flip around the x-axis \n \n y : flip around the y-axis \n \n both : flip around both axes \n \n \n simIM.dist\n \n L1 \n L2 \n C \n \n \n simIM.maskSize\n \n _3x3 \n _5x5 \n _precise \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'IMPluginAPIreference.html'}, {'title': 'simVisionAPI', 'text': "\n Vision plugin API reference \n API functions for performing simple image processing, and handling special types of vision algorithms. \n simVision.addBuffer1ToWorkImg \n simVision.addWorkImgToBuffer1 \n simVision.binaryWorkImg \n simVision.blobDetectionOnWorkImg \n simVision.buffer1ToWorkImg \n simVision.buffer2ToWorkImg \n simVision.changedPixelsOnWorkImg \n simVision.circularCutWorkImg \n simVision.colorSegmentationOnWorkImg \n simVision.coordinatesFromWorkImg \n simVision.createVelodyneHDL64E \n simVision.createVelodyneVPL16 \n simVision.destroyVelodyneHDL64E \n simVision.destroyVelodyneVPL16 \n simVision.distort \n simVision.edgeDetectionOnWorkImg \n simVision.handleAnaglyphStereo \n simVision.handleSpherical \n simVision.handleVelodyneHDL64E \n simVision.handleVelodyneVPL16 \n simVision.horizontalFlipWorkImg \n simVision.intensityScaleOnWorkImg \n simVision.matrix3x3OnWorkImg \n simVision.matrix5x5OnWorkImg \n simVision.multiplyWorkImgWithBuffer1 \n simVision.normalizeWorkImg \n simVision.rectangularCutWorkImg \n simVision.resizeWorkImg \n simVision.rotateWorkImg \n simVision.scaleAndOffsetWorkImg \n simVision.selectiveColorOnWorkImg \n simVision.sensorDepthMapToWorkImg \n simVision.sensorImgToWorkImg \n simVision.sharpenWorkImg \n simVision.shiftWorkImg \n simVision.subtractBuffer1FromWorkImg \n simVision.subtractWorkImgFromBuffer1 \n simVision.swapBuffers \n simVision.swapWorkImgWithBuffer1 \n simVision.uniformImgToWorkImg \n simVision.velodyneDataFromWorkImg \n simVision.verticalFlipWorkImg \n simVision.workImgToBuffer1 \n simVision.workImgToBuffer2 \n simVision.workImgToSensorDepthMap \n simVision.workImgToSensorImg \n \n \n \n Handling special types of sensors \n simVision.createVelodyneHDL64E \n simVision.createVelodyneVPL16 \n simVision.destroyVelodyneHDL64E \n simVision.destroyVelodyneVPL16 \n simVision.distort \n simVision.handleAnaglyphStereo \n simVision.handleSpherical \n simVision.handleVelodyneHDL64E \n simVision.handleVelodyneVPL16 \n \n Simple image handling and processing \n simVision.addBuffer1ToWorkImg \n simVision.addWorkImgToBuffer1 \n simVision.binaryWorkImg \n simVision.blobDetectionOnWorkImg \n simVision.buffer1ToWorkImg \n simVision.buffer2ToWorkImg \n simVision.changedPixelsOnWorkImg \n simVision.circularCutWorkImg \n simVision.colorSegmentationOnWorkImg \n simVision.coordinatesFromWorkImg \n simVision.edgeDetectionOnWorkImg \n simVision.horizontalFlipWorkImg \n simVision.intensityScaleOnWorkImg \n simVision.matrix3x3OnWorkImg \n simVision.matrix5x5OnWorkImg \n simVision.multiplyWorkImgWithBuffer1 \n simVision.normalizeWorkImg \n simVision.rectangularCutWorkImg \n simVision.resizeWorkImg \n simVision.rotateWorkImg \n simVision.scaleAndOffsetWorkImg \n simVision.selectiveColorOnWorkImg \n simVision.sensorDepthMapToWorkImg \n simVision.sensorImgToWorkImg \n simVision.sharpenWorkImg \n simVision.shiftWorkImg \n simVision.subtractBuffer1FromWorkImg \n simVision.subtractWorkImgFromBuffer1 \n simVision.swapBuffers \n simVision.swapWorkImgWithBuffer1 \n simVision.uniformImgToWorkImg \n simVision.velodyneDataFromWorkImg \n simVision.verticalFlipWorkImg \n simVision.workImgToBuffer1 \n simVision.workImgToBuffer2 \n simVision.workImgToSensorDepthMap \n simVision.workImgToSensorImg \n \n \n \n simVision.createVelodyneHDL64E \n \n \n \nDescription \n \n \nCreates a handle for generating data similar to a Velodyne HDL64E. See also  simVision.destroyVelodyneHDL64E  and  simVision.handleVelodyneHDL64E . \n \n \n \nLua synopsis\n \n int \nhandle=simVision.createVelodyneHDL64E(int[4] visionSensorHandles,float \nfrequency,int options=0,int pointSize=2,float[2] \ncoloring_closeFarDist={1,5},float displayScalingFactor=1,int \npointCloudHandle=-1) \n \n \n Lua parameters \n \n rgbVisionSensorHandle : handle of a passive vision sensor, receiving the computed RGB image. \n visionSensorHandles : the handles of 4 active vision sensors, looking to the front, left, rear and right. \n frequency : the rotation frequency. \n options : bit-coded options: \n bit0 set (i.e. 1): do not display points \n bit1 set( i.e. 2): display only current points. \n bit2 set( i.e. 4): returned data is polar (otherwise cartesian). \n bit3 set( i.e. 8): displayed points are emissive. \n pointSize : the size of the displayed points, in pixels. \n coloring_closeFarDist : the close and far distances, used to adjust intensity coloring. \n displayScalingFactor : a scaling factor applied \nradially to each point. Can be used to bring points slightly closer to \nthe sensor, to avoid points being hidden behind surfaces due to depth \nmap resolution. \n pointCloudHandle : the optional handle of a point cloud object (that will be in charge of displaying the detected points. \n \n \n \n \nLua return values\n \n \n handle : the created Velodyne HDL64E handle. \n \n \n \nPython synopsis\n \n int \nhandle=simVision.createVelodyneHDL64E(list visionSensorHandles,float \nfrequency,int options=0,int pointSize=2,list \ncoloring_closeFarDist=[1,5],float displayScalingFactor=1,int \npointCloudHandle=-1) \n \n \n \n simVision.createVelodyneVPL16 \n \n \n \nDescription \n \n \nCreates a handle for generating data similar to a Velodyne VPL16. See also  simVision.destroyVelodyneVPL16  and  simVision.handleVelodyneVPL16 . \n \n \n \nLua synopsis\n \n int \nhandle=simVision.createVelodyneVPL16(int[4] visionSensorHandles,float \nfrequency,int options=0,int pointSize=2,float[2] \ncoloring_closeFarDist={1,5},float displayScalingFactor=1,int \npointCloudHandle=-1) \n \n \n Lua parameters \n \n rgbVisionSensorHandle : handle of a passive vision sensor, receiving the computed RGB image. \n visionSensorHandles : the handles of 4 active vision sensors, looking to the front, left, rear and right. \n frequency : the rotation frequency. \n options : bit-coded options: \n bit0 set (i.e. 1): do not display points \n bit1 set( i.e. 2): display only current points. \n bit2 set( i.e. 4): returned data is polar (otherwise cartesian). \n bit3 set( i.e. 8): displayed points are emissive. \n pointSize : the size of the displayed points, in pixels. \n coloring_closeFarDist : the close and far distances, used to adjust intensity coloring. \n displayScalingFactor : a scaling factor applied \nradially to each point. Can be used to bring points slightly closer to \nthe sensor, to avoid points being hidden behind surfaces due to depth \nmap resolution. \n pointCloudHandle : the optional handle of a point cloud object (that will be in charge of displaying the detected points. \n \n \n \n \nLua return values\n \n \n handle : the created Velodyne VPL16 handle. \n \n \n \nPython synopsis\n \n int \nhandle=simVision.createVelodyneVPL16(list visionSensorHandles,float \nfrequency,int options=0,int pointSize=2,list \ncoloring_closeFarDist=[1,5],float displayScalingFactor=1,int \npointCloudHandle=-1) \n \n \n \n simVision.destroyVelodyneHDL64E \n \n \n \nDescription \n \n \nDeletes a Velodyne HDL64E handle previously created with  simVision.createVelodyneHDL64E . \n \n \n \nLua synopsis\n \n simVision.destroyVelodyneHDL64E(int velodyneHandle) \n \n \n Lua parameters \n \n velodyneHandle : a handle previously returned by  simVision.createVelodyneHDL64E . \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.destroyVelodyneHDL64E(int velodyneHandle) \n \n \n \n simVision.destroyVelodyneVPL16 \n \n \n \nDescription \n \n \nDeletes a Velodyne VPL16 handle previously created with  simVision.createVelodyneVPL16 . \n \n \n \nLua synopsis\n \n simVision.destroyVelodyneVPL16(int velodyneHandle) \n \n \n Lua parameters \n \n velodyneHandle : a handle previously returned by  simVision.createVelodyneVPL16 . \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.destroyVelodyneVPL16(int velodyneHandle) \n \n \n \n simVision.distort \n \n \n \nDescription \n \n \nTransforms (distorts) a vision sensor image via pixel remapping. \n \n \n \nLua synopsis\n \n simVision.distort(int visionSensorHandle,int[] pixelMap=nil,float[] depthScalings=nil) \n \n \n Lua parameters \n \n visionSensorHandle : the handle of the vision sensor. \n pixelMap : a table containing indices to new pixel \npositions. Should be of size resX*resY. Consecutive, incremental indices\n (starting at 0) represents the identity transformation. Can be omitted \nif a map was previously provided and doesn't need change. \n depthScaling : an optional table containing scaling factors for each depth value. \n \n \n \n \nLua return values\n \n \n \n \n \n \n \nPython synopsis\n \n simVision.distort(int visionSensorHandle,list pixelMap=None,list depthScalings=None) \n \n \n \n simVision.handleAnaglyphStereo \n \n \n \nDescription \n \n \nAllows to generate an anaglyph stereo image from two individual vision sensors (for the left and right eye). \n \n \n \nLua synopsis\n \n simVision.handleAnaglyphStereo(int rgbVisionSensorHandle,int[2] handlesOfTwoVisionSensors,float[6] leftAndRightColors=nil) \n \n \n Lua parameters \n \n rgbVisionSensorHandle : handle of a passive vision sensor, receiving the computed RGB image. \n handlesOfTwoVisionSensors : the handles of two active vision sensors (for the left and right eye). \n leftAndRightColors : the colors for the left and right eye rendering. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.handleAnaglyphStereo(int rgbVisionSensorHandle,list handlesOfTwoVisionSensors,list leftAndRightColors=None) \n \n \n \n simVision.handleSpherical \n \n \n \nDescription \n \n \nAllows to generate an RGB and/or depth image that covers all directions,\n i.e. spherical vision, based on the input of 6 individual vision \nsensors, each looking into a different and perpendicular direction. \n \n \n \nLua synopsis\n \n simVision.handleSpherical(int \nrgbVisionSensorHandle,int[6] handlesOfSixVisionSensors,float \nhorizontalAngle,float verticalAngle,int depthVisionSensorHandle=-1) \n \n \n Lua parameters \n \n rgbVisionSensorHandle : handle of a passive vision sensor, receiving the computed RGB spherical image. \n handlesOfSixVisionSensors : the handles of 6 mutually perpendicular, looking into a different direction active vision sensors. \n horizontalAngle : the desired horizontal view angle, in radians (e.g. 2*math.pi). \n horizontalAngle : the desired vertical view angle, in radians (e.g. math.pi). \n depthVisionSensorHandle : handle of a passive vision sensor, receiving the computed depth image representation of the spherical depth map. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.handleSpherical(int \nrgbVisionSensorHandle,list handlesOfSixVisionSensors,float \nhorizontalAngle,float verticalAngle,int depthVisionSensorHandle=-1) \n \n \n \n simVision.handleVelodyneHDL64E \n \n \n \nDescription \n \n \nHandles a velodyne HDL64E sensor (i.e. generates and displays detection points. See also  simVision.createVelodyneHDL64E . \n \n \n \nLua synopsis\n \n float[]/buffer points,buffer colors=simVision.handleVelodyneHDL64E(int velodyneHandle,float dt) \n \n \n Lua parameters \n \n velodyneHandle : a handle previously returned by  simVision.createVelodyneHDL64E .\n Can be combined with sim.handleflag_abscoords to retrieve points \nrelative to the absolute reference frame, instead of the reference frame\n of the sensor. Can also be combined with sim.handleflag_codedstring, in\n order to retrieve packed data (faster). \n dt : the time duration since last call to this function. Typically the simulation time step. \n \n \n \n \nLua return values\n \n \n points : a table containing the detected points, or a coded string. \n colors : a coded string containing the colors of \neach point (3 byte values for each point (RGB)). The colors are only \nreturned if the Velodyne model is appropriately configured. \n \n \n \n \nPython synopsis\n \n list/bytes points,bytes colors=simVision.handleVelodyneHDL64E(int velodyneHandle,float dt) \n \n \n \n simVision.handleVelodyneVPL16 \n \n \n \nDescription \n \n \nHandles a velodyne VPL16 sensor (i.e. generates and displays detection points. See also  simVision.createVelodyneVPL16 . \n \n \n \nLua synopsis\n \n float[]/buffer points,buffer colors=simVision.handleVelodyneVPL16(int velodyneHandle,float dt) \n \n \n Lua parameters \n \n velodyneHandle : a handle previously returned by  simVision.createVelodyneVPL16 .\n Can be combined with sim.handleflag_abscoords to retrieve points \nrelative to the absolute reference frame, instead of the reference frame\n of the sensor. Can also be combined with sim.handleflag_codedstring, in\n order to retrieve packed data (faster). \n dt : the time duration since last call to this function. Typically the simulation time step. \n \n \n \n \nLua return values\n \n \n points : a table containing the detected points, or a coded string. \n colors : a coded string containing the colors of \neach point (3 byte values for each point (RGB)). The colors are only \nreturned if the Velodyne model is appropriately configured. \n \n \n \n \nPython synopsis\n \n list/bytes points,bytes colors=simVision.handleVelodyneVPL16(int velodyneHandle,float dt) \n \n \n \n simVision.addBuffer1ToWorkImg \n \n \n \nDescription \n \n \nPerforms a pixel wise addition between the  work image  and buffer  buffer1 , and stores the result in the  work image . See also  simVision.addWorkImgToBuffer1  and  simVision.subtractBuffer1FromWorkImg . \n \n \n \nLua synopsis\n \n simVision.addBuffer1ToWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.addBuffer1ToWorkImg(int handle) \n \n \n \n simVision.addWorkImgToBuffer1 \n \n \n \nDescription \n \n \nPerforms a pixel wise addition between the  work image  and buffer  buffer1 , and stores the result in buffer  buffer1 . See also  simVision.addBuffer1ToWorkImg  and  simVision.subtractWorkImgFromBuffer1 . \n \n \n \nLua synopsis\n \n simVision.addWorkImgToBuffer1(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.addWorkImgToBuffer1(int handle) \n \n \n \n simVision.binaryWorkImg \n \n \n \nDescription \n \n \nTransforms the  work image  into a binary image, with optional triggering. \n \n \n \nLua synopsis\n \n int trigger,buffer \npackedPacket=simVision.binaryWorkImg(int handle,float threshold,float \noneProportion,float oneTol,float xCenter,float xCenterTol,float \nyCenter,float yCenterTol,float orient,float orientTol,float \nroundness,bool enableTrigger,float[3] overlayColor={1.0,0.0,1.0})) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n threshold : the threshold for binary 0 or binary 1. \n oneProportion : the nominal binary 1 pixels relative amount (0-1), for triggering. \n oneTol : the allowed tolerance for  oneProportion . \n xCenter : the nominal x center of binary 1 pixels (0-1), for triggering. \n xCenterTol : the allowed tolerance for  xCenter . \n yCenter : the nominal y center of binary 1 pixels (0-1), for triggering. \n yCenterTol : the allowed tolerance for  yCenter . \n orient : the nominal orientation, in radians, of the bounding box around binary 1 pixels (0-1), for triggering. \n orientTol : the allowed tolerance for  orient . \n roundness : the nominal roundness value of the bounding box around binary 1 pixels (0-1), for triggering. \n enableTrigger : if true and the triggering conditions are met, then return value  trigger  will be true. \n overlayColor : an overlay color used to visualize triggering conditions. Set to nil for no overlay. \n \n \n \n \nLua return values\n \n \n trigger : true if the filter has triggered. \n packedPacket : a packed packet (use  sim.unpackFloatTable  to unpack) containing: \n a) the binary image  proportion  value \n b) the binary image  posX  value \n c) the binary image  posY  value \n d) the binary image  angle  value \n e) the binary image  roundness  value \n \n \n \n \nPython synopsis\n \n int trigger,bytes \npackedPacket=simVision.binaryWorkImg(int handle,float threshold,float \noneProportion,float oneTol,float xCenter,float xCenterTol,float \nyCenter,float yCenterTol,float orient,float orientTol,float \nroundness,bool enableTrigger,list overlayColor=[1.0,0.0,1.0])) \n \n \n \n simVision.blobDetectionOnWorkImg \n \n \n \nDescription \n \n \nPerforms blob detection on the  work image . \n \n \n \nLua synopsis\n \n int trigger,buffer \npackedPacket=simVision.blobDetectionOnWorkImg(int handle,float \nthreshold,float minBlobSize,bool diffColor,float[3] \noverlayColor={1.0,0.0,1.0})) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n threshold : the intensity threshold for a pixel to be considered  on .  \n minBlobSize : the minimum size of a blob (in relation to the total image surface). \n diffColor : if true then each blob will be represented in a different color. \n overlayColor : an overlay color used to visualize the blobs. Set to nil for no overlay. \n \n \n \n \nLua return values\n \n \n trigger : always false. Not used. \n packedPacket : a packed packet (use  sim.unpackFloatTable  to unpack) containing: \n a) the number of detected blobs \n b) the number of values returned for each blob \n then for each blob: \n c.1) the blob relative size \n c.2) the blob orientation \n c.3) the blob relative position X \n c.4) the blob relative position Y \n c.5) the blob bounding box relative width \n c.6) the blob bounding box relative height \n \n \n \n \nPython synopsis\n \n int trigger,bytes \npackedPacket=simVision.blobDetectionOnWorkImg(int handle,float \nthreshold,float minBlobSize,bool diffColor,list \noverlayColor=[1.0,0.0,1.0])) \n \n \n \n simVision.buffer1ToWorkImg \n \n \n \nDescription \n \n \nCopies buffer  buffer1  to the  work image . See also  simVision.buffer2ToWorkImg ,  simVision.workImgToBuffer1 ,  simVision.swapBuffers  and  simVision.swapWorkImgWithBuffer1 . \n \n \n \nLua synopsis\n \n simVision.buffer1ToWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.buffer1ToWorkImg(int handle) \n \n \n \n simVision.buffer2ToWorkImg \n \n \n \nDescription \n \n \nCopies buffer  buffer2  to the  work image . See also  simVision.buffer1ToWorkImg ,  simVision.workImgToBuffer2  and  simVision.swapBuffers . \n \n \n \nLua synopsis\n \n simVision.buffer2ToWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.buffer2ToWorkImg(int handle) \n \n \n \n simVision.changedPixelsOnWorkImg \n \n \n \nDescription \n \n \nReturns the pixels that changed the  work image , from one frame to the next. \n \n \n \nLua synopsis\n \n int trigger,buffer packedPacket=simVision.changedPixelsOnWorkImg(int handle,float threshold) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n threshold : the minimum intensity variation for a pixel to have changed. \n \n \n \n \nLua return values\n \n \n trigger : always false. Not used. \n packedPacket : a packed packet (use  sim.unpackFloatTable  to unpack) containing for each changed pixel: \n a.1) 1 if the pixel became brighter, -1 otherwise \n a.2) the x coordinate of the pixel \n a.3) the y coordinate of the pixel \n \n \n \n \nPython synopsis\n \n int trigger,bytes packedPacket=simVision.changedPixelsOnWorkImg(int handle,float threshold) \n \n \n \n simVision.circularCutWorkImg \n \n \n \nDescription \n \n \nPerforms a circular cut on the  work image . \n \n \n \nLua synopsis\n \n simVision.circularCutWorkImg(int handle,float radius,bool toBuffer1) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n radius : the radius of the disc, expressed proportionally to the image resolution. Pixels outside of the disc's bounds are removed. \n toBuffer1 : if true, then the removed pixels are copied to buffer  buffer1 . \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.circularCutWorkImg(int handle,float radius,bool toBuffer1) \n \n \n \n simVision.colorSegmentationOnWorkImg \n \n \n \nDescription \n \n \nPerforms a color segmentation on the  work image . \n \n \n \nLua synopsis\n \n simVision.colorSegmentationOnWorkImg(int handle,float colorDistance) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n colorDistance : the color distance to be used as threshold. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.colorSegmentationOnWorkImg(int handle,float colorDistance) \n \n \n \n simVision.coordinatesFromWorkImg \n \n \n \nDescription \n \n \nExtracts coordinates from the  work image  (based on the view field of a vision sensor). \n \n \n \nLua synopsis\n \n int trigger,buffer packedPacket,buffer \ncolorData=simVision.coordinatesFromWorkImg(int handle,int[2] \npointCount,bool angularSpace,bool returnColorData) \n \n \n Lua parameters \n \n handle : handle of the vision sensor. Can be \ncombined with sim.handleflag_abscoords in order to retrieve points \nrelative to the absolute reference frame, instead of the vision sensor \nreference frame. \n pointCount : the desired point count along X and Y. \n angularSpace : whether the point sampling happens in the cartesian or angular space (within a given direction). \n returnColorData : whether to also return color data for each point. If true, then the vision sensor's image data should be located in buffer  buffer1 . \n \n \n \n \nLua return values\n \n \n trigger : always false. Not used. \n packedPacket : a packed packet (use  sim.unpackFloatTable  to unpack) containing: \n a) the number of points along X \n b) the number of points along Y \n then for each points: \n c.1) the x coordinate of the point \n c.2) the y coordinate of the point \n c.3) the z coordinate of the point \n c.4) the distance to the point \n colorData : optional color data (use  sim.unpackUInt8Table  to unpack) containing RGB triplets for each point. \n \n \n \n \nPython synopsis\n \n int trigger,bytes packedPacket,bytes \ncolorData=simVision.coordinatesFromWorkImg(int handle,list \npointCount,bool angularSpace,bool returnColorData) \n \n \n \n simVision.edgeDetectionOnWorkImg \n \n \n \nDescription \n \n \nApplies an edge detection filter to the  work image . See also  simVision.matrix3x3OnWorkImg  and  simVision.matrix5x5OnWorkImg . \n \n \n \nLua synopsis\n \n simVision.edgeDetectionOnWorkImg(int handle,float threshold) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n threshold : the threshold value. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.edgeDetectionOnWorkImg(int handle,float threshold) \n \n \n \n simVision.horizontalFlipWorkImg \n \n \n \nDescription \n \n \nHorizontally flips the  work image . See also  simVision.verticalFlipWorkImg . \n \n \n \nLua synopsis\n \n simVision.horizontalFlipWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.horizontalFlipWorkImg(int handle) \n \n \n \n simVision.intensityScaleOnWorkImg \n \n \n \nDescription \n \n \nTransforms the  work image  into an intensity representation. \n \n \n \nLua synopsis\n \n simVision.intensityScaleOnWorkImg(int handle,float start,float end,bool greyscale) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n start : the value representing the minimum intensity. \n end : the value representing the maximum intensity. \n greyscale : if true, the output is a grey scale image, otherwise it is a color coded intensity image. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.intensityScaleOnWorkImg(int handle,float start,float end,bool greyscale) \n \n \n \n simVision.matrix3x3OnWorkImg \n \n \n \nDescription \n \n \nApplies a 3X3 matrix filter to the  work image . \n \n \n \nLua synopsis\n \n simVision.matrix3x3OnWorkImg(int handle,int passes,float multiplier,float[9] matrix) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n passes : the number of desired filter passes. \n multiplier : a matrix multiplier. \n matrix : the 3X3 matrix. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.matrix3x3OnWorkImg(int handle,int passes,float multiplier,list matrix) \n \n \n \n simVision.matrix5x5OnWorkImg \n \n \n \nDescription \n \n \nApplies a 5X5 matrix filter to the  work image . \n \n \n \nLua synopsis\n \n simVision.matrix5x5OnWorkImg(int handle,int passes,float multiplier,float[25] matrix) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n passes : the int of desired filter passes. \n multiplier : a matrix multiplier. \n matrix : the 5X5 matrix. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.matrix5x5OnWorkImg(int handle,int passes,float multiplier,list matrix) \n \n \n \n simVision.multiplyWorkImgWithBuffer1 \n \n \n \nDescription \n \n \nMultiplies (pixel wise) the  work image  with buffer  buffer1 , and stores the result in the  work image . \n \n \n \nLua synopsis\n \n simVision.multiplyWorkImgWithBuffer1(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.multiplyWorkImgWithBuffer1(int handle) \n \n \n \n simVision.normalizeWorkImg \n \n \n \nDescription \n \n \nNormalizes the  work image . \n \n \n \nLua synopsis\n \n simVision.normalizeWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.normalizeWorkImg(int handle) \n \n \n \n simVision.rectangularCutWorkImg \n \n \n \nDescription \n \n \nPerforms a rectangular cut on the  work image . \n \n \n \nLua synopsis\n \n simVision.rectangularCutWorkImg(int handle,float[2] rectangle,bool toBuffer1) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n rectangle : the x/y size of the rectangle, \nexpressed proportionally to the image resolution. Pixels outside of the \nrectangle's bounds are removed. \n toBuffer1 : if true, then the removed pixels are copied to buffer  buffer1 . \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.rectangularCutWorkImg(int handle,list rectangle,bool toBuffer1) \n \n \n \n simVision.resizeWorkImg \n \n \n \nDescription \n \n \nScales the  work image . The resolution remains same. \n \n \n \nLua synopsis\n \n simVision.resizeWorkImg(int handle,float[2] scaling) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n scaling : the x/y scaling. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.resizeWorkImg(int handle,list scaling) \n \n \n \n simVision.rotateWorkImg \n \n \n \nDescription \n \n \nPerforms a rotation of the  work image . \n \n \n \nLua synopsis\n \n simVision.rotateWorkImg(int handle,float angle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n angle : the rotation angle in radians. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.rotateWorkImg(int handle,float angle) \n \n \n \n simVision.scaleAndOffsetWorkImg \n \n \n \nDescription \n \n \nShifts and scales colors of the  work image , in the RGB or HSL space: colorOut=postOffset+(colorIn+preOffset)*scaling \n \n \n \nLua synopsis\n \n simVision.scaleAndOffsetWorkImg(int handle,float[3] colorPreOffset,float[3] colorScaling,float[3] colorPostOffset,bool rgbSpace) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n colorPreOffset : the pre-offset, in RGB or HSL space. \n colorScaling : the scaling, in RGB or HSL space. \n colorPostOffset : the post-offset, in RGB or HSL space. \n rgbSpace : if true, values are in the RGB space, otherwise they are in the HSL space. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.scaleAndOffsetWorkImg(int handle,list colorPreOffset,list colorScaling,list colorPostOffset,bool rgbSpace) \n \n \n \n simVision.selectiveColorOnWorkImg \n \n \n \nDescription \n \n \nSelects a specific color in the RGB or HSL space of the  work image . \n \n \n \nLua synopsis\n \n simVision.selectiveColorOnWorkImg(int \nhandle,float[3] nominalColor,float[3] colorTolerance,bool rgbSpace,bool \nkeepColor,bool toBuffer1) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n nominalColor : the nominal color to select, in RGB or HSL space. \n colorTolerance : the tolerance around the nominal color, in RGB or HSL space. \n rgbSpace : if true, values are in the RGB space, otherwise they are in the HSL space. \n keepColor : if true, the specified color is kept, otherwise it is removed. \n toBuffer1 : if true, the removed color is copied to buffer  buffer1 . \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.selectiveColorOnWorkImg(int handle,list nominalColor,list colorTolerance,bool rgbSpace,bool keepColor,bool toBuffer1) \n \n \n \n simVision.sensorDepthMapToWorkImg \n \n \n \nDescription \n \n \nCopies the depth buffer acquired by a vision sensor to the  work image  (buffer used for image processing). see also  simVision.sensorImgToWorkImg  and  simVision.workImgToSensorImg . \n \n \n \nLua synopsis\n \n simVision.sensorDepthMapToWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.sensorDepthMapToWorkImg(int handle) \n \n \n \n simVision.sensorImgToWorkImg \n \n \n \nDescription \n \n \nCopies the RGB image acquired by a vision sensor to the  work image  (buffer used for image processing). See also  simVision.sensorDepthMapToWorkImg  and  simVision.workImgToSensorImg . \n \n \n \nLua synopsis\n \n simVision.sensorImgToWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.sensorImgToWorkImg(int handle) \n \n \n \n simVision.sharpenWorkImg \n \n \n \nDescription \n \n \nSharpens the  work image . See also  simVision.matrix3x3OnWorkImg  and  simVision.matrix5x5OnWorkImg . \n \n \n \nLua synopsis\n \n simVision.sharpenWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.sharpenWorkImg(int handle) \n \n \n \n simVision.shiftWorkImg \n \n \n \nDescription \n \n \nShifts the  work image . \n \n \n \nLua synopsis\n \n simVision.shiftWorkImg(int handle,float[2] shift,bool wrap) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n shift : the x/y shift amount, proportional to the image resolution (0=no shift, 1=shift by x/y resolution pixels). \n wrap : whether parts shifted outside the image frame wrap around. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.shiftWorkImg(int handle,list shift,bool wrap) \n \n \n \n simVision.subtractBuffer1FromWorkImg \n \n \n \nDescription \n \n \nSubtracts (pixel wise subtraction) buffer  buffer1  from the  work image . See also  simVision.subtractWorkImgFromBuffer1  and  simVision.addBuffer1ToWorkImg . \n \n \n \nLua synopsis\n \n simVision.subtractBuffer1FromWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.subtractBuffer1FromWorkImg(int handle) \n \n \n \n simVision.subtractWorkImgFromBuffer1 \n \n \n \nDescription \n \n \nSubtracts (pixel wise subtraction) the  work image  from buffer  buffer1 . See also  simVision.subtractBuffer1FromWorkImg  and  simVision.addWorkImgToBuffer1 . \n \n \n \nLua synopsis\n \n simVision.subtractWorkImgFromBuffer1(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.subtractWorkImgFromBuffer1(int handle) \n \n \n \n simVision.swapBuffers \n \n \n \nDescription \n \n \nSwaps buffer  buffer1  with buffer  buffer2 . See also  simVision.swapWorkImgWithBuffer1 . \n \n \n \nLua synopsis\n \n simVision.swapBuffers(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.swapBuffers(int handle) \n \n \n \n simVision.swapWorkImgWithBuffer1 \n \n \n \nDescription \n \n \nSwaps the  work image  with buffer  buffer1 . See also  simVision.swapBuffers . \n \n \n \nLua synopsis\n \n simVision.swapWorkImgWithBuffer1(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.swapWorkImgWithBuffer1(int handle) \n \n \n \n simVision.uniformImgToWorkImg \n \n \n \nDescription \n \n \nApplies a uniform color to the  work image  (buffer used for image processing) \n \n \n \nLua synopsis\n \n simVision.uniformImgToWorkImg(int handle,float[3] color) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n color : a table containing the RGB-triplet for the color (in the range of 0-1). \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.uniformImgToWorkImg(int handle,list color) \n \n \n \n simVision.velodyneDataFromWorkImg \n \n \n \nDescription \n \n \nExtracts Velodyne coordinates from the  work image  (based on the view field of a vision sensor). \n \n \n \nLua synopsis\n \n int trigger,buffer packedPacket,buffer \ncolorData=simVision.velodyneDataFromWorkImg(int handle,int[2] \npointCount,float verticalScanAngle,bool returnColorData=false) \n \n \n Lua parameters \n \n handle : handle of the vision sensor. Can be \ncombined with sim.handleflag_abscoords in order to retrieve points \nrelative to the absolute reference frame, instead of the vision sensor \nreference frame. \n pointCount : the desired point count along X and Y. \n verticalScanAngle : the vertical scan angle. \n returnColorData : whether to also return color data for each point. If true, then the vision sensor's image data should be located in buffer  buffer1 . \n \n \n \n \nLua return values\n \n \n trigger : always false. Not used. \n packedPacket : a packed packet (use  sim.unpackFloatTable  to unpack) containing: \n a) the number of points along X \n b) the number of points along Y \n then for each points: \n c.1) the x coordinate of the point \n c.2) the y coordinate of the point \n c.3) the z coordinate of the point \n c.4) the distance from the sensor to the point \n colorData : optional color data (use  sim.unpackUInt8Table  to unpack) containing RGB triplets for each point. \n \n \n \n \nPython synopsis\n \n int trigger,bytes packedPacket,bytes \ncolorData=simVision.velodyneDataFromWorkImg(int handle,list \npointCount,float verticalScanAngle,bool returnColorData=False) \n \n \n \n simVision.verticalFlipWorkImg \n \n \n \nDescription \n \n \nVertically flips the  work image . See also  simVision.horizontalFlipWorkImg . \n \n \n \nLua synopsis\n \n simVision.verticalFlipWorkImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.verticalFlipWorkImg(int handle) \n \n \n \n simVision.workImgToBuffer1 \n \n \n \nDescription \n \n \nCopies the  work image  to buffer  buffer1 . See also  simVision.workImgToBuffer2 ,  simVision.buffer1ToWorkImg ,  simVision.swapBuffers  and  simVision.swapWorkImgWithBuffer1 . \n \n \n \nLua synopsis\n \n simVision.workImgToBuffer1(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.workImgToBuffer1(int handle) \n \n \n \n simVision.workImgToBuffer2 \n \n \n \nDescription \n \n \nCopies the  work image  to buffer  buffer2 . See also  simVision.workImgToBuffer1 ,  simVision.buffer2ToWorkImg  and  simVision.swapBuffers . \n \n \n \nLua synopsis\n \n simVision.workImgToBuffer2(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.workImgToBuffer2(int handle) \n \n \n \n simVision.workImgToSensorDepthMap \n \n \n \nDescription \n \n \nCopies the  work image  (buffer used for image processing) to a \nvision sensor's depth buffer (each depth buffer pixel will be averaged \nfrom the image RGB-triplet). See also  simVision.workImgToSensorImg . \n \n \n \nLua synopsis\n \n simVision.workImgToSensorDepthMap(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.workImgToSensorDepthMap(int handle) \n \n \n \n simVision.workImgToSensorImg \n \n \n \nDescription \n \n \nCopies the  work image  (buffer used for image processing) to a vision sensor's RGB buffer. See also  simVision.sensorImgToWorkImg . \n \n \n \nLua synopsis\n \n simVision.workImgToSensorImg(int handle) \n \n \n Lua parameters \n \n handle : handle of the vision sensor, or sim.handle_self if the object attached to this script is the vision sensor. \n \n \n \n \nLua return values\n \n \n \n \n \n \nPython synopsis\n \n simVision.workImgToSensorImg(int handle) \n \n \n \n \n , ", 'tags': '', 'url': 'simVisionAPI.html'}, {'title': 'customUIPlugin', 'text': '\n \n \n \n \n Custom user interfaces \n CoppeliaSim offers custom user interfaces (custom UIs) via a plugin wrapping some functionality of the Qt framework. The plugin, courtesy of Federico Ferri, exports several  API functions related to user interfaces . Its source code can be found  here . \n The custom UIs offer Qt-style widgets such as dialogs integrating buttons, edit-boxes, sliders, labels, images, plots, etc. Any action on custom UIs (e.g. button-click, text edition, slider movement) is reported as a script callback. A custom UI is described via an XML string that follows  a specific syntax . Following displays a typical custom UI: \n \n \n [Custom UI example] \n \n Specialized user interfaces are also available, via specific API functions: \n message boxes \n input dialogs \n file dialogs \n color dialogs \n auxiliary consoles \n text/code editors \n CoppeliaSim also offers  Qt QML  functionality. See the  API functions related to QML  and the  QML plugin source code . \n \n \n \n', 'tags': '', 'url': 'customUIPlugin.html'}, {'title': 'UIPluginAPIreference', 'text': '\n UI Plugin API reference \n API functions for creating custom user interfaces. \n simUI.addCurve \n simUI.addCurveTimePoints \n simUI.addCurveXYPoints \n simUI.addScene3DNode \n simUI.addTreeItem \n simUI.clearCurve \n simUI.clearTable \n simUI.clearTree \n simUI.collapseAll \n simUI.colorDialog \n simUI.create \n simUI.destroy \n simUI.expandAll \n simUI.expandToDepth \n simUI.fileDialog \n simUI.getCheckboxValue \n simUI.getColumnCount \n simUI.getComboboxItemCount \n simUI.getComboboxItemText \n simUI.getComboboxItems \n simUI.getComboboxSelectedIndex \n simUI.getCurrentEditWidget \n simUI.getCurrentTab \n simUI.getCurveData \n simUI.getEditValue \n simUI.getItem \n simUI.getLabelText \n simUI.getPosition \n simUI.getRadiobuttonValue \n simUI.getRowCount \n simUI.getSize \n simUI.getSliderValue \n simUI.getSpinboxValue \n simUI.getTitle \n simUI.getWidgetVisibility \n simUI.growPlotRanges \n simUI.growPlotXRange \n simUI.growPlotYRange \n simUI.hide \n simUI.inputDialog \n simUI.insertComboboxItem \n simUI.insertTableColumn \n simUI.insertTableRow \n simUI.isVisible \n simUI.msgBox \n simUI.removeComboboxItem \n simUI.removeCurve \n simUI.removeScene3DNode \n simUI.removeTableColumn \n simUI.removeTableRow \n simUI.removeTreeItem \n simUI.replot \n simUI.rescaleAxes \n simUI.rescaleAxesAll \n simUI.restoreState \n simUI.saveState \n simUI.setButtonPressed \n simUI.setButtonText \n simUI.setCheckboxValue \n simUI.setColumnCount \n simUI.setColumnHeaderText \n simUI.setColumnWidth \n simUI.setComboboxItems \n simUI.setComboboxSelectedIndex \n simUI.setCurrentEditWidget \n simUI.setCurrentTab \n simUI.setEditValue \n simUI.setEnabled \n simUI.setImageData \n simUI.setItem \n simUI.setItemEditable \n simUI.setItemImage \n simUI.setLabelText \n simUI.setLegendVisibility \n simUI.setMouseOptions \n simUI.setPlotLabels \n simUI.setPlotRanges \n simUI.setPlotXLabel \n simUI.setPlotXRange \n simUI.setPlotYLabel \n simUI.setPlotYRange \n simUI.setPosition \n simUI.setProgress \n simUI.setRadiobuttonValue \n simUI.setRowCount \n simUI.setRowHeaderText \n simUI.setRowHeight \n simUI.setScene3DNodeEnabled \n simUI.setScene3DNodeFloatParam \n simUI.setScene3DNodeIntParam \n simUI.setScene3DNodeParam \n simUI.setScene3DNodeStringParam \n simUI.setScene3DNodeVector2Param \n simUI.setScene3DNodeVector3Param \n simUI.setScene3DNodeVector4Param \n simUI.setSize \n simUI.setSliderValue \n simUI.setSpinboxValue \n simUI.setStyleSheet \n simUI.setTableSelection \n simUI.setText \n simUI.setTitle \n simUI.setTreeSelection \n simUI.setUrl \n simUI.setWidgetVisibility \n simUI.setWindowEnabled \n simUI.show \n simUI.supportedImageFormats \n simUI.svgLoadData \n simUI.svgLoadFile \n simUI.updateTreeItemParent \n simUI.updateTreeItemText \n \n \n \n simUI.addCurve\n \n \n \n                                                    Description\n                                                 \n Adds a curve to a plot widget. \n \n \n Lua synopsis \n simUI.addCurve(string handle, int id, int type, string name, int[3] color, int style, curve_options options) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n type  (int): type of the curve. see  simUI.curve_type . \n \n name  (string): name of the curve \n \n color  (table of int, size 3): color of the curve, as RGB values in the 0...255 range \n \n style  (int): style of the curve. see  simUI.curve_style . \n \n options  (curve_options): data structure holding extra options. see  curve_options . \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.addCurve(string handle, int id, int type, string name, list color, int style, curve_options options) \n \n \n \n \n                                                See also\n                                             \n   simUI.curve_type   simUI.curve_style   curve_options   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.addCurveTimePoints\n \n \n \n                                                    Description\n                                                 \n Adds time points to the specified curve of the plot widget. \n \n \n Lua synopsis \n simUI.addCurveTimePoints(string handle, int id, string name, double[] x, double[] y) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n name  (string): name of the curve \n \n x  (table of double): x values \n \n y  (table of double): y values \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.addCurveTimePoints(string handle, int id, string name, list x, list y) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.addCurveXYPoints\n \n \n \n                                                    Description\n                                                 \n Adds points to the specified curve of the plot widget. \n \n \n Lua synopsis \n simUI.addCurveXYPoints(string handle, int id, string name, double[] t, double[] x, double[] y) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n name  (string): name of the curve \n \n t  (table of double): t values (i.e. the curve \nparameter, used also to determine how points are connected, according to\n natural ordering of t) \n \n x  (table of double): x values \n \n y  (table of double): y values \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.addCurveXYPoints(string handle, int id, string name, list t, list x, list y) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.addScene3DNode\n \n \n \n                                                    Description\n                                                 \n Add a node in a scene3d widget. \n \n \n Lua synopsis \n simUI.addScene3DNode(string handle, int id, int nodeId, int parentNodeId, int type) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n parentNodeId  (int): parent node id \n \n type  (int): type of the node. see  simUI.scene3d_node_type \n \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.addScene3DNode(string handle, int id, int nodeId, int parentNodeId, int type) \n \n \n \n \n                                                See also\n                                             \n   simUI.removeScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector3Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.addTreeItem\n \n \n \n                                                    Description\n                                                 \n Add an item to the specified tree widget. \n \n \n Lua synopsis \n simUI.addTreeItem(string handle, int id, \nint item_id, string[] text, int parent_id=0, bool expanded=false, bool \nsuppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n item_id  (int): item id \n \n text  (table of string): item text fields \n \n parent_id  (int, default: 0): parent item id (0 means a toplevel item) \n \n expanded  (bool, default: false): if true, the item will be in expanded state \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.addTreeItem(string handle, int id, int item_id, list text, int parent_id=0, bool expanded=false, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.clearCurve\n \n \n \n                                                    Description\n                                                 \n Clear points of the specified curve of the plot widget. \n \n \n Lua synopsis \n simUI.clearCurve(string handle, int id, string name) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n name  (string): name of the curve \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.clearCurve(string handle, int id, string name) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.clearTable\n \n \n \n                                                    Description\n                                                 \n Clear the specified table widget. \n \n \n Lua synopsis \n simUI.clearTable(string handle, int id, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.clearTable(string handle, int id, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.clearTree\n \n \n \n                                                    Description\n                                                 \n Clear the specified tree widget. \n \n \n Lua synopsis \n simUI.clearTree(string handle, int id, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.clearTree(string handle, int id, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.collapseAll\n \n \n \n                                                    Description\n                                                 \n Collapse all nodes in the specified tree widget. \n \n \n Lua synopsis \n simUI.collapseAll(string handle, int id, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.collapseAll(string handle, int id, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.clearTree   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.colorDialog\n \n \n \n                                                    Description\n                                                 \n Display a color dialog. \n \n \n Lua synopsis \n float[3] \nresult=simUI.colorDialog(float[3..4] initColor={1,1,1}, string \ntitle="Select color", bool showAlphaChannel=false, bool native=true) \n \n \n \n Lua parameters \n \n \n initColor  (table of float, size 3..4, default: {1,1,1}): initial color \n \n title  (string, default: "Select color"): the title of the dialog \n \n showAlphaChannel  (bool, default: false): allow the user to select the alpha component of a color \n \n native  (bool, default: true): use OS-native file dialogs \n \n \n \n Lua return values \n \n result  (table of float, size 3): result \n \n \n Python synopsis \n list result=simUI.colorDialog(list \ninitColor={1,1,1}, string title="Select color", bool \nshowAlphaChannel=false, bool native=true) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.create\n \n \n \n                                                    Description\n                                                 \n Create a window. \n \n \n Lua synopsis \n string uiHandle=simUI.create(string xml) \n \n \n \n Lua parameters \n \n xml  (string): xml ui definition (refer to  UI plugin XML syntax ) \n \n \n Lua return values \n \n uiHandle  (string): a handle to the created UI \n \n \n Python synopsis \n string uiHandle=simUI.create(string xml) \n \n \n \n \n                                                See also\n                                             \n   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.destroy\n \n \n \n                                                    Description\n                                                 \n Destroy a window. \n \n \n Lua synopsis \n simUI.destroy(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.destroy(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.expandAll\n \n \n \n                                                    Description\n                                                 \n Expand all nodes in the specified tree widget. \n \n \n Lua synopsis \n simUI.expandAll(string handle, int id, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.expandAll(string handle, int id, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.expandToDepth\n \n \n \n                                                    Description\n                                                 \n Expand nodes up to a certain depth in the specified tree widget. \n \n \n Lua synopsis \n simUI.expandToDepth(string handle, int id, int depth, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n depth  (int): depth \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.expandToDepth(string handle, int id, int depth, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.fileDialog\n \n \n \n                                                    Description\n                                                 \n Display a file dialog. \n \n \n Lua synopsis \n string[] result=simUI.fileDialog(int type,\n string title, string startPath, string initName, string extName, string\n ext, bool native=false) \n \n \n \n Lua parameters \n \n \n type  (int): type \n \n title  (string): title \n \n startPath  (string): start path \n \n initName  (string): initial file name \n \n extName  (string): the name of the extension \n \n ext  (string): the actual extension \n \n native  (bool, default: false): use OS-native file dialogs \n \n \n \n Lua return values \n \n result  (table of string): result \n \n \n Python synopsis \n list result=simUI.fileDialog(int type, \nstring title, string startPath, string initName, string extName, string \next, bool native=false) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.getCheckboxValue\n \n \n \n                                                    Description\n                                                 \n Get the value of a checkbox widget. \n \n \n Lua synopsis \n int value=simUI.getCheckboxValue(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n value  (int): value \n \n \n Python synopsis \n int value=simUI.getCheckboxValue(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.setCheckboxValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getColumnCount\n \n \n \n                                                    Description\n                                                 \n Get the number of columns in the specified table/tree widget. \n \n \n Lua synopsis \n int count=simUI.getColumnCount(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n count  (int): column count \n \n \n Python synopsis \n int count=simUI.getColumnCount(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getComboboxItemCount\n \n \n \n                                                    Description\n                                                 \n Get the number of items in the specified combobox widget. \n \n \n Lua synopsis \n int count=simUI.getComboboxItemCount(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n count  (int): Item count. \n \n \n Python synopsis \n int count=simUI.getComboboxItemCount(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemText   simUI.getComboboxItems   simUI.getComboboxSelectedIndex   simUI.insertComboboxItem   simUI.removeComboboxItem   simUI.setComboboxItems   simUI.setComboboxSelectedIndex   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getComboboxItemText\n \n \n \n                                                    Description\n                                                 \n Get the text of an item in a combobox widget. \n \n \n Lua synopsis \n string text=simUI.getComboboxItemText(string handle, int id, int index) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n index  (int): Item index. \n \n \n \n Lua return values \n \n text  (string): Item text. \n \n \n Python synopsis \n string text=simUI.getComboboxItemText(string handle, int id, int index) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemCount   simUI.getComboboxItems   simUI.getComboboxSelectedIndex   simUI.insertComboboxItem   simUI.removeComboboxItem   simUI.setComboboxItems   simUI.setComboboxSelectedIndex   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getComboboxItems\n \n \n \n                                                    Description\n                                                 \n Get the content of a combobox. \n \n \n Lua synopsis \n string[] items=simUI.getComboboxItems(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n items  (table of string): Array of items (strings). \n \n \n Python synopsis \n list items=simUI.getComboboxItems(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemCount   simUI.getComboboxItemText   simUI.getComboboxSelectedIndex   simUI.insertComboboxItem   simUI.removeComboboxItem   simUI.setComboboxItems   simUI.setComboboxSelectedIndex   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getComboboxSelectedIndex\n \n \n \n                                                    Description\n                                                 \n Get the selected item index in a combobox widget. \n \n \n Lua synopsis \n int index=simUI.getComboboxSelectedIndex(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n index  (int): Index of selected item after inserting all the items. \n \n \n Python synopsis \n int index=simUI.getComboboxSelectedIndex(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemCount   simUI.getComboboxItemText   simUI.getComboboxItems   simUI.insertComboboxItem   simUI.removeComboboxItem   simUI.setComboboxItems   simUI.setComboboxSelectedIndex   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getCurrentEditWidget\n \n \n \n                                                    Description\n                                                 \n Get the edit widget with focus and selected text. \n \n \n Lua synopsis \n int id=simUI.getCurrentEditWidget(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n \n id  (int): widget id of an edit widget, or -1 if no edit widget was focused and had selected text. \n \n \n Python synopsis \n int id=simUI.getCurrentEditWidget(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.getEditValue   simUI.setCurrentEditWidget   simUI.setEditValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getCurrentTab\n \n \n \n                                                    Description\n                                                 \n Get the current tab index of a tabs widget. \n \n \n Lua synopsis \n int index=simUI.getCurrentTab(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n index  (int): index of the tab (zero-based) \n \n \n Python synopsis \n int index=simUI.getCurrentTab(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.setCurrentTab   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getCurveData\n \n \n \n                                                    Description\n                                                 \n Get the data contained in the specified curve. \n \n \n Lua synopsis \n double[] t, double[] x, double[] y=simUI.getCurveData(string handle, int id, string name) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n name  (string): name of the curve \n \n \n \n Lua return values \n \n \n t  (table of double): t values (if applicable) \n \n x  (table of double): x values \n \n y  (table of double): y values \n \n \n \n Python synopsis \n list t, list x, list y=simUI.getCurveData(string handle, int id, string name) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getEditValue\n \n \n \n                                                    Description\n                                                 \n Get the value of a edit widget. \n \n \n Lua synopsis \n string value=simUI.getEditValue(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n value  (string): value \n \n \n Python synopsis \n string value=simUI.getEditValue(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.getCurrentEditWidget   simUI.setCurrentEditWidget   simUI.setEditValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getItem\n \n \n \n                                                    Description\n                                                 \n Get the table widget item text. \n \n \n Lua synopsis \n string text=simUI.getItem(string handle, int id, int row, int column) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n row  (int): row index \n \n column  (int): column index \n \n \n \n Lua return values \n \n text  (string): item value \n \n \n Python synopsis \n string text=simUI.getItem(string handle, int id, int row, int column) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getLabelText\n \n \n \n                                                    Description\n                                                 \n Get the text of a label widget. \n \n \n Lua synopsis \n string text=simUI.getLabelText(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n text  (string): text \n \n \n Python synopsis \n string text=simUI.getLabelText(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.setLabelText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getPosition\n \n \n \n                                                    Description\n                                                 \n Get the position of a UI window. \n \n \n Lua synopsis \n int x, int y=simUI.getPosition(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n \n \n x  (int): X position \n \n y  (int): Y position \n \n \n \n Python synopsis \n int x, int y=simUI.getPosition(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.getRadiobuttonValue\n \n \n \n                                                    Description\n                                                 \n Get the value of a radiobutton widget. \n \n \n Lua synopsis \n int value=simUI.getRadiobuttonValue(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n value  (int): value \n \n \n Python synopsis \n int value=simUI.getRadiobuttonValue(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.setRadiobuttonValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getRowCount\n \n \n \n                                                    Description\n                                                 \n Get the table widget number of rows. \n \n \n Lua synopsis \n int count=simUI.getRowCount(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n count  (int): row count \n \n \n Python synopsis \n int count=simUI.getRowCount(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getSize\n \n \n \n                                                    Description\n                                                 \n Get the size of a UI window. \n \n \n Lua synopsis \n int w, int h=simUI.getSize(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n \n \n w  (int): width \n \n h  (int): height \n \n \n \n Python synopsis \n int w, int h=simUI.getSize(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.getSliderValue\n \n \n \n                                                    Description\n                                                 \n Get the value of a slider widget. \n \n \n Lua synopsis \n int value=simUI.getSliderValue(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n value  (int): value \n \n \n Python synopsis \n int value=simUI.getSliderValue(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.setSliderValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getSpinboxValue\n \n \n \n                                                    Description\n                                                 \n Get the value of a spinbox widget. \n \n \n Lua synopsis \n float value=simUI.getSpinboxValue(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n value  (float): value \n \n \n Python synopsis \n float value=simUI.getSpinboxValue(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.setSpinboxValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.getTitle\n \n \n \n                                                    Description\n                                                 \n Get the title of a UI window. \n \n \n Lua synopsis \n string title=simUI.getTitle(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n \n title  (string): X position \n \n \n Python synopsis \n string title=simUI.getTitle(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.getWidgetVisibility\n \n \n \n                                                    Description\n                                                 \n Get the visibility status of a widget. \n \n \n Lua synopsis \n bool visibility=simUI.getWidgetVisibility(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n visibility  (bool): true if the window is visible, false otherwise \n \n \n Python synopsis \n bool visibility=simUI.getWidgetVisibility(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.growPlotRanges\n \n \n \n                                                    Description\n                                                 \n Increase the ranges of the plot widget by a fixed amount. \n \n \n Lua synopsis \n simUI.growPlotRanges(string handle, int id, double xmin, double xmax, double ymin, double ymax) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n xmin  (double): minimum x range \n \n xmax  (double): maximum x range \n \n ymin  (double): minimum y range \n \n ymax  (double): maximum y range \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.growPlotRanges(string handle, int id, double xmin, double xmax, double ymin, double ymax) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.growPlotXRange\n \n \n \n                                                    Description\n                                                 \n Increase the X range of the plot widget. \n \n \n Lua synopsis \n simUI.growPlotXRange(string handle, int id, double xmin, double xmax) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n xmin  (double): minimum x range \n \n xmax  (double): maximum x range \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.growPlotXRange(string handle, int id, double xmin, double xmax) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.growPlotYRange\n \n \n \n                                                    Description\n                                                 \n Increase the Y range of the plot widget. \n \n \n Lua synopsis \n simUI.growPlotYRange(string handle, int id, double ymin, double ymax) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n ymin  (double): minimum y range \n \n ymax  (double): maximum y range \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.growPlotYRange(string handle, int id, double ymin, double ymax) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.hide\n \n \n \n                                                    Description\n                                                 \n Hide the UI window. \n \n \n Lua synopsis \n simUI.hide(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.hide(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.inputDialog\n \n \n \n                                                    Description\n                                                 \n Display an input dialog. \n \n \n Lua synopsis \n string result=simUI.inputDialog(string initValue="", string label="Input value:", string title="") \n \n \n \n Lua parameters \n \n \n initValue  (string, default: ""): initial value \n \n label  (string, default: "Input value:"): label above the input field \n \n title  (string, default: ""): title of input dialog \n \n \n \n Lua return values \n \n result  (string): result \n \n \n Python synopsis \n string result=simUI.inputDialog(string initValue="", string label="Input value:", string title="") \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.insertComboboxItem\n \n \n \n                                                    Description\n                                                 \n Insert an item in a combobox widget. \n \n \n Lua synopsis \n simUI.insertComboboxItem(string handle, int id, int index, string text, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n index  (int): If the index is equal to or higher than \nthe total number of items, the new item is appended to the list of \nexisting items. If the index is zero or negative, the new item is \nprepended to the list of existing items. \n \n text  (string): Item text. \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.insertComboboxItem(string handle, int id, int index, string text, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemCount   simUI.getComboboxItemText   simUI.getComboboxItems   simUI.getComboboxSelectedIndex   simUI.removeComboboxItem   simUI.setComboboxItems   simUI.setComboboxSelectedIndex   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.insertTableColumn\n \n \n \n                                                    Description\n                                                 \n insert a column in a table widget \n \n \n Lua synopsis \n simUI.insertTableColumn(int ui, int widget, int index) \n \n \n \n Lua parameters \n \n \n ui  (int): the ui handle \n \n widget  (int): the widget identifier \n \n index  (int): the index (0-based) where the new column will appear \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.insertTableColumn(int ui, int widget, int index) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.insertTableRow\n \n \n \n                                                    Description\n                                                 \n insert a row in a table widget \n \n \n Lua synopsis \n simUI.insertTableRow(int ui, int widget, int index) \n \n \n \n Lua parameters \n \n \n ui  (int): the ui handle \n \n widget  (int): the widget identifier \n \n index  (int): the index (0-based) where the new row will appear \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.insertTableRow(int ui, int widget, int index) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.isVisible\n \n \n \n                                                    Description\n                                                 \n Check if the window is visible. \n \n \n Lua synopsis \n bool visibility=simUI.isVisible(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n \n visibility  (bool): true if the window is visible, false otherwise \n \n \n Python synopsis \n bool visibility=simUI.isVisible(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.msgBox\n \n \n \n                                                    Description\n                                                 \n Display a message box. \n \n \n Lua synopsis \n int result=simUI.msgBox(int type, int buttons, string title, string message) \n \n \n \n Lua parameters \n \n \n type  (int): type \n \n buttons  (int): buttons \n \n title  (string): title \n \n message  (string): message \n \n \n \n Lua return values \n \n result  (int): result \n \n \n Python synopsis \n int result=simUI.msgBox(int type, int buttons, string title, string message) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.removeComboboxItem\n \n \n \n                                                    Description\n                                                 \n Remove an item from a combobox widget. \n \n \n Lua synopsis \n simUI.removeComboboxItem(string handle, int id, int index, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n index  (int): Item index. \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.removeComboboxItem(string handle, int id, int index, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemCount   simUI.getComboboxItemText   simUI.getComboboxItems   simUI.getComboboxSelectedIndex   simUI.insertComboboxItem   simUI.setComboboxItems   simUI.setComboboxSelectedIndex   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.removeCurve\n \n \n \n                                                    Description\n                                                 \n Remove the specified curve from the plot widget. \n \n \n Lua synopsis \n simUI.removeCurve(string handle, int id, string name) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n name  (string): name of the curve \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.removeCurve(string handle, int id, string name) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.removeScene3DNode\n \n \n \n                                                    Description\n                                                 \n Remove a node in a scene3d widget. \n \n \n Lua synopsis \n simUI.removeScene3DNode(string handle, int id, int nodeId) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.removeScene3DNode(string handle, int id, int nodeId) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector3Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.removeTableColumn\n \n \n \n                                                    Description\n                                                 \n remove a column from a table widget \n \n \n Lua synopsis \n simUI.removeTableColumn(int ui, int widget, int index) \n \n \n \n Lua parameters \n \n \n ui  (int): the ui handle \n \n widget  (int): the widget identifier \n \n index  (int): the column index (0-based) to remove \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.removeTableColumn(int ui, int widget, int index) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.removeTableRow\n \n \n \n                                                    Description\n                                                 \n remove a row from a table widget \n \n \n Lua synopsis \n simUI.removeTableRow(int ui, int widget, int index) \n \n \n \n Lua parameters \n \n \n ui  (int): the ui handle \n \n widget  (int): the widget identifier \n \n index  (int): the row index (0-based) to remove \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.removeTableRow(int ui, int widget, int index) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.removeTreeItem\n \n \n \n                                                    Description\n                                                 \n Remove an item from the specified tree widget. \n \n \n Lua synopsis \n simUI.removeTreeItem(string handle, int id, int item_id, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n item_id  (int): item id \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.removeTreeItem(string handle, int id, int item_id, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.replot\n \n \n \n                                                    Description\n                                                 \n Refresh all the plots of a plot widget. \n \n \n Lua synopsis \n simUI.replot(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.replot(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.rescaleAxes\n \n \n \n                                                    Description\n                                                 \n Rescales the axes such that the specified curve in the plot is fully visible. \n \n \n Lua synopsis \n simUI.rescaleAxes(string handle, int id, string name, bool onlyEnlargeX=false, bool onlyEnlargeY=false) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n name  (string): name of the curve \n \n onlyEnlargeX  (bool, default: false): makes sure the x ranges are only expanded, never reduced \n \n onlyEnlargeY  (bool, default: false): makes sure the x ranges are only expanded, never reduced \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.rescaleAxes(string handle, int id, string name, bool onlyEnlargeX=false, bool onlyEnlargeY=false) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.rescaleAxesAll\n \n \n \n                                                    Description\n                                                 \n Rescales the axes such that all curves in the plot are fully visible. \n \n \n Lua synopsis \n simUI.rescaleAxesAll(string handle, int id, bool onlyEnlargeX=false, bool onlyEnlargeY=false) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n onlyEnlargeX  (bool, default: false): makes sure the x ranges are only expanded, never reduced \n \n onlyEnlargeY  (bool, default: false): makes sure the x ranges are only expanded, never reduced \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.rescaleAxesAll(string handle, int id, bool onlyEnlargeX=false, bool onlyEnlargeY=false) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.restoreState\n \n \n \n                                                    Description\n                                                 \n Restore a previously saved header state of the specified table/tree widget. \n \n \n Lua synopsis \n simUI.restoreState(string handle, int id, string state) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n state  (string): a previously saved string representing the state \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.restoreState(string handle, int id, string state) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.saveState\n \n \n \n                                                    Description\n                                                 \n Save header state of the specified table/tree widget. \n \n \n Lua synopsis \n string state=simUI.saveState(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n \n \n Lua return values \n \n state  (string): a string representing the state \n \n \n Python synopsis \n string state=simUI.saveState(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setButtonPressed\n \n \n \n                                                    Description\n                                                 \n Set the state of a button. \n \n \n Lua synopsis \n simUI.setButtonPressed(string handle, int id, bool pressed) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n pressed  (bool): button state \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setButtonPressed(string handle, int id, bool pressed) \n \n \n \n \n                                                See also\n                                             \n   simUI.setButtonText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setButtonText\n \n \n \n                                                    Description\n                                                 \n Set the text of a button. \n \n \n Lua synopsis \n simUI.setButtonText(string handle, int id, string text) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n text  (string): button text \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setButtonText(string handle, int id, string text) \n \n \n \n \n                                                See also\n                                             \n   simUI.setButtonPressed   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setCheckboxValue\n \n \n \n                                                    Description\n                                                 \n Set the value of a checkbox widget. \n \n \n Lua synopsis \n simUI.setCheckboxValue(string handle, int id, int value, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n value  (int): value \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setCheckboxValue(string handle, int id, int value, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getCheckboxValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setColumnCount\n \n \n \n                                                    Description\n                                                 \n Resize the specified table/tree widget. \n \n \n Lua synopsis \n simUI.setColumnCount(string handle, int id, int count, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n count  (int): column count \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setColumnCount(string handle, int id, int count, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setColumnHeaderText\n \n \n \n                                                    Description\n                                                 \n Set the column header text of the specified table/tree widget. \n \n \n Lua synopsis \n simUI.setColumnHeaderText(string handle, int id, int column, string text) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n column  (int): column index \n \n text  (string): column header text \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setColumnHeaderText(string handle, int id, int column, string text) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setColumnWidth\n \n \n \n                                                    Description\n                                                 \n Resize a column in the specified table/tree widget. \n \n \n Lua synopsis \n simUI.setColumnWidth(string handle, int id, int column, int min_size, int max_size) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n column  (int): column index \n \n min_size  (int): minimum size \n \n max_size  (int): maximum size \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setColumnWidth(string handle, int id, int column, int min_size, int max_size) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setComboboxItems\n \n \n \n                                                    Description\n                                                 \n Populate a combobox widget with the specified items, and set the selected item to the specified index. \n \n \n Lua synopsis \n simUI.setComboboxItems(string handle, int id, string[] items, int index, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n items  (table of string): Array of items (strings). \n \n index  (int): Index of selected item after inserting all the items. \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setComboboxItems(string handle, int id, list items, int index, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemCount   simUI.getComboboxItemText   simUI.getComboboxItems   simUI.getComboboxSelectedIndex   simUI.insertComboboxItem   simUI.removeComboboxItem   simUI.setComboboxSelectedIndex   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setComboboxSelectedIndex\n \n \n \n                                                    Description\n                                                 \n Change the selected item index in a combobox widget. \n \n \n Lua synopsis \n simUI.setComboboxSelectedIndex(string handle, int id, int index, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n index  (int): Index of selected item after inserting all the items. \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setComboboxSelectedIndex(string handle, int id, int index, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getComboboxItemCount   simUI.getComboboxItemText   simUI.getComboboxItems   simUI.getComboboxSelectedIndex   simUI.insertComboboxItem   simUI.removeComboboxItem   simUI.setComboboxItems   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setCurrentEditWidget\n \n \n \n                                                    Description\n                                                 \n Set the edit widget focus and selected text. \n \n \n Lua synopsis \n simUI.setCurrentEditWidget(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id. this value can be -1, in which case the function will do nothing. \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setCurrentEditWidget(string handle, int id) \n \n \n \n \n                                                See also\n                                             \n   simUI.getCurrentEditWidget   simUI.getEditValue   simUI.setEditValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setCurrentTab\n \n \n \n                                                    Description\n                                                 \n Set the current tab index in a tabs widget. \n \n \n Lua synopsis \n simUI.setCurrentTab(string handle, int id, int index, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n index  (int): index of the tab (zero-based) \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setCurrentTab(string handle, int id, int index, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getCurrentTab   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setEditValue\n \n \n \n                                                    Description\n                                                 \n Set the value of a edit widget. \n \n \n Lua synopsis \n simUI.setEditValue(string handle, int id, string value, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n value  (string): value \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setEditValue(string handle, int id, string value, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getCurrentEditWidget   simUI.getEditValue   simUI.setCurrentEditWidget   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setEnabled\n \n \n \n                                                    Description\n                                                 \n Enable or disable a widget. \n \n \n Lua synopsis \n simUI.setEnabled(string handle, int id, bool enabled, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n enabled  (bool): enabled \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setEnabled(string handle, int id, bool enabled, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getWidgetVisibility   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setImageData\n \n \n \n                                                    Description\n                                                 \n Set image content using specified bitmap (RGB888) data. \n \n \n Lua synopsis \n simUI.setImageData(string handle, int id, string data, int width, int height) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): id of a image widget \n \n data  (string): image byte data \n \n width  (int): width of the image \n \n height  (int): height of the image \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setImageData(string handle, int id, string data, int width, int height) \n \n \n \n \n                                                See also\n                                             \n   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setItem\n \n \n \n                                                    Description\n                                                 \n Change item value in the specified table widget. \n \n \n Lua synopsis \n simUI.setItem(string handle, int id, int row, int column, string text, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n row  (int): row index \n \n column  (int): column index \n \n text  (string): item value \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setItem(string handle, int id, int row, int column, string text, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setItemEditable\n \n \n \n                                                    Description\n                                                 \n Change item editable flag in the specified table widget. \n \n \n Lua synopsis \n simUI.setItemEditable(string handle, int id, int row, int column, bool editable) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n row  (int): row index \n \n column  (int): column index \n \n editable  (bool): editable flag \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setItemEditable(string handle, int id, int row, int column, bool editable) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setItemImage\n \n \n \n                                                    Description\n                                                 \n Change item image in the specified table widget. \n \n \n Lua synopsis \n simUI.setItemImage(string handle, int id, int row, int column, string data, int width, int height, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n row  (int): row index \n \n column  (int): column index \n \n data  (string): image data \n \n width  (int): image width \n \n height  (int): image height \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setItemImage(string handle, int id, int row, int column, string data, int width, int height, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setLabelText\n \n \n \n                                                    Description\n                                                 \n Set the text of a label widget. \n \n \n Lua synopsis \n simUI.setLabelText(string handle, int id, string text, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n text  (string): text \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setLabelText(string handle, int id, string text, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getLabelText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setLegendVisibility\n \n \n \n                                                    Description\n                                                 \n Set visibility of the plot legend (default is hidden). \n \n \n Lua synopsis \n simUI.setLegendVisibility(string handle, int id, bool visible) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n visible  (bool): if true, the plot legend will be visible \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setLegendVisibility(string handle, int id, bool visible) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setMouseOptions\n \n \n \n                                                    Description\n                                                 \n Set plot widget options for interacting with mouse. \n \n \n Lua synopsis \n simUI.setMouseOptions(string handle, int id, bool panX, bool panY, bool zoomX, bool zoomY) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n panX  (bool): if true, panning (by dragging with the mouse) the X axis is allowed \n \n panY  (bool): if true, panning (by dragging with the mouse) the Y axis is allowed \n \n zoomX  (bool): if true, zooming (by mouse wheel) the X axis is allowed \n \n zoomY  (bool): if true, zooming (by mouse wheel) the Y axis is allowed \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setMouseOptions(string handle, int id, bool panX, bool panY, bool zoomX, bool zoomY) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setPlotLabels\n \n \n \n                                                    Description\n                                                 \n Set the labels of the plot widget. \n \n \n Lua synopsis \n simUI.setPlotLabels(string handle, int id, string x, string y) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n x  (string): x label \n \n y  (string): y label \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setPlotLabels(string handle, int id, string x, string y) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setPlotRanges\n \n \n \n                                                    Description\n                                                 \n Set the ranges of the plot widget. \n \n \n Lua synopsis \n simUI.setPlotRanges(string handle, int id, double xmin, double xmax, double ymin, double ymax) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n xmin  (double): minimum x range \n \n xmax  (double): maximum x range \n \n ymin  (double): minimum y range \n \n ymax  (double): maximum y range \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setPlotRanges(string handle, int id, double xmin, double xmax, double ymin, double ymax) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setPlotXLabel\n \n \n \n                                                    Description\n                                                 \n Set the X label of the plot widget. \n \n \n Lua synopsis \n simUI.setPlotXLabel(string handle, int id, string label) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n label  (string): x label \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setPlotXLabel(string handle, int id, string label) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setPlotXRange\n \n \n \n                                                    Description\n                                                 \n Set the X range of the plot widget. \n \n \n Lua synopsis \n simUI.setPlotXRange(string handle, int id, double xmin, double xmax) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n xmin  (double): minimum x range \n \n xmax  (double): maximum x range \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setPlotXRange(string handle, int id, double xmin, double xmax) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setPlotYLabel\n \n \n \n                                                    Description\n                                                 \n Set the Y label of the plot widget. \n \n \n Lua synopsis \n simUI.setPlotYLabel(string handle, int id, string label) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n label  (string): y label \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setPlotYLabel(string handle, int id, string label) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setPlotYRange\n \n \n \n                                                    Description\n                                                 \n Set the Y range of the plot widget. \n \n \n Lua synopsis \n simUI.setPlotYRange(string handle, int id, double ymin, double ymax) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n ymin  (double): minimum y range \n \n ymax  (double): maximum y range \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setPlotYRange(string handle, int id, double ymin, double ymax) \n \n \n \n \n                                                See also\n                                             \n   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setPosition\n \n \n \n                                                    Description\n                                                 \n Set the position of a UI window. \n \n \n Lua synopsis \n simUI.setPosition(string handle, int x, int y, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n x  (int): X position \n \n y  (int): Y position \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setPosition(string handle, int x, int y, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.setProgress\n \n \n \n                                                    Description\n                                                 \n Chnge the value of a progressbar widget. \n \n \n Lua synopsis \n simUI.setProgress(string handle, int id, int value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n value  (int): value \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setProgress(string handle, int id, int value) \n \n \n \n \n                                                See also\n                                             \n   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setRadiobuttonValue\n \n \n \n                                                    Description\n                                                 \n Set the value of a radiobutton widget. \n \n \n Lua synopsis \n simUI.setRadiobuttonValue(string handle, int id, int value, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n value  (int): value \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setRadiobuttonValue(string handle, int id, int value, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getRadiobuttonValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setRowCount\n \n \n \n                                                    Description\n                                                 \n Resize the specified table widget. \n \n \n Lua synopsis \n simUI.setRowCount(string handle, int id, int count, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n count  (int): row count \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setRowCount(string handle, int id, int count, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowHeaderText   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setRowHeaderText\n \n \n \n                                                    Description\n                                                 \n Set the row header text of the specified table widget. \n \n \n Lua synopsis \n simUI.setRowHeaderText(string handle, int id, int row, string text) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n row  (int): row index \n \n text  (string): row header text \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setRowHeaderText(string handle, int id, int row, string text) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeight   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setRowHeight\n \n \n \n                                                    Description\n                                                 \n Resize a row in the specified table widget. \n \n \n Lua synopsis \n simUI.setRowHeight(string handle, int id, int row, int min_size, int max_size) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n row  (int): row index \n \n min_size  (int): minimum size \n \n max_size  (int): maximum size \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setRowHeight(string handle, int id, int row, int min_size, int max_size) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setTableSelection   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setScene3DNodeEnabled\n \n \n \n                                                    Description\n                                                 \n Enable or disable a node in a scene3d widget. \n \n \n Lua synopsis \n simUI.setScene3DNodeEnabled(string handle, int id, int nodeId, bool enabled) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n enabled  (bool): enabled flag \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeEnabled(string handle, int id, int nodeId, bool enabled) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.removeScene3DNode   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector3Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setScene3DNodeFloatParam\n \n \n \n                                                    Description\n                                                 \n Set node float parameter in a scene3d widget. \n \n \n Lua synopsis \n simUI.setScene3DNodeFloatParam(string handle, int id, int nodeId, string paramName, float value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n paramName  (string): name of parameter \n \n value  (float): value of parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeFloatParam(string handle, int id, int nodeId, string paramName, float value) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.removeScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector3Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setScene3DNodeIntParam\n \n \n \n                                                    Description\n                                                 \n Set node int parameter in a scene3d widget. \n \n \n Lua synopsis \n simUI.setScene3DNodeIntParam(string handle, int id, int nodeId, string paramName, int value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n paramName  (string): name of parameter \n \n value  (int): value of parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeIntParam(string handle, int id, int nodeId, string paramName, int value) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.removeScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector3Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setScene3DNodeParam\n \n \n \n                                                    Description\n                                                 \n polymorphic version of the onSetScene3DNodeXXXParam() functions \n \n \n Lua synopsis \n simUI.setScene3DNodeParam(int ui, int widget, int nodeId, string paramName, any paramValue) \n \n \n \n Lua parameters \n \n \n ui  (int): the ui handle \n \n widget  (int): the widget identifier \n \n nodeId  (int): the node id \n \n paramName  (string): the parameter name \n \n paramValue  (any): the parameter value \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeParam(int ui, int widget, int nodeId, string paramName, any paramValue) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.setScene3DNodeStringParam\n \n \n \n                                                    Description\n                                                 \n Set node string parameter in a scene3d widget. \n \n \n Lua synopsis \n simUI.setScene3DNodeStringParam(string handle, int id, int nodeId, string paramName, string value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n paramName  (string): name of parameter \n \n value  (string): value of parameter \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeStringParam(string handle, int id, int nodeId, string paramName, string value) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.removeScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector3Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setScene3DNodeVector2Param\n \n \n \n                                                    Description\n                                                 \n Set node vector2 parameter in a scene3d widget. \n \n \n Lua synopsis \n simUI.setScene3DNodeVector2Param(string handle, int id, int nodeId, string paramName, float x, float y) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n paramName  (string): name of parameter \n \n x  (float): value of first component \n \n y  (float): value of second component \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeVector2Param(string handle, int id, int nodeId, string paramName, float x, float y) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.removeScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector3Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setScene3DNodeVector3Param\n \n \n \n                                                    Description\n                                                 \n Set node vector3 parameter in a scene3d widget. \n \n \n Lua synopsis \n simUI.setScene3DNodeVector3Param(string handle, int id, int nodeId, string paramName, float x, float y, float z) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n paramName  (string): name of parameter \n \n x  (float): value of first component \n \n y  (float): value of second component \n \n z  (float): value of third component \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeVector3Param(string handle, int id, int nodeId, string paramName, float x, float y, float z) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.removeScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector4Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setScene3DNodeVector4Param\n \n \n \n                                                    Description\n                                                 \n Set node vector4 parameter in a scene3d widget. \n \n \n Lua synopsis \n simUI.setScene3DNodeVector4Param(string handle, int id, int nodeId, string paramName, float x, float y, float z, float w) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n nodeId  (int): node id \n \n paramName  (string): name of parameter \n \n x  (float): value of first component \n \n y  (float): value of second component \n \n z  (float): value of third component \n \n w  (float): value of fourth component \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setScene3DNodeVector4Param(string handle, int id, int nodeId, string paramName, float x, float y, float z, float w) \n \n \n \n \n                                                See also\n                                             \n   simUI.addScene3DNode   simUI.removeScene3DNode   simUI.setScene3DNodeEnabled   simUI.setScene3DNodeFloatParam   simUI.setScene3DNodeIntParam   simUI.setScene3DNodeStringParam   simUI.setScene3DNodeVector2Param   simUI.setScene3DNodeVector3Param   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setSize\n \n \n \n                                                    Description\n                                                 \n Set the size of a UI window. \n \n \n Lua synopsis \n simUI.setSize(string handle, int w, int h, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n w  (int): width \n \n h  (int): height \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setSize(string handle, int w, int h, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setTitle   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.setSliderValue\n \n \n \n                                                    Description\n                                                 \n Set the value of a slider widget. \n \n \n Lua synopsis \n simUI.setSliderValue(string handle, int id, int value, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n value  (int): value \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setSliderValue(string handle, int id, int value, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getSliderValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setSpinboxValue\n \n \n \n                                                    Description\n                                                 \n Set the value of a spinbox widget. \n \n \n Lua synopsis \n simUI.setSpinboxValue(string handle, int id, float value, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n value  (float): value \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setSpinboxValue(string handle, int id, float value, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.getSpinboxValue   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setStyleSheet\n \n \n \n                                                    Description\n                                                 \n Set the stylesheet of a widget. \n \n \n Lua synopsis \n simUI.setStyleSheet(string handle, int id, string styleSheet) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n styleSheet  (string): stylesheet data \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setStyleSheet(string handle, int id, string styleSheet) \n \n \n \n \n                                                See also\n                                             \n   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setWidgetVisibility \n \n \n \n \n simUI.setTableSelection\n \n \n \n                                                    Description\n                                                 \n Set selection in a table widget. \n \n \n Lua synopsis \n simUI.setTableSelection(string handle, int id, int row, int column, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n row  (int): row index \n \n column  (int): column index \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setTableSelection(string handle, int id, int row, int column, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.clearTable   simUI.getColumnCount   simUI.getItem   simUI.getRowCount   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setItem   simUI.setItemEditable   simUI.setItemImage   simUI.setRowCount   simUI.setRowHeaderText   simUI.setRowHeight   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setText\n \n \n \n                                                    Description\n                                                 \n Set the text in a text-browser widget. \n \n \n Lua synopsis \n simUI.setText(string handle, int id, string text, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n text  (string): text content \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setText(string handle, int id, string text, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.setUrl   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setTitle\n \n \n \n                                                    Description\n                                                 \n Set the title of a UI window. \n \n \n Lua synopsis \n simUI.setTitle(string handle, string title, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n title  (string): X position \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setTitle(string handle, string title, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setWindowEnabled   simUI.show \n \n \n \n \n simUI.setTreeSelection\n \n \n \n                                                    Description\n                                                 \n Set selection in a tree widget. \n \n \n Lua synopsis \n simUI.setTreeSelection(string handle, int id, int item_id, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n item_id  (int): item id \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setTreeSelection(string handle, int id, int item_id, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.updateTreeItemParent   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setUrl\n \n \n \n                                                    Description\n                                                 \n Load an url in a text-browser widget. \n \n \n Lua synopsis \n simUI.setUrl(string handle, int id, string url) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n url  (string): url resource \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setUrl(string handle, int id, string url) \n \n \n \n \n                                                See also\n                                             \n   simUI.setText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.setWidgetVisibility\n \n \n \n                                                    Description\n                                                 \n Hide or show a widget. \n \n \n Lua synopsis \n simUI.setWidgetVisibility(string handle, int id, bool visibility) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n visibility  (bool): true if the window is visible, false otherwise \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setWidgetVisibility(string handle, int id, bool visibility) \n \n \n \n \n                                                See also\n                                             \n   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet \n \n \n \n \n simUI.setWindowEnabled\n \n \n \n                                                    Description\n                                                 \n Enable or disable a UI window. \n \n \n Lua synopsis \n simUI.setWindowEnabled(string handle, bool enabled, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n enabled  (bool): enabled \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.setWindowEnabled(string handle, bool enabled, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.show \n \n \n \n \n simUI.show\n \n \n \n                                                    Description\n                                                 \n Show the UI window. \n \n \n Lua synopsis \n simUI.show(string handle) \n \n \n \n Lua parameters \n \n handle  (string): ui handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.show(string handle) \n \n \n \n \n                                                See also\n                                             \n   simUI.create   simUI.destroy   simUI.getPosition   simUI.getSize   simUI.getTitle   simUI.hide   simUI.isVisible   simUI.setPosition   simUI.setSize   simUI.setTitle   simUI.setWindowEnabled \n \n \n \n \n simUI.supportedImageFormats\n \n \n \n                                                    Description\n                                                 \n Return a list of supported image formats \n \n \n Lua synopsis \n string[] formatList, string formatListStr=simUI.supportedImageFormats(string separator=nil) \n \n \n \n Lua parameters \n \n separator  (string, default: nil): if provided, also a string of formats concatenated by separator will be returned \n \n \n Lua return values \n \n \n formatList  (table of string): list of formats, each item will be the file extension of the format \n \n formatListStr  (string): concatenated list of formats, if separator is provided \n \n \n \n Python synopsis \n list formatList, string formatListStr=simUI.supportedImageFormats(string separator=nil) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simUI.svgLoadData\n \n \n \n                                                    Description\n                                                 \n Load a SVG document in a SVG widget. \n \n \n Lua synopsis \n simUI.svgLoadData(string handle, int id, string data) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n data  (string): SVG data (XML) as a string \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.svgLoadData(string handle, int id, string data) \n \n \n \n \n                                                See also\n                                             \n   simUI.svgLoadFile   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.svgLoadFile\n \n \n \n                                                    Description\n                                                 \n Load a SVG file in a SVG widget. \n \n \n Lua synopsis \n simUI.svgLoadFile(string handle, int id, string file) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n file  (string): file path \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.svgLoadFile(string handle, int id, string file) \n \n \n \n \n                                                See also\n                                             \n   simUI.svgLoadData   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.updateTreeItemParent\n \n \n \n                                                    Description\n                                                 \n Modify the parent of an existing item in the specified tree widget. \n \n \n Lua synopsis \n simUI.updateTreeItemParent(string handle, int id, int item_id, int parent_id, bool suppressEvents=true) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n item_id  (int): item id \n \n parent_id  (int): parent id \n \n suppressEvents  (bool, default: true): if true, no event will be generated from this call \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.updateTreeItemParent(string handle, int id, int item_id, int parent_id, bool suppressEvents=true) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemText   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n simUI.updateTreeItemText\n \n \n \n                                                    Description\n                                                 \n Modify the text of an existing item in the specified tree widget. \n \n \n Lua synopsis \n simUI.updateTreeItemText(string handle, int id, int item_id, string[] text) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): widget id \n \n item_id  (int): item id \n \n text  (table of string): item text fields \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.updateTreeItemText(string handle, int id, int item_id, list text) \n \n \n \n \n                                                See also\n                                             \n   simUI.addTreeItem   simUI.clearTree   simUI.collapseAll   simUI.expandAll   simUI.expandToDepth   simUI.getColumnCount   simUI.removeTreeItem   simUI.restoreState   simUI.saveState   simUI.setColumnCount   simUI.setColumnHeaderText   simUI.setColumnWidth   simUI.setTreeSelection   simUI.updateTreeItemParent   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simUI.msgbox_type\n \n info \n question \n warning \n critical \n \n \n simUI.msgbox_buttons\n \n ok \n yesno \n yesnocancel \n okcancel \n \n \n simUI.msgbox_result\n \n cancel \n no \n yes \n ok \n \n \n simUI.filedialog_type\n \n load \n load_multiple \n save \n folder \n \n \n simUI.curve_type\n \n \n time : a curve with an X-simple domain, i.e.  y = f(x) \n \n \n xy : a parametric curve, i.e.  x = f x (t), y = f y (t) \n \n \n \n simUI.curve_style\n \n scatter \n line \n line_and_scatter \n \n step_left : only available for \'time\' curves \n \n step_center : only available for \'time\' curves \n \n step_right : only available for \'time\' curves \n \n impulse : only available for \'time\' curves \n \n \n simUI.curve_scatter_shape\n \n none \n dot \n cross \n plus \n circle \n disc \n square \n diamond \n star \n triangle \n triangle_inverted \n cross_square \n plus_square \n cross_circle \n plus_circle \n peace \n \n \n simUI.line_style\n \n solid \n dotted \n dashed \n \n \n simUI.scene3d_node_type\n \n entity \n transform \n camera \n camera_controller_first_person \n camera_controller_orbit \n light_point \n light_directional \n light_spot \n mesh_cuboid \n mesh_torus \n mesh_cone \n mesh_cylinder \n mesh_plane \n mesh_sphere \n mesh \n material_phong \n material_gooch \n material_texture \n material_diffuse_map \n texture2d \n texture_image \n object_picker \n \n \n simUI.mouse\n \n \n left_button_down : left mouse button pressed \n \n left_button_up : left mouse button released \n \n move : mouse pointer has been moved \n \n \n \n Data structures \n Data structures are used to pass complex data around. Create data structures in Lua in the form of a map, e.g.:  {line_size=3, add_to_legend=false, selectable=true} \n \n curve_options\n \n \n \n                                                Description\n                                             \n Extra options for the curve creation function  simUI.addCurve . \n \n \n \n Fields \n \n \n scatter_shape  (int, default: sim_ui_curve_scatter_shape_disc): scatter shape. see  simUI.curve_scatter_shape . \n \n scatter_size  (int, default: 10): size of the scatter shape \n \n line_size  (int, default: 2): size of the line \n \n line_style  (int, default: sim_ui_line_style_solid): style of the pen used to draw the line. see  simUI.line_style . \n \n add_to_legend  (bool, default: true): if false, the curve will not be added to the legend \n \n selectable  (bool, default: true): if false, the curve points cannot be selected and will not react to click events \n \n track  (bool, default: false): if true, enable the mouse tracker \n \n \n \n \n                                                See also\n                                             \n   simUI.curve_scatter_shape   simUI.addCurve   simUI.addCurveTimePoints   simUI.addCurveXYPoints   simUI.clearCurve   simUI.getCurveData   simUI.growPlotRanges   simUI.growPlotXRange   simUI.growPlotYRange   simUI.removeCurve   simUI.replot   simUI.rescaleAxes   simUI.rescaleAxesAll   simUI.setLegendVisibility   simUI.setMouseOptions   simUI.setPlotLabels   simUI.setPlotRanges   simUI.setPlotXLabel   simUI.setPlotXRange   simUI.setPlotYLabel   simUI.setPlotYRange   simUI.getWidgetVisibility   simUI.setEnabled   simUI.setStyleSheet   simUI.setWidgetVisibility \n \n \n \n \n keyboard_modifiers\n \n \n \n                                                Description\n                                             \n \n \n \n Fields \n \n \n control  (bool, default: false):  \n \n shift  (bool, default: false):  \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Script functions \n Script functions are used to call some lua code from the plugin side (tipically used for event handlers). \n \n onclickCallback\n \n \n \n                                                    Description\n                                                 \n Callback for button click event. \n \n \n Lua synopsis \n simUI.onclickCallback(string handle, int id) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): the ID of the clicked button \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onclickCallback(string handle, int id) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onLinkActivatedCallback\n \n \n \n                                                    Description\n                                                 \n Callback for when a link is clicked. \n \n \n Lua synopsis \n simUI.onLinkActivatedCallback(string handle, int id, string link) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): the ID of the clicked button \n \n link  (string): the href attribute of the activated link \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onLinkActivatedCallback(string handle, int id, string link) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onchangeIntCallback\n \n \n \n                                                    Description\n                                                 \n Callback for widget change event. \n \n \n Lua synopsis \n simUI.onchangeIntCallback(string handle, int id, int value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): the ID of the widget \n \n value  (int): the new value \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onchangeIntCallback(string handle, int id, int value) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onchangeDoubleCallback\n \n \n \n                                                    Description\n                                                 \n Callback for widget change event. \n \n \n Lua synopsis \n simUI.onchangeDoubleCallback(string handle, int id, float value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): the ID of the widget \n \n value  (float): the new value \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onchangeDoubleCallback(string handle, int id, float value) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onchangeStringCallback\n \n \n \n                                                    Description\n                                                 \n Callback for widget change event. \n \n \n Lua synopsis \n simUI.onchangeStringCallback(string handle, int id, string value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): the ID of the widget \n \n value  (string): the new value \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onchangeStringCallback(string handle, int id, string value) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n oneditingfinishedCallback\n \n \n \n                                                    Description\n                                                 \n Callback for editing finished event. \n \n \n Lua synopsis \n simUI.oneditingfinishedCallback(string handle, int id, string value) \n \n \n \n Lua parameters \n \n \n handle  (string): ui handle \n \n id  (int): the ID of the widget \n \n value  (string): the new value \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.oneditingfinishedCallback(string handle, int id, string value) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n oncloseCallback\n \n \n \n                                                    Description\n                                                 \n Callback for window close event. It will \nbe called when the user clicks the close button of the window. When an \nonclose callback is specified, the window will not close automatically \nwhen the user clicks the window close button. \n \n \n Lua synopsis \n simUI.oncloseCallback(string handle) \n \n \n \n Lua parameters \n \n handle  (string): the handle of the UI \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.oncloseCallback(string handle) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onPlottableClickCallback\n \n \n \n                                                    Description\n                                                 \n Callback for plot widget plottableClick event. \n \n \n Lua synopsis \n simUI.onPlottableClickCallback(string handle, int id, string curve, int index, float x, float y) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the plot widget \n \n curve  (string): the name of the curve \n \n index  (int): the index of the clicked point in the curve \n \n x  (float): the x value of the clicked point \n \n y  (float): the y value of the clicked point \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onPlottableClickCallback(string handle, int id, string curve, int index, float x, float y) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onLegendClickCallback\n \n \n \n                                                    Description\n                                                 \n Callback for plot widget legendClick event. \n \n \n Lua synopsis \n simUI.onLegendClickCallback(string handle, int id, string curve) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the plot widget \n \n curve  (string): the name of the curve \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onLegendClickCallback(string handle, int id, string curve) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onCellActivateCallback\n \n \n \n                                                    Description\n                                                 \n Callback for table widget cellActivated event. \n \n \n Lua synopsis \n simUI.onCellActivateCallback(string handle, int id, int row, int column, string cellValue) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the plot widget \n \n row  (int): the row index (zero based) of the activated cell \n \n column  (int): the column index (zero based) of the activated cell \n \n cellValue  (string): the value of the cell \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onCellActivateCallback(string handle, int id, int row, int column, string cellValue) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onTableSelectionChangeCallback\n \n \n \n                                                    Description\n                                                 \n Callback for table widget selectionChanged event. \n \n \n Lua synopsis \n simUI.onTableSelectionChangeCallback(string handle, int id, int row, int column) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the plot widget \n \n row  (int): the row index (zero based) of the activated cell \n \n column  (int): the column index (zero based) of the activated cell \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onTableSelectionChangeCallback(string handle, int id, int row, int column) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onTreeSelectionChangeCallback\n \n \n \n                                                    Description\n                                                 \n Callback for tree widget selectionChanged event. \n \n \n Lua synopsis \n simUI.onTreeSelectionChangeCallback(string handle, int id, int item_id) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the plot widget \n \n item_id  (int): the item id \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onTreeSelectionChangeCallback(string handle, int id, int item_id) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onMouseEventCallback\n \n \n \n                                                    Description\n                                                 \n Callback for a mouse event. \n \n \n Lua synopsis \n simUI.onMouseEventCallback(string handle, int id, int type, keyboard_modifiers mods, int x, int y) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the widget \n \n type  (int): the mouse event type, one of the values from  simUI.mouse \n \n \n mods  (keyboard_modifiers): modifiers. see  keyboard_modifiers \n \n \n x  (int): x coordinate of mouse pointer \n \n y  (int): y coordinate of mouse pointer \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onMouseEventCallback(string handle, int id, int type, keyboard_modifiers mods, int x, int y) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onKeyPressCallback\n \n \n \n                                                    Description\n                                                 \n Callback called when a key is pressed in a widget. \n \n \n Lua synopsis \n simUI.onKeyPressCallback(string handle, int id, int key, string text) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the widget \n \n key  (int): the integer value of the key \n \n text  (string): a textual representation of the key \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onKeyPressCallback(string handle, int id, int key, string text) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n onScene3DObjectClickCallback\n \n \n \n                                                    Description\n                                                 \n Callback called when an object is clicked in a scene3d widget. \n \n \n Lua synopsis \n simUI.onScene3DObjectClickCallback(string handle, int id, int nodeId) \n \n \n \n Lua parameters \n \n \n handle  (string): the handle of the UI \n \n id  (int): the ID of the widget \n \n nodeId  (int): the ID of the object-picker \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simUI.onScene3DObjectClickCallback(string handle, int id, int nodeId) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'UIPluginAPIreference.html'}, {'title': 'simUI-widgets', 'text': '\n CustomUI Plugin - UI XML Syntax\n Elements: \n \n <ui> \n <button> \n <checkbox> \n <combobox> \n <edit> \n <group> \n <hslider> \n <image> \n <label> \n <plot> \n <progressbar> \n <radiobutton> \n <scene3d> \n <spinbox> \n <table> \n <tabs> \n <tab> \n <text-browser> \n <tree> \n <vslider> \n <svg> \n <stretch> \n <br> \n \n \n \n \n ^ \n \n \n Element: \n <ui> \n \n \n Description: \n Root element (related to Custom UI window). \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n modal \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, the dialog window will be modal. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n title \n \n \n Type: \n string \n \n \n Default: \n Custom UI \n \n \n Description: \n Title of the Custom UI window. \n \n \n \n Name: \n resizable \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n Make window resizable if true. \n \n \n \n Name: \n closeable \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n Make window closeable if true. \n \n \n \n Name: \n layout \n \n \n Type: \n \n        One of:\n         \n vbox \n hbox \n form \n grid \n none \n \n \n \n \n Default: \n vbox \n \n \n Description: \n Layout of the widget. When layout is \'none\', specify widget placement using the geometry attribute, like: geometry="x,y,width,height". \n \n \n \n Name: \n content-margins \n \n \n Type: \n int[4] \n \n \n Default: \n 7,7,7,7 \n \n \n Description: \n Sets the left, top, right, and bottom margins to use around the layout. \n \n \n \n Name: \n placement \n \n \n Type: \n \n        One of:\n         \n center \n relative \n absolute \n \n \n \n \n Default: \n center \n \n \n Description: \n Placement of the window widget. It will affect how the position attribute is interpreted. \n \n \n \n Name: \n position \n \n \n Type: \n int[2] \n \n \n Default: \n 50,50 \n \n \n Description: \n Position of the window widget. \n \n \n \n Name: \n size \n \n \n Type: \n int[2] \n \n \n Default: \n -1,-1 \n \n \n Description: \n Initial size of the window widget. -1,-1 will use the default behavior (automatically compute the optimal size). \n \n \n \n Name: \n activate \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If false, the window is shown without activating it (Qt flag WA_ShowWithoutActivating). \n \n \n \n Name: \n on-close \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the close event. Arguments of the function are: (uiHandle). When a callback is specified, the window will not close upon pressing the close button. It may be hidden or destroyed explicitly in the callback. \n \n \n \n \n See also: \n \n <stretch> \n <br> \n \n \n \n ^ \n \n \n Element: \n <button> \n \n \n Description: \n Push button widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n text \n \n \n Type: \n string \n \n \n Default: \n ??? \n \n \n Description: \n Text on the button. \n \n \n \n Name: \n default \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, this is the default button of the dialog window. \n \n \n \n Name: \n auto-repeat \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If auto-repeat is enabled, then the click() signal is emitted at regular intervals when the button is down. \n \n \n \n Name: \n auto-repeat-delay \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Defines the initial delay in milliseconds before auto-repetition kicks in. \n \n \n \n Name: \n auto-repeat-interval \n \n \n Type: \n int \n \n \n Default: \n 200 \n \n \n Description: \n Defines the length of the auto-repetition interval in milliseconds. \n \n \n \n Name: \n checkable \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, the button is checkable. \n \n \n \n Name: \n checked \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, the button is initially checked. \n \n \n \n Name: \n auto-exclusive \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, checkable buttons that belong to the same parent widget behave as if they were part of the same exclusive button group. In an exclusive button group, only one button can be checked at any time; checking another button automatically unchecks the previously checked one. \n \n \n \n Name: \n on-click \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the click event. Arguments of the function are: (uiHandle, id). \n \n \n \n Name: \n icon \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a icon to use. The only icon name scheme supported is default://SP_xxx where SP_xxx is a constant from http://doc.qt.io/qt-5/qstyle.htmll#StandardPixmap-enum \n \n \n \n \n ^ \n \n \n Element: \n <checkbox> \n \n \n Description: \n Checkbox widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n text \n \n \n Type: \n string \n \n \n Default: \n ??? \n \n \n Description: \n Text on the checkbox label. \n \n \n \n Name: \n checked \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, the checkbox is initially checked. \n \n \n \n Name: \n checkable \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, the button is checkable. \n \n \n \n Name: \n auto-exclusive \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, checkable buttons that belong to the same parent widget behave as if they were part of the same exclusive button group. In an exclusive button group, only one button can be checked at any time; checking another button automatically unchecks the previously checked one. \n \n \n \n Name: \n on-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the change event.  Arguments of the function are: (uiHandle, id, newValue). \n \n \n \n \n ^ \n \n \n Element: \n <combobox> \n \n \n Description: \n A combobox widget. It allows to select one from many items from a dropdown menu.  Items can be added as child XML nodes, e.g. <item>Item text</item>, or dynamically via the script API. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n checkable \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, the button is checkable. \n \n \n \n Name: \n auto-exclusive \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, checkable buttons that belong to the same parent widget behave as if they were part of the same exclusive button group. In an exclusive button group, only one button can be checked at any time; checking another button automatically unchecks the previously checked one. \n \n \n \n Name: \n on-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the change event.  Arguments of the function are: (uiHandle, id, newValue). \n \n \n \n \n ^ \n \n \n Element: \n <edit> \n \n \n Description: \n A widget for text input. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n value \n \n \n Type: \n string \n \n \n Default: \n ??? \n \n \n Description: \n Initial text. \n \n \n \n Name: \n password \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, display platform-dependent password mask characters instead of the characters actually entered. \n \n \n \n Name: \n on-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the change event.  Arguments of the function are: (uiHandle, id, newValue). \n \n \n \n Name: \n on-editing-finished \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the editing finished event.  Arguments of the function are: (uiHandle, id, newValue). \n \n \n \n \n ^ \n \n \n Element: \n <group> \n \n \n Description: \n A widget for grouping other widgets.  Other widgets are specified as children of the <group> node.  It has its own layout, so it can be used to use a different layout only for a group of widgets. It is also required to group a set of radiobutton widgets. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n flat \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, the group will have no visual appearance (text will be ignored).  Otherwise, it will have some visual appearance, depending on the platform. \n \n \n \n Name: \n layout \n \n \n Type: \n \n        One of:\n         \n vbox \n hbox \n form \n grid \n none \n \n \n \n \n Default: \n vbox \n \n \n Description: \n Layout of the widget. When layout is \'none\', specify widget placement using the geometry attribute, like: geometry="x,y,width,height". \n \n \n \n Name: \n content-margins \n \n \n Type: \n int[4] \n \n \n Default: \n 7,7,7,7 \n \n \n Description: \n Sets the left, top, right, and bottom margins to use around the layout. \n \n \n \n \n See also: \n \n <stretch> \n <br> \n \n \n \n ^ \n \n \n Element: \n <hslider> \n \n \n Description: \n A horizontal slider widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n value \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Initial value. \n \n \n \n Name: \n minimum \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Minimum value. \n \n \n \n Name: \n maximum \n \n \n Type: \n int \n \n \n Default: \n 100 \n \n \n Description: \n Maximum value. \n \n \n \n Name: \n tick-interval \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Tick interval. \n \n \n \n Name: \n tick-position \n \n \n Type: \n \n        One of:\n         \n none \n both-sides \n above \n below \n left \n right \n \n \n \n \n Default: \n none \n \n \n Description: \n In which direction to draw ticks. \n \n \n \n Name: \n inverted \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, minimum and maximum will be swapped. \n \n \n \n Name: \n on-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the change event.  Arguments of the function are: (uiHandle, id, newValue). \n \n \n \n \n See also: \n <vslider> \n \n \n ^ \n \n \n Element: \n <image> \n \n \n Description: \n A image display widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n file \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Display the image from the specified file. \n \n \n \n Name: \n width \n \n \n Type: \n int \n \n \n Default: \n -1 \n \n \n Description: \n Desired width for the initial image. \n \n \n \n Name: \n height \n \n \n Type: \n int \n \n \n Default: \n -1 \n \n \n Description: \n Desired height for the initial image. \n \n \n \n Name: \n scaled-contents \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n This property holds whether this widget will scale its image to fill all available space. \n \n \n \n Name: \n keep-aspect-ratio \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, and also scaled-contents is true, will keep aspect ratio when resizing. \n \n \n \n Name: \n on-mouse-down \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the mouseDown event. Arguments of the function are: (uiHandle, id, type, flags, x, y). \n \n \n \n Name: \n on-mouse-up \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the mouseUp event. Arguments of the function are: (uiHandle, id, type, flags, x, y). \n \n \n \n Name: \n on-mouse-move \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the mouseMove event. Arguments of the function are: (uiHandle, id, type, flags, x, y). \n \n \n \n \n See also: \n \n <label> \n <svg> \n \n \n \n ^ \n \n \n Element: \n <label> \n \n \n Description: \n A static text widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n text \n \n \n Type: \n string \n \n \n Default: \n ??? \n \n \n Description: \n Text on the label. \n \n \n \n Name: \n wordwrap \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, long text will wrap in multiple lines, otherwise will be cut. \n \n \n \n Name: \n on-link-activated \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the linkActivated event. Arguments of the function are: (uiHandle, id, linkHref). \n \n \n \n \n See also: \n <edit> \n \n \n ^ \n \n \n Element: \n <plot> \n \n \n Description: \n A widget for displaying time series charts. \n \n \n Attributes: \n \n \n Name: \n background-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the background, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the color of the window\'s background. \n \n \n \n Name: \n foreground-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the foreground elements (i.e.: axes, axes labels, tick labels, tick marks and grid lines), as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. This value can be overridden by any of the specific attributes for the individual elements. \n \n \n \n Name: \n axis-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the axes, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. Can be overridden by axis-x-color and axis-y-color. \n \n \n \n Name: \n label-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the axis labels, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. Can be overridden by label-x-color and label-y-color. \n \n \n \n Name: \n grid-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the grid, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. Can be overridden by grid-x-color and grid-y-color. \n \n \n \n Name: \n tick-label-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the tick labels, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n axis-x-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the X axis, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n axis-y-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the Y axis, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n label-x-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the X label, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n label-y-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the Y label, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n grid-x-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the X grid, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n grid-y-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the Y grid, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n tick-label-x-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the X tick labels, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n tick-label-y-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the Y tick labels, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the default color. \n \n \n \n Name: \n square \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n \n \n \n \n Name: \n max-buffer-size \n \n \n Type: \n int \n \n \n Default: \n 1000 \n \n \n Description: \n Maximum size of the buffer(s). \n \n \n \n Name: \n cyclic-buffer \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, buffers will be cyclic when full. \n \n \n \n Name: \n ticks \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, x and y tickmarks will be visible. \n \n \n \n Name: \n x-ticks \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, x tickmarks will be visible. \n \n \n \n Name: \n y-ticks \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, y tickmarks will be visible. \n \n \n \n Name: \n tick-labels \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, x and y tick labels will be visible. \n \n \n \n Name: \n x-tick-labels \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, x tick labels will be visible. \n \n \n \n Name: \n y-tick-labels \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, y tick labels will be visible. \n \n \n \n Name: \n on-click \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the click event on a curve data point.  Arguments of the function are: (uiHandle, id, curveName, dataIndex, xValue, yValue). \n \n \n \n Name: \n on-legend-click \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the click event on a legend item.  Arguments of the function are: (uiHandle, id, curveName). \n \n \n \n \n ^ \n \n \n Element: \n <progressbar> \n \n \n Description: \n A progress indicator widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n minimum \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Minimum value of the progress. \n \n \n \n Name: \n maximum \n \n \n Type: \n int \n \n \n Default: \n 100 \n \n \n Description: \n Maximum value of the progress. \n \n \n \n Name: \n orientation \n \n \n Type: \n \n        One of:\n         \n horizontal \n vertical \n \n \n \n \n Default: \n horizontal \n \n \n Description: \n Orientation. \n \n \n \n Name: \n inverted \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, the progress ends will be inverted. \n \n \n \n Name: \n value \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Initial value. \n \n \n \n Name: \n text-visible \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Visibility of progress text. \n \n \n \n \n ^ \n \n \n Element: \n <radiobutton> \n \n \n Description: \n A radio button widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n text \n \n \n Type: \n string \n \n \n Default: \n ??? \n \n \n Description: \n Text on the button. \n \n \n \n Name: \n checked \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, this button will be initially checked. \n \n \n \n Name: \n on-click \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the click event.  Arguments of the function are: (uiHandle, id). \n \n \n \n \n ^ \n \n \n Element: \n <scene3d> \n \n \n Description: \n A widget for displaying a 3D scene. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n clear-color \n \n \n Type: \n int[3] \n \n \n Default: \n -1,-1,-1 \n \n \n Description: \n Color of the background, as three RGB components in the 0...255 range. The special value -1,-1,-1 means to use the color of the window\'s background. \n \n \n \n Name: \n on-click \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the click event. Arguments of the function are: (uiHandle, id, nodeId). \n \n \n \n \n ^ \n \n \n Element: \n <spinbox> \n \n \n Description: \n A widget for numeric input, with increase/decrease buttons. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n value \n \n \n Type: \n int or float \n \n \n Default: \n 0 \n \n \n Description: \n Initial value. \n \n \n \n Name: \n minimum \n \n \n Type: \n int or float \n \n \n Default: \n 0 \n \n \n Description: \n Minimum value. \n \n \n \n Name: \n maximum \n \n \n Type: \n int or float \n \n \n Default: \n 100 \n \n \n Description: \n Maximum value. \n \n \n \n Name: \n prefix \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n String prefix in the displayed value. \n \n \n \n Name: \n suffix \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n String suffix in the displayed value. \n \n \n \n Name: \n step \n \n \n Type: \n int or float \n \n \n Default: \n 1 \n \n \n Description: \n Step (increment/decrement) when using the buttons. \n \n \n \n Name: \n decimals \n \n \n Type: \n int \n \n \n Default: \n 6 \n \n \n Description: \n Number of displayed decimal places. \n \n \n \n Name: \n float \n \n \n Type: \n bool \n \n \n Default: \n autodetect \n \n \n Description: \n If true, the spinbox will display a floating point value. If false, the spinbox will display integer values. If omitted, this property will be automatically determined by minimum/maximum/step values: if any of those is not a round integer, or if decimals is specified, the spinbox will be float. \n \n \n \n Name: \n on-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the change event.  Arguments of the function are: (uiHandle, id, newValue). \n \n \n \n \n ^ \n \n \n Element: \n <table> \n \n \n Description: \n A table widget. Can optionally contain a <header> elements and <row> elements. Each <header>/<row> element contains only <item> elements. <item> elements may have an optional "editable" attribute of type bool. \n \n \n Attributes: \n \n \n Name: \n show-horizontal-header \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, column headers will be visible. \n \n \n \n Name: \n show-vertical-header \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, row headers will be visible. The \'label\' attribute of the <row> can be used to change the displayed text of the row header. The default row header is the line number. \n \n \n \n Name: \n autosize-horizontal-header \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, column headers will resize to fit contents. \n \n \n \n Name: \n autosize-vertical-header \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, row headers will resize to fit contents. \n \n \n \n Name: \n show-grid \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, grid will be visible. \n \n \n \n Name: \n selection-mode \n \n \n Type: \n \n        One of:\n         \n items \n rows \n columns \n \n \n \n \n Default: \n items \n \n \n Description: \n Controls the selection behavior, i.e. if the user can select individual items, entire rows, or entire columns. \n \n \n \n Name: \n editable \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, cells will be editable. \n \n \n \n Name: \n sortable \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, it will be possible to sort data by columns by clicking on column headers. \n \n \n \n Name: \n on-cell-activate \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the cell activate event. Arguments of the function are: (uiHandle, id, row, column, cellValue). \n \n \n \n Name: \n on-selection-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the selection change event. Arguments of the function are: (uiHandle, id, row, column). If selection mode is \'rows\', column will be -1 and vice versa. \n \n \n \n Name: \n on-key-press \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the key press event. Arguments of the function are: (uiHandle, id, key, text). \n \n \n \n \n ^ \n \n \n Element: \n <tabs> \n \n \n Description: \n A tabs widget. Must contain only <tab> child elements. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n \n See also: \n <tab> \n \n \n ^ \n \n \n Element: \n <tab> \n \n \n Description: \n A tab for the tabs widget. Can only be contained in a <tabs> element.\nCan contain widgets, just like <ui> and <group>, and has its own layout. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n title \n \n \n Type: \n string \n \n \n Default: \n ??? \n \n \n Description: \n Title of the tab. \n \n \n \n Name: \n layout \n \n \n Type: \n \n        One of:\n         \n vbox \n hbox \n form \n grid \n none \n \n \n \n \n Default: \n vbox \n \n \n Description: \n Layout of the widget. When layout is \'none\', specify widget placement using the geometry attribute, like: geometry="x,y,width,height". \n \n \n \n Name: \n content-margins \n \n \n Type: \n int[4] \n \n \n Default: \n 7,7,7,7 \n \n \n Description: \n Sets the left, top, right, and bottom margins to use around the layout. \n \n \n \n \n See also: \n \n <stretch> \n <br> \n \n \n \n ^ \n \n \n Element: \n <text-browser> \n \n \n Description: \n A text browser widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n text \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Initial text content. \n \n \n \n Name: \n html \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n if true, text will be treated as HTML \n \n \n \n Name: \n read-only \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n if true, text will be read-only \n \n \n \n Name: \n on-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the change event.  Arguments of the function are: (uiHandle, id, newText). \n \n \n \n Name: \n on-link-activated \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the linkActivated event. Arguments of the function are: (uiHandle, id, linkHref). \n \n \n \n \n See also: \n <edit> \n \n \n ^ \n \n \n Element: \n <tree> \n \n \n Description: \n A tree widget. Must contain one <header> element and many <row> elements. Each <header>/<row> element contains only <item> elements. <row> elements can have \'id\' and \'parent-id\' attributes (positive integers) to set relationships between items, and a \'expanded\' attribute (bool) to initially expand the item. \n \n \n Attributes: \n \n \n Name: \n show-header \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n If true, column headers will be visible. \n \n \n \n Name: \n autosize-header \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, column headers will resize to fit contents. \n \n \n \n Name: \n sortable \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, it will be possible to sort data by columns by clicking on column headers. \n \n \n \n Name: \n on-selection-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the selection change event. Arguments of the function are: (uiHandle, id, item_id). \n \n \n \n \n ^ \n \n \n Element: \n <vslider> \n \n \n Description: \n A vertical slider widget. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n value \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Initial value. \n \n \n \n Name: \n minimum \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Minimum value. \n \n \n \n Name: \n maximum \n \n \n Type: \n int \n \n \n Default: \n 100 \n \n \n Description: \n Maximum value. \n \n \n \n Name: \n tick-interval \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Tick interval. \n \n \n \n Name: \n tick-position \n \n \n Type: \n \n        One of:\n         \n none \n both-sides \n above \n below \n left \n right \n \n \n \n \n Default: \n none \n \n \n Description: \n In which direction to draw ticks. \n \n \n \n Name: \n inverted \n \n \n Type: \n bool \n \n \n Default: \n false \n \n \n Description: \n If true, minimum and maximum will be swapped. \n \n \n \n Name: \n on-change \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the change event.  Arguments of the function are: (uiHandle, id, newValue). \n \n \n \n \n See also: \n <hslider> \n \n \n ^ \n \n \n Element: \n <svg> \n \n \n Description: \n An SVG widget. Content can be embedded in the XML. \n \n \n Attributes: \n \n \n Name: \n enabled \n \n \n Type: \n bool \n \n \n Default: \n true \n \n \n Description: \n Enable status of widget. \n \n \n \n Name: \n style \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Qt stylesheet. \n \n \n \n Name: \n file \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n File to load. \n \n \n \n Name: \n on-mouse-down \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the mouseDown event. Arguments of the function are: (uiHandle, id, type, flags, x, y). \n \n \n \n Name: \n on-mouse-up \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the mouseUp event. Arguments of the function are: (uiHandle, id, type, flags, x, y). \n \n \n \n Name: \n on-mouse-move \n \n \n Type: \n string \n \n \n Default: \n \n \n \n Description: \n Name of a script function to handle the mouseMove event. Arguments of the function are: (uiHandle, id, type, flags, x, y). \n \n \n \n \n See also: \n <image> \n \n \n ^ \n \n \n Element: \n <stretch> \n \n \n Description: \n Special element that can be put inside a parent with layout (such as <ui>, <group> or <tab>) if the layout is  hbox  or  vbox . \n \n \n Attributes: \n \n \n Name: \n factor \n \n \n Type: \n int \n \n \n Default: \n 0 \n \n \n Description: \n Stretch factor (see  http://doc.qt.io/qt-4.8/layout.htmll#stretch-factors ). \n \n \n \n \n ^ \n \n \n Element: \n <br> \n \n \n Description: \n Special element that can be put inside a parent with layout (such as <ui>, <group> or <tab>) if the layout is  grid , and it is used to begin a new line in the grid layout. \n \n \n Attributes: \n \n \n \n', 'tags': '', 'url': 'simUI-widgets.html'}, {'title': 'QMLPluginAPIreference', 'text': '\n QML Plugin API reference \n API functions for creating QML user interfaces. More info about creating user interfaces in QML can be found at  https://doc.qt.io/ . \n simQML.createEngine \n simQML.destroyEngine \n simQML.imageDataURL \n simQML.load \n simQML.loadData \n simQML.sendEvent \n simQML.sendEventRaw \n simQML.setEventHandler \n simQML.setEventHandlerRaw \n \n \n \n simQML.createEngine\n \n \n \n                                                    Description\n                                                 \n Create a QML engine. \n \n \n Lua synopsis \n string handle=simQML.createEngine() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n handle  (string): qml engine handle \n \n \n Python synopsis \n string handle=simQML.createEngine() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.destroyEngine\n \n \n \n                                                    Description\n                                                 \n Destroy the specified QML engine. \n \n \n Lua synopsis \n simQML.destroyEngine(string handle) \n \n \n \n Lua parameters \n \n handle  (string): qml engine handle \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.destroyEngine(string handle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.imageDataURL\n \n \n \n                                                    Description\n                                                 \n Encode image data according to "data" URL scheme (RFC 2397). \n \n \n Lua synopsis \n string dataURL=simQML.imageDataURL(string \ndata, int width, int height, string format="BMP", int \ndata_format=sim_qml_image_data_format_rgb888) \n \n \n \n Lua parameters \n \n \n data  (string): raw image data \n \n width  (int): image width \n \n height  (int): image height \n \n format  (string, default: "BMP"): encoding format (must be "PNG", "JPG" or "BMP") \n \n data_format  (int, default: sim_qml_image_data_format_rgb888): image data format (see  simQML.image_data_format ) \n \n \n \n Lua return values \n \n dataURL  (string): data URL \n \n \n Python synopsis \n string dataURL=simQML.imageDataURL(string \ndata, int width, int height, string format="BMP", int \ndata_format=sim_qml_image_data_format_rgb888) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.load\n \n \n \n                                                    Description\n                                                 \n Load a QML file in the specified engine. \n \n \n Lua synopsis \n simQML.load(string engineHandle, string filename) \n \n \n \n Lua parameters \n \n \n engineHandle  (string): qml engine handle \n \n filename  (string): qml file path \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.load(string engineHandle, string filename) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.loadData\n \n \n \n                                                    Description\n                                                 \n Load a QML from a string in the specified engine. \n \n \n Lua synopsis \n simQML.loadData(string engineHandle, string data, string basepath="") \n \n \n \n Lua parameters \n \n \n engineHandle  (string): qml engine handle \n \n data  (string): qml data \n \n basepath  (string, default: ""): base path for imports \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.loadData(string engineHandle, string data, string basepath="") \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.sendEvent\n \n \n \n                                                    Description\n                                                 \n send an event with an object payload which will be serialized using JSON \n \n \n Lua synopsis \n simQML.sendEvent(string engine, string name, table data) \n \n \n \n Lua parameters \n \n \n engine  (string): the handle of the QML engine \n \n name  (string): the name of the event \n \n data  (table): the object payload \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.sendEvent(string engine, string name, list data) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.sendEventRaw\n \n \n \n                                                    Description\n                                                 \n Send an event to QML. In order to receive events in QML, a  CoppeliaSimBridge  object must be created, and its  onEventReceived(name, data)  handler must be implemented. Predefined events sent by the plugin:  when the scene is switched, an event with name  "onInstanceSwitch"  and data consisting of a single boolean JSON-serialized value, which will be  true  when the QML component\'s scene becomes active, and  false  when it becomes inactive. \n \n \n Lua synopsis \n simQML.sendEventRaw(string engineHandle, string eventName, string eventData) \n \n \n \n Lua parameters \n \n \n engineHandle  (string): qml engine handle \n \n eventName  (string): event name \n \n eventData  (string): event data \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.sendEventRaw(string engineHandle, string eventName, string eventData) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.setEventHandler\n \n \n \n                                                    Description\n                                                 \n registers the event handler for the engine, which will deserialize JSON payloads \n \n \n Lua synopsis \n simQML.setEventHandler(string engine, string funcName) \n \n \n \n Lua parameters \n \n \n engine  (string): the handle of the QML engine \n \n funcName  (string): the name of the function, called with args (engineHandle,eventName,eventData) \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.setEventHandler(string engine, string funcName) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simQML.setEventHandlerRaw\n \n \n \n                                                    Description\n                                                 \n Set the event handler to receive events from QML. In order to send events in QML, a  CoppeliaSimBridge  object must be created, and its  sendEvent(name, data)  method must be called. For information about receiving events in QML, see  simQML.sendEvent . \n \n \n Lua synopsis \n simQML.setEventHandlerRaw(string engineHandle, string functionName) \n \n \n \n Lua parameters \n \n \n engineHandle  (string): qml engine handle \n \n functionName  (string): function name to be called when event is received: see  onEventReceived \n \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.setEventHandlerRaw(string engineHandle, string functionName) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simQML.image_data_format\n \n gray8 \n rgb888 \n bgr888 \n rgbx8888 \n rgb32 \n argb32 \n \n \n \n \n Script functions \n Script functions are used to call some lua code from the plugin side (tipically used for event handlers). \n \n onEventReceivedRaw\n \n \n \n                                                    Description\n                                                 \n Callback for events sent from QML. The event handler must be registered with  simQML.setEventHandlerRaw . \n \n \n Lua synopsis \n simQML.onEventReceivedRaw(string engineHandle, string eventName, string eventData) \n \n \n \n Lua parameters \n \n \n engineHandle  (string): qml engine handle \n \n eventName  (string): event name \n \n eventData  (string): event data \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simQML.onEventReceivedRaw(string engineHandle, string eventName, string eventData) \n \n \n \n \n                                                    See also\n                                                 \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'QMLPluginAPIreference.html'}, {'title': 'importExport', 'text': "\n \n \n \n \n Import/export \n Several type of data and formats can be imported to, or exported from CoppeliaSim: \n mesh data, via various formats \n scene/model data, via CoppeliaSim's XML format \n scene/model data, via the URDF format \n scene/model data, via the SDF format \n animation or scene data, via the GLTF format \n video data, via various formats \n image data, via various formats \n text/binary data \n miscellaneous data \n New importers/exports can easily be created via an  add-on , or via a  plugin . \n \n \n \n Importing/exporting mesh data\n \n The mesh import/export functionality is handled via the  Assimp plugin for CoppeliaSim . More formats can be supported if the Assimp library (and Assimp plugin) are recompiled with the required flags. The plugin's functionality is exposed to CoppeliaSim's GUI and can be reached at [Menu bar --> File --> Import --> Meshes...] or [Menu bar --> File --> Export --> Selected shapes...]. \n If after the import operation you can't see any shapes in the  scene , but the  scene hierarchy  indicates the presence of newly added shapes, then most probably your shapes are either too big or too small to be seen. You can then proceed to a scaling operation. Additionally, you can subdivide imported meshes via [Menu Bar --> Edit --> Grouping/Merging --> Divide selected shapes].  \n Make sure that imported meshes do not contain too many triangles (for a robot, typically between 10'000-20'000 triangles in total), otherwise CoppeliaSim could be slowed down. You can decimate an imported mesh via [Menu bar --> Edit --> Decimate selected shape...] \n Heightfields in CoppeliaSim are also meshes, and can be imported via [Menu bar --> File --> Import --> Heightfield...]. Supported formats are image formats (the color or grey tone components represent elevations), or csv or txt formats (comma-separated values (y rows with x values)). \n See also the  API functions related to mesh import/export . \n \n \n Exporting a simulation as GLTF\n \n A scene or simulation can be exported via the GLTF format. The result will be a still scene or an animated scene. The functionality is available via two distinct  add-ons :  GLTFExporter  and  GLTFAnimationExporter , available via [Menu bar --> Add-ons]. \n See also the  API functions related to GLTF export . \n \n \n Importing/exporting images\n \n Images can be imported/exported with  sim.loadImage  and  sim.saveImage .  \n See also  sim.getScaledImage ,  sim.transformImage ,  sim.transformBuffer  and the  OpenCV plugin API reference . \n \n \n Importing/exporting text/binary data\n \n Following example illustrates how to log a joint angle to a file, as text data: \n \nfunction sysCall_init()\n    jointHandle=sim.getObject('/Joint')\n    file=io.open('jointAngles.txt','w+')\n    file:write('Joint angles for each simulation step:\\n\\n')\nend\n\nfunction sysCall_sensing()\n    local v=180*sim.getJointPosition(jointHandle)/math.pi\n    file:write(string.format('time: %.3f [s]',sim.getSimulationTime()+sim.getSimulationTimeStep()))\n    file:write(string.format(', joint angle: %.1f [deg]\\n',v))\nend\n\nfunction sysCall_cleanup()\n    file:close()\nend \n Following example illustrates how to read a file, line by line: \n \nfor line in io.lines('textFile.txt') do \n    print(line)\nend \n \n \n \n Importing miscellaneous data\n \n The  Floor Plan Importer  add-on can create shapes from a floor plan image, by mapping each pixel value to either a  wall , a  door  or a  window . \n A floor-plan image looks like this: \n \n [Example of a floor-plan image] \n \n Note that above image is zoomed in, and actual lines are 1px thick. \n Different gray levels are used to indicate different classes. In this example, 0 is used for walls, 82 for window holes, and 187 for door holes. These values can be configured (see below) and anything outside the given ranges will be ignored, so it is possible to use a floor plan that contains more annotations, but only extract wall/door/window lines if given in a specific gray value. \n Various other formats derived from or related to images can also be imported. For a complete list of supported formats, use  simUI.supportedImageFormats . Following example illustrates the PGM format: \n P2\n18 6\n3\n0 0 0 0 0 0 0 0 0 0 0 0 2 2 2 2 0 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0\n0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 0\n0 0 1 1 1 1 0 0 0 0 0 0 2 2 2 2 0 0 \n The add-on is available via [Menu bar --> Modules]. After selecting the menu entry, an image file must be selected, then a few import options can be specified: \n \n pixel size : the scaling of the image. One pixel in the image will correspond to this length in the real world. \n For every class (walls, windows, doors):\n         \n height : the height of the wall/hole in the real world. \n range : the range of the intensity (grayscale value) in the image. \n \n \n color : the color of the walls shape. \n respondable : wether the walls shape will be respondable. \n optimize : if checked, the lines will be dissected to a minimal number of rectangles, so the shape will contain a low count of pure (cuboid) shapes. \n invert image values : if checked, the image values will be inverted before processing. \n \n \n \n \n \n", 'tags': '', 'url': 'importExport.html'}, {'title': 'xmlFormat', 'text': "\n \n \n \n \n XML formats \n CoppeliaSim supports two different XML formats, where each follow a different goal: \n an  exhaustive format : the exhaustive format is a  lossless format, which means that all scene or model information will be same between a save and load operation. The drawback is however that the file should not be manually modified, since the risk of corrupting it is high. This format is ideal for version control for example. \n a  simple format : the simple format is a  lossy format, which means that not all information contained in a scene or model will be saved, only a subset of it. The advantage is however that it can be manually created and/or modified. This format is ideal for creating initial models, or for creating CoppeliaSim exporters in different applications. \n Both formats have two variables (defined in file  system/usrset.txt ) allowing to control the output XML file: \n xmlExportSplitSize : represents the subset data size threshold where data will be referenced and written to a separate file. Set to 0 if you wish to create a single file. \n xmlExportKnownFormats : if  true , and the export generates several files, then the  png  format for images, and the  dae  format for meshs are used. The  dae  format is however only supported with the simple xml format. \n The exhaustive format will not be discussed further here. Refer to the generated files for additional information. \n \n Simple XML format\n \n The simple format, however its name, can contain quite complex information. Each piece of information is wrapped as  element  inside of a start- and end- tag . Most tags are optional (if not specified, then default values will be used). The simplest to get a good understanding of such a file's organization and which tags are not optional is to first export a scene, then examine/modify the generated file. \n Following gives a brief overview, based on simple examples. First, a scene containing a camera attached to a dummy. Required items are indicated in red: \n <CoppeliaSim> \n   <filetype>simpleScene</filetype>   (Should be simpleScene or simpleModel) \n   <xmlSerializationNb>1</xmlSerializationNb> \n  <environment>  (ignored when loading a model) \n    ...  (refer to generated files for details) \n  </environment>   <settings>  (ignored when loading a model)     ...  (refer to generated files for details) \n  </settings>   <dynamics>  (ignored when loading a model)     ...  (refer to generated files for details) \n  </dynamics>   <simulation>  (ignored when loading a model)     ...  (refer to generated files for details) \n  </simulation>\n  <dummy>     ...  (refer to generated files for details) \n    <camera>       ...  (refer to generated files for details) \n    </camera>   </dummy> </CoppeliaSim> \n \n It is a good idea to specify a few more tags for a scene object, such as the object alias, its position/orientation relative to its parent object, and the script(s) it is associated with: \n \n... <camera>   <common>     <alias>DefaultCamera</alias>     <localFrame>       <position>1.120530 -1.899800 1.079718</position>       <euler>-110.932999 -28.703005 169.590027</euler>     </localFrame>     ...  (refer to generated files for details) \n  </common>\n  <childScript>     ...  (refer to generated files for details)     <scriptText><![CDATA[       function sysCall_init()         print('From child script: Hello world!')       end     ]]></scriptText>   </childScript>   <customizationScript>     ...  (refer to generated files for details)     <scriptText><![CDATA[       function sysCall_init()         print('From customization script: Hello world!')       end     ]]></scriptText>   </customizationScript>   ...  (refer to generated files for details) \n</camera> ... \n Shapes require a bit more explanations. Here a  pure cuboid , i.e. a primitive shape: \n \n<shape>   <common>     ...  (refer to generated files for details) \n  </common>    <primitive>   (should be compound, primitive, heightfield or mesh)      <type>cuboid</type>   (should be cuboid, sphere, cylinder, cone, plane or disc)     <size>0.100000 0.100000 0.100000</size>\n    <localFrame>  (this is in addition to the local frame you may specify in <common>)       <position>0.000000 0.000000 0.000000</position>       <euler>-0.000000 0.000000 -0.000000</euler>     </localFrame>\n    ...  (refer to generated files for details) \n   </primitive>   <dynamics>     ...  (see further below for details) \n  </dynamics> </shape> \n Here a  mesh , referencing an external file: \n \n<shape>   <common>     ...  (refer to generated files for details) \n  </common>    <mesh>   (should be compound, primitive, heightfield or mesh)      <fileName>test.simscene_mesh_Cuboid0.dae</fileName>   (or vertices and indices) \n    <localFrame>  (this is in addition to the local frame you may specify in <common>)       <position>0.000000 0.000000 0.000000</position>       <euler>-0.000000 0.000000 -0.000000</euler>     </localFrame>\n    ...  (refer to generated files for details) \n   </mesh>   <dynamics>     ...  (see further below for details) \n  </dynamics> </shape> \n Here a  mesh , with inlined mesh data: \n \n<shape>   <common>     ...  (refer to generated files for details) \n  </common>    <mesh>   (should be compound, primitive, heightfield or mesh) \n     <vertices>0.05 -0.05 -0.05 -0.05 -0.05 -0.05 0.05 0.05 -0.05 -0.05 ...</vertices> \n     <indices>0 1 2 2 1 3 1 0 4 1 4 5 2 3 6 6 3 7 6 7 4 4 7 5 3 1 7 7 1 5 0 2 6 0 6 4</indices> \n    <localFrame>  (this is in addition to the local frame you may specify in <common>)       <position>0.000000 0.000000 0.000000</position>       <euler>-0.000000 0.000000 -0.000000</euler>     </localFrame>\n    ...  (refer to generated files for details) \n   </mesh>   <dynamics>     ...  (see further below for details) \n  </dynamics> </shape> \n Here a  heightfield : \n \n<shape>   <common>     ...  (refer to generated files for details) \n  </common>    <heightfield>   (should be compound, primitive, heightfield or mesh) \n     <size>4 3</size> \n     <data>0.2 0.2 0.2 0.2 0.1 0.0 0.0 0.1 0.1 0.1 0.0 0.2</data> \n    <gridStep>3.333333</gridStep>\n    <localFrame>  (this is in addition to the local frame you may specify in <common>)       <position>0.000000 0.000000 0.000000</position>       <euler>-0.000000 0.000000 -0.000000</euler>     </localFrame>\n    ...  (refer to generated files for details) \n   </heightfield>   <dynamics>     ...  (see further below for details) \n  </dynamics> </shape> \n And here a  compound : \n \n<shape>   <common>     ...  (refer to generated files for details) \n  </common>    <compound>   (should contain at least 2 of any of compound, primitive or mesh) \n     <primitive>       ...      </primitive>      <primitive>       ...      </primitive>      <compound>       ...      </compound>     ...    </compound>   <dynamics>     ...  (see further below for details) \n  </dynamics> </shape> \n If a shape has dynamic properties, you should also fill-in the dynamics tags, as in following example: \n \n<shape>   ...   <dynamics>     <respondableMask>65535</respondableMask>     <mass>1.0</mass>     <localInertiaFrame>       <position>0.0 0.0 0.0</position>       <euler>0.0 0.0 0.0</euler>     </localInertiaFrame>     <principalMomentOfInertia>0.001667 0.001667 0.001667</principalMomentOfInertia>     <switches>       <static>false</static>       <respondable>true</respondable>       ...  (refer to generated files for details)     </switches>     <material>       <engines>         <bullet>           <friction>0.5</friction>           <oldfriction>1.0</oldfriction>           ...  (refer to generated files for details)         </bullet>         <ode>           <friction>1.0</friction>             ...  (refer to generated files for details)         </ode>         <vortex>           <primlinearaxisfriction>1.0</primlinearaxisfriction>           <seclinearaxisfriction>1.0</seclinearaxisfriction>           ...  (refer to generated files for details)         </vortex>         <newton>           <staticfriction>1.0</staticfriction>           <kineticfriction>1.0</kineticfriction>           ...  (refer to generated files for details)         </newton>       </engines>     </material>   </dynamics> </shape> \n Here a revolute joint, in kinematic mode: \n <joint>   <common>     ...  (refer to generated files for details)   </common>   <type>revolute</type>  (can be revolute, prismatic or spherical)   <mode>kinematic</mode>  (can be kinematic, dependent or dynamic)   <minPosition>-180.0</minPosition>   <range>360.0</range>   <position>0.0</position>   <switches>     <cyclic>true</cyclic>   </switches>   ...  (refer to generated files for details) </joint> \n Here a revolute joint, in dynamic mode, motor disabled: \n <joint>   <common>     ...  (refer to generated files for details)   </common>   <type>revolute</type>  (can be revolute, prismatic or spherical)   <mode>dynamic</mode>  (can be kinematic, dependent or dynamic)   <minPosition>-180.0</minPosition>   <range>360.0</range>   <position>0.0</position>   <switches>     <cyclic>true</cyclic>   </switches>\n  <dynamics>     <maxForce>2.5</maxForce>     ...  (refer to generated files for details)     <switches>       <motorEnabled>false</motorEnabled>       ...  (refer to generated files for details)     </switches>     <engines>       ...  (refer to generated files for details)     </engines>   </dynamics> </joint> \n Here a revolute joint, in dynamic mode, position controlled: \n <joint>   <common>     ...  (refer to generated files for details)   </common>   <type>revolute</type>  (can be revolute, prismatic or spherical)   <mode>dynamic</mode>  (can be kinematic, dependent or dynamic)   <minPosition>-180.0</minPosition>   <range>360.0</range>   <position>0.0</position>   <switches>     <cyclic>true</cyclic>   </switches>\n  <dynamics>     <maxForce>2.5</maxForce>     <upperVelocityLimit>180</upperVelocityLimit>     <targetPosition>0.0</targetPosition>     <pidValues>0.1 0.0 0.0</pidValues>     ...  (refer to generated files for details)     <switches>       <motorEnabled>false</motorEnabled>       <controlLoopEnabled>true</controlLoopEnabled>       ...  (refer to generated files for details)     </switches>     <engines>       ...  (refer to generated files for details)     </engines>   </dynamics> </joint> \n Other scene objects are not discussed here. For details, export a scene containing such object, then examine the generated file. \n Here a simplified version of  BubbleRob , from  this tutorial : \n \n<CoppeliaSim>     <filetype>simpleScene</filetype>   <xmlSerializationNb>1</xmlSerializationNb>   <shape>     <common>       <alias>walls</alias>       <localFrame>         <position>0 0 0.1</position>         <euler>0 -90 0</euler>       </localFrame>       <localObjectProperty>         <selectable>false</selectable>       </localObjectProperty>       <localObjectSpecialProperty>         <collidable>true</collidable>         <measurable>true</measurable>         <detectable>true</detectable>       </localObjectSpecialProperty>     </common>     <compound>       <primitive>         <type>cuboid</type>         <size>5 0.02 0.2</size>         <localFrame>           <position>0 2.5 0</position>           <euler>0 90 0</euler>         </localFrame>       </primitive>       <primitive>         <type>cuboid</type>         <size>5 0.02 0.2</size>         <localFrame>           <position>0 0 -2.5</position>           <euler>0 90 90</euler>         </localFrame>       </primitive>       <primitive>         <type>cuboid</type>         <size>5 0.02 0.2</size>         <localFrame>           <position>0 0 2.5</position>           <euler>0 90 90</euler>         </localFrame>       </primitive>       <primitive>         <type>cuboid</type>         <size>5 0.02 0.2</size>         <localFrame>           <position>0 -2.5 0</position>           <euler>0 90 0</euler>         </localFrame>       </primitive>     </compound>     <dynamics>       <switches>         <static>true</static>         <respondable>true</respondable>       </switches>     </dynamics>   </shape>   <shape>     <common>       <alias>obstacle</alias>       <localFrame>         <position>1 0 0.1</position>       </localFrame>       <localObjectSpecialProperty>         <collidable>true</collidable>         <measurable>true</measurable>         <detectable>true</detectable>       </localObjectSpecialProperty>     </common>     <primitive>       <type>cuboid</type>       <size>0.2 0.2 0.2</size>     </primitive>     <dynamics>       <switches>         <static>true</static>         <respondable>true</respondable>       </switches>     </dynamics>   </shape>   <light>     <common>       <alias>light</alias>       <localFrame>         <position>0 0 2</position>         <euler>100 -50 0</euler>       </localFrame>     </common>     <type>directional</type>     <color>       <light>         <ambientDiffuse>127 127 127</ambientDiffuse>       </light>     </color>   </light>   <shape>     <common>       <alias>bubbleRob</alias>       <localFrame>         <position>0 0 0.12</position>       </localFrame>       <localObjectSpecialProperty>         <collidable>true</collidable>         <measurable>true</measurable>         <detectable>true</detectable>       </localObjectSpecialProperty>       <switches>         <modelBase>true</modelBase>       </switches>     </common>     <primitive>       <type>sphere</type>       <size>0.2 0.2 0.2</size>       <color>         <ambientDiffuse>255 167 36</ambientDiffuse>       </color>     </primitive>     <dynamics>       <respondableMask>65295</respondableMask>       <mass>4</mass>       <principalMomentOfInertia>0.004 0.004 0.004</principalMomentOfInertia>       <switches>         <static>false</static>         <respondable>true</respondable>       </switches>     </dynamics>     <childScript>       <scriptText><![CDATA[\nfunction sysCall_init()   leftMotor=sim.getObject('./bubbleRobLeftMotor')   rightMotor=sim.getObject('./bubbleRobRightMotor')   noseSensor=sim.getObject('./bubbleRobSensingNose')   driveBackTime=0 end function sysCall_actuation()   if driveBackTime&gt;0 then     driveBackTime=driveBackTime-sim.getSimulationTimeStep()   end   local result=sim.readProximitySensor(noseSensor)   if result&gt;0 then     driveBackTime=3     sim.setJointTargetVelocity(leftMotor,-math.pi*0.5)     sim.setJointTargetVelocity(rightMotor,-math.pi*0.25)   end   if driveBackTime&lt;=0 then     sim.setJointTargetVelocity(leftMotor,math.pi)     sim.setJointTargetVelocity(rightMotor,math.pi)   end end\n  ]]></scriptText>     </childScript>     <proximitySensor>       <common>         <alias>bubbleRobSensingNose</alias>         <localFrame>           <position>0.1 0 0</position>           <euler>0 90 90</euler>         </localFrame>         <localObjectProperty>           <selectModelBaseInstead>true</selectModelBaseInstead>         </localObjectProperty>       </common>       <type>cone</type>       <size>0.01</size>       <volume>         <range>0.15</range>         <smallestAllowedDistance>0.01</smallestAllowedDistance>         <angle>60</angle>       </volume>     </proximitySensor>     <joint>       <common>         <alias>bubbleRobLeftMotor</alias>         <localFrame>           <position>0.05 0.1 -0.08</position>           <euler>-90 0 0</euler>         </localFrame>         <localObjectProperty>           <selectModelBaseInstead>true</selectModelBaseInstead>         </localObjectProperty>       </common>       <type>revolute</type>       <mode>force</mode>       <switches>         <cyclic>true</cyclic>       </switches>       <sizes>         <length>0.15</length>         <diameter>0.02</diameter>       </sizes>       <dynamics>         <maxForce>2.5</maxForce>         <upperVelocityLimit>360</upperVelocityLimit>         <switches>           <motorEnabled>true</motorEnabled>         </switches>       </dynamics>       <shape>         <common>           <alias>bubbleRobLeftWheel</alias>           <localObjectProperty>             <selectModelBaseInstead>true</selectModelBaseInstead>           </localObjectProperty>           <localObjectSpecialProperty>             <collidable>true</collidable>             <measurable>true</measurable>             <detectable>true</detectable>           </localObjectSpecialProperty>         </common>         <primitive>           <type>cylinder</type>           <size>0.08 0.08 0.02</size>           <color>             <ambientDiffuse>64 64 64</ambientDiffuse>           </color>         </primitive>         <dynamics>           <mass>0.8</mass>           <principalMomentOfInertia>0.0004 0.0004 0.0008</principalMomentOfInertia>           <switches>             <static>false</static>             <respondable>true</respondable>           </switches>         </dynamics>       </shape>     </joint>     <joint>       <common>         <alias>bubbleRobRightMotor</alias>         <localFrame>           <position>0.05 -0.1 -0.08</position>           <euler>-90 0 0</euler>         </localFrame>         <localObjectProperty>           <selectModelBaseInstead>true</selectModelBaseInstead>         </localObjectProperty>       </common>       <type>revolute</type>       <mode>force</mode>       <switches>         <cyclic>true</cyclic>       </switches>       <sizes>         <length>0.15</length>         <diameter>0.02</diameter>       </sizes>       <dynamics>         <maxForce>2.5</maxForce>         <upperVelocityLimit>360</upperVelocityLimit>         <switches>           <motorEnabled>true</motorEnabled>         </switches>       </dynamics>       <shape>         <common>           <alias>bubbleRobRightWheel</alias>           <localObjectProperty>             <selectModelBaseInstead>true</selectModelBaseInstead>           </localObjectProperty>           <localObjectSpecialProperty>             <collidable>true</collidable>             <measurable>true</measurable>             <detectable>true</detectable>           </localObjectSpecialProperty>         </common>         <primitive>           <type>cylinder</type>           <size>0.08 0.08 0.02</size>           <color>             <ambientDiffuse>64 64 64</ambientDiffuse>           </color>         </primitive>         <dynamics>           <mass>0.8</mass>           <principalMomentOfInertia>0.0004 0.0004 0.0008</principalMomentOfInertia>           <switches>             <static>false</static>             <respondable>true</respondable>           </switches>         </dynamics>       </shape>     </joint>     <forceSensor>       <common>         <alias>bubbleRobLink</alias>         <localFrame>           <position>-0.07 0 -0.07</position>         </localFrame>         <localObjectProperty>           <selectModelBaseInstead>true</selectModelBaseInstead>         </localObjectProperty>       </common>       <size>0.05</size>       <shape>         <common>           <alias>bubbleRobCaster</alias>           <localFrame>             <position>0 0 -0.025</position>           </localFrame>           <localObjectProperty>             <selectModelBaseInstead>true</selectModelBaseInstead>           </localObjectProperty>           <localObjectSpecialProperty>             <collidable>true</collidable>             <measurable>true</measurable>             <detectable>true</detectable>           </localObjectSpecialProperty>         </common>         <primitive>           <type>sphere</type>           <size>0.05 0.05 0.05</size>           <color>             <ambientDiffuse>55 55 55</ambientDiffuse>           </color>         </primitive>         <dynamics>           <respondableMask>65520</respondableMask>           <mass>0.5</mass>           <principalMomentOfInertia>0.00025 0.00025 0.00025</principalMomentOfInertia>           <switches>             <static>false</static>             <respondable>true</respondable>           </switches>           <material>             <engines>               <bullet>                 <friction>0</friction>               </bullet>               <ode>                 <friction>0</friction>               </ode>               <vortex>                 <primlinearaxisfriction>0</primlinearaxisfriction>                 <seclinearaxisfriction>0</seclinearaxisfriction>               </vortex>               <newton>                 <staticfriction>0</staticfriction>                 <kineticfriction>0</kineticfriction>               </newton>             </engines>           </material>         </dynamics>       </shape>     </forceSensor>   </shape>   <camera>     <common>       <alias>camera</alias>       <localFrame>         <position>0.952512 1.344827 0.718737</position>         <euler>114.251228 -20.888456 9.124518</euler>       </localFrame>     </common>     <mainCamera>true</mainCamera>   </camera>   <shape>     <common>       <alias>floor</alias>       <localFrame>         <position>0 0 -0.02</position>       </localFrame>       <localObjectProperty>         <selectable>false</selectable>       </localObjectProperty>       <localObjectSpecialProperty>         <collidable>true</collidable>         <measurable>true</measurable>         <detectable>true</detectable>       </localObjectSpecialProperty>     </common>     <primitive>       <type>cuboid</type>       <size>5 5 0.04</size>       <color>         <ambientDiffuse>209 209 209</ambientDiffuse>       </color>     </primitive>     <dynamics>       <switches>         <static>true</static>         <respondable>true</respondable>       </switches>     </dynamics>   </shape> </CoppeliaSim>\n \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'xmlFormat.html'}, {'title': 'urdfPlugin', 'text': '\n \n \n \n \n URDF importer plugin \n The URDF  file format (*.urdf) is supported for import operations via a plugin ( simExtURDF ) coutesy of Ignacio Tartavull. Next to  API functions related to the URDF format , the plugin also offers a GUI dialog accessible via [Menu bar --> Add-ons --> URDF importer]: \n \n [URDF plugin dialog] \n \n Assign collision links to layer 9 : hides collision links in layer 9 (layer 9 is off by default).\n \n Assign joints to layer 10 : hides joints in layer 10 (layer 10 is off by default).\n \n Convex decompose non-convex collision links : decomposes non-convex respondable shapes into convex shapes. This item should always be checked, since convex shapes perform faster and are more stable during dynamic collision response calculations.\n \n Show convex decomposition dialog : allows to adjust the way how the convex decomposition operates.\n \n Create visual links if none : creates an artificial visual element if the link doesn\'t define one.\n \n Center model above ground : centers the imported model above the ground.\n \n Prepare model definition if feasable : tags the root object as "model base" and adapts the other objects accordingly (e.g. clicking an object in the model will select the whole model instead of an individual object).\n \n Alternate local respondable masks : when checked, alternates the local collision masks so that adjacent respondable shapes won\'t react to collision. If unckecked, then all respondable shapes will only react to collision with objects outside of the model.\n \n Enable position control for revolute and prismatic joints : if checked, then revolute and prismatic joints will be in position control mode. Joint force/torque and upper regulation velocity are taken from the URDF file. \n Import : triggers an import operation.\n \n \n \n \n \n', 'tags': '', 'url': 'urdfPlugin.html'}, {'title': 'APIFunctions', 'text': '\n \n \n \n \n Regular API reference \n The list of API functions below allows you to access many CoppeliaSim parameters . There are however too many parameters in CoppeliaSim to have a specific API function for each one of them.  Auxiliary  parameters can be accessed via a set of given functions that use  object parameter IDs . Refer also to  the  global parameter IDs . \nAll units going to, or coming from the API are in meters, kilograms, seconds and  radians  or a combination of those (unless otherwise explicitly indicated).\n \n File operations \n \n sim.closeScene \n sim.saveScene \n sim.loadScene \n sim.saveModel \n sim.loadModel \n sim.importShape \n sim.importMesh \n sim.exportMesh \n sim.launchExecutable \n sim.createTexture \n \n \n \n simCloseScene \n simSaveScene \n simLoadScene \n simSaveModel \n simLoadModel \n simDoesFileExist \n simImportShape \n simImportMesh \n simExportMesh \n simCreateTexture \n \n \n General object handle retrieval \n \n sim.getObject \n sim.getObjectFromUid \n sim.isHandle \n sim.getObjects \n sim.getObjectsInTree \n sim.getCollectionObjects \n sim.setReferencedHandles \n sim.getReferencedHandles \n \n \n \n simGetObject \n simGetObjectFromUid \n simIsHandle \n simGetObjects \n simGetObjectsInTree \n simGetCollectionObjects \n simSetReferencedHandles \n simGetReferencedHandles \n \n \n General functionality handling \n \n sim.handleChildScripts \n sim.handleCustomizationScripts \n sim.handleAddOnScripts \n sim.handleSandboxScript \n \n \n \n simHandleMainScript \n \n \n Collision detection \n \n sim.checkCollision \n sim.checkCollisionEx \n \n \n \n simCheckCollision \n simCheckCollisionEx \n \n \n Minimum distance calculation \n \n sim.checkDistance \n \n \n \n simCheckDistance \n \n \n Dynamics \n \n sim.handleDynamics \n sim.setJointTargetPosition \n sim.setJointTargetVelocity \n sim.readForceSensor \n sim.getJointForce \n sim.getJointTargetForce \n sim.setJointTargetForce \n sim.addForce \n sim.addForceAndTorque \n sim.getVelocity \n sim.getLinkDummy \n sim.setLinkDummy \n sim.resetDynamicObject \n sim.addParticleObject \n sim.addParticleObjectItem \n sim.removeParticleObject \n sim.getContactInfo \n sim.getShapeMass \n sim.setShapeMass \n sim.getShapeInertia \n sim.setShapeInertia \n sim.computeMassAndInertia \n sim.createForceSensor \n sim.convexDecompose \n sim.getQHull \n sim.getDecimatedMesh \n sim.isDynamicallyEnabled \n sim.setShapeMaterial \n\n See also:\n  physics engine parameter functions .\n \n \n \n simHandleDynamics \n simSetJointTargetPosition \n simSetJointTargetVelocity \n simReadForceSensor \n simGetJointForce \n simGetJointTargetForce \n simSetJointTargetForce \n simAddForce \n simAddForceAndTorque \n simGetVelocity \n simGetLinkDummy \n simSetLinkDummy \n simResetDynamicObject \n simAddParticleObject \n simAddParticleObjectItem \n simRemoveParticleObject \n simGetContactInfo \n simGetShapeMass \n simSetShapeMass \n simGetShapeInertia \n simSetShapeInertia \n simComputeMassAndInertia \n simCreateForceSensor \n simConvexDecompose \n simGetQHull \n simGetDecimatedMesh \n simIsDynamicallyEnabled \n simSetShapeMaterial \n \n \n Proximity sensors \n \n sim.handleProximitySensor \n sim.readProximitySensor \n sim.resetProximitySensor \n sim.checkProximitySensor \n sim.checkProximitySensorEx \n sim.checkProximitySensorEx2 \n sim.createProximitySensor \n\n See also:\n  object parameter functions  and  parameters related to proximity sensors .\n \n \n \n simHandleProximitySensor \n simReadProximitySensor \n simResetProximitySensor \n simCheckProximitySensor \n simCheckProximitySensorEx \n simCheckProximitySensorEx2 \n simCreateProximitySensor \n \n \n Vision sensors \n \n sim.handleVisionSensor \n sim.readVisionSensor \n sim.resetVisionSensor \n sim.checkVisionSensor \n sim.checkVisionSensorEx \n sim.getVisionSensorDepth \n sim.getVisionSensorImg \n sim.setVisionSensorImg \n sim.adjustView \n sim.createVisionSensor \n sim.getExtensionString \n\n See also:\n  object parameter functions  and  parameters related to vision sensors .\n \n \n \n simHandleVisionSensor \n simReadVisionSensor \n simResetVisionSensor \n simCheckVisionSensor \n simCheckVisionSensorEx \n simGetVisionSensorDepth \n simGetVisionSensorImg \n simSetVisionSensorImg \n simAdjustView \n simCreateVisionSensor \n simGetExtensionString \n \n \n Force sensors \n \n sim.readForceSensor \n sim.createForceSensor \n\n See also:\n  object parameter functions  and  parameters related to force sensors .\n \n \n \n simReadForceSensor \n simCreateForceSensor \n \n \n Joints \n \n sim.setJointPosition \n sim.getJointPosition \n sim.setJointTargetPosition \n sim.getJointTargetPosition \n sim.setJointTargetVelocity \n sim.getJointTargetVelocity \n sim.getJointVelocity \n sim.getObjectChildPose \n sim.setObjectChildPose \n sim.setJointInterval \n sim.getJointInterval \n sim.getJointType \n sim.createJoint \n sim.setJointMode \n sim.getJointMode \n sim.setJointDependency \n sim.getJointDependency \n sim.getJointForce \n sim.getJointTargetForce \n sim.setJointTargetForce \n\n See also:\n  object parameter functions  and  parameters related to joints .\n  physics engine parameter functions .\n \n \n \n simSetJointPosition \n simGetJointPosition \n simSetJointTargetPosition \n simGetJointTargetPosition \n simSetJointTargetVelocity \n simGetJointTargetVelocity \n simGetJointVelocity \n simGetObjectChildPose \n simSetObjectChildPose \n simSetJointInterval \n simGetJointInterval \n simGetJointType \n simCreateJoint \n simSetJointMode \n simGetJointMode \n simSetJointDependency \n simGetJointDependency \n simGetJointForce \n simGetJointTargetForce \n simSetJointTargetForce \n \n \n Shapes \n \n sim.addForce \n sim.addForceAndTorque \n sim.getVelocity \n sim.getShapeColor \n sim.setShapeColor \n sim.getShapeTextureId \n sim.setShapeTexture \n sim.createMeshShape \n sim.createPrimitiveShape \n sim.createHeightfieldShape \n sim.getShapeMesh \n sim.getShapeViz \n sim.getShapeGeomInfo \n sim.getShapeMass \n sim.setShapeMass \n sim.getShapeInertia \n sim.setShapeInertia \n sim.computeMassAndInertia \n sim.groupShapes \n sim.ungroupShape \n sim.importShape \n sim.convexDecompose \n sim.getQHull \n sim.getDecimatedMesh \n sim.reorientShapeBoundingBox \n sim.setShapeMaterial \n sim.getShapeBB \n sim.setShapeBB \n sim.getExtensionString \n sim.generateTextShape \n\n See also:\n  object parameter functions  and  parameters related to shapes .\n  physics engine parameter functions .\n \n \n \n simAddForce \n simAddForceAndTorque \n simGetVelocity \n simGetShapeColor \n simSetShapeColor \n simGetShapeTextureId \n simSetShapeTexture \n simCreateMeshShape \n simCreatePrimitiveShape \n simCreateHeightfieldShape \n simGetShapeMesh \n simGetShapeViz \n simApplyTexture \n simGetShapeGeomInfo \n simGetShapeMass \n simSetShapeMass \n simGetShapeInertia \n simSetShapeInertia \n simComputeMassAndInertia \n simGroupShapes \n simUngroupShape \n simImportShape \n simConvexDecompose \n simGetQHull \n simGetDecimatedMesh \n simReorientShapeBoundingBox \n simSetShapeMaterial \n simGetExtensionString \n \n \n Graphs \n \n sim.addGraphStream \n sim.setGraphStreamTransformation \n sim.setGraphStreamValue \n sim.addGraphCurve \n sim.destroyGraphCurve \n sim.duplicateGraphCurveToStatic \n sim.handleGraph \n sim.resetGraph \n\n See also:\n  object parameter functions  and  parameters related to graphs .\n \n \n \n simAddGraphStream \n simSetGraphStreamTransformation \n simSetGraphStreamValue \n simAddGraphCurve \n simDestroyGraphCurve \n simDuplicateGraphCurveToStatic \n simHandleGraph \n simResetGraph \n \n \n Lights \n \n sim.getLightParameters \n sim.setLightParameters \n sim.getExtensionString \n\n See also:\n  object parameter functions  and  parameters related to lights .\n \n \n \n simGetLightParameters \n simSetLightParameters \n simGetExtensionString \n \n \n Cameras \n \n sim.cameraFitToView \n sim.adjustView \n sim.getExtensionString \n\n See also:\n  object parameter functions  and  parameters related to cameras .\n \n \n \n simCameraFitToView \n simAdjustView \n simGetExtensionString \n \n \n Dummies \n \n sim.createDummy \n sim.getLinkDummy \n sim.setLinkDummy \n\n See also:\n  object parameter functions  and  parameters related to dummies .\n \n \n \n simCreateDummy \n simGetLinkDummy \n simSetLinkDummy \n \n \n OC trees \n \n sim.createOctree \n sim.insertVoxelsIntoOctree \n sim.removeVoxelsFromOctree \n sim.insertObjectIntoOctree \n sim.subtractObjectFromOctree \n sim.getOctreeVoxels \n sim.checkOctreePointOccupancy \n\n See also:\n  object parameter functions  and  parameters related to OC trees .\n \n \n \n simCreateOctree \n simInsertVoxelsIntoOctree \n simRemoveVoxelsFromOctree \n simInsertObjectIntoOctree \n simSubtractObjectFromOctree \n simGetOctreeVoxels \n simCheckOctreePointOccupancy \n \n \n Point clouds \n \n sim.createPointCloud \n sim.getPointCloudOptions \n sim.setPointCloudOptions \n sim.insertPointsIntoPointCloud \n sim.removePointsFromPointCloud \n sim.subtractObjectFromPointCloud \n sim.intersectPointsWithPointCloud \n sim.insertObjectIntoPointCloud \n sim.getPointCloudPoints \n\n See also:\n  object parameter functions  and  parameters related to point clouds .\n \n \n \n simCreatePointCloud \n simGetPointCloudOptions \n simSetPointCloudOptions \n simInsertPointsIntoPointCloud \n simRemovePointsFromPointCloud \n simSubtractObjectFromPointCloud \n simIntersectPointsWithPointCloud \n simInsertObjectIntoPointCloud \n simGetPointCloudPoints \n \n \n Paths \n \n sim.createPath \n sim.getConfigDistance \n sim.getPathLengths \n sim.getPathInterpolatedConfig \n sim.resamplePath \n sim.generateTimeOptimalTrajectory \n sim.generateShapeFromPath \n sim.getClosestPosOnPath \n \n \n simGenerateShapeFromPath \n simGetClosestPosOnPath \n \n \n Scene objects \n \n sim.getObject \n sim.getObjectUid \n sim.isHandle \n sim.removeObject \n sim.removeModel \n sim.getObjectAlias \n sim.setObjectAlias \n sim.getObjects \n sim.getObjectsInTree \n sim.getObjectParent \n sim.setObjectParent \n sim.getObjectChild \n sim.getObjectMatrix \n sim.setObjectMatrix \n sim.getObjectPose \n sim.setObjectPose \n sim.getObjectPosition \n sim.setObjectPosition \n sim.getObjectOrientation \n sim.setObjectOrientation \n sim.getObjectQuaternion \n sim.setObjectQuaternion \n sim.getObjectType \n sim.getObjectSelection \n sim.setObjectSelection \n sim.getObjectSizeFactor \n sim.copyPasteObjects \n sim.scaleObject \n sim.scaleObjects \n sim.getObjectProperty \n sim.setObjectProperty \n sim.getObjectSpecialProperty \n sim.setObjectSpecialProperty \n sim.getObjectVelocity \n sim.readCustomTableData \n sim.writeCustomTableData \n sim.readCustomDataBlock \n sim.readCustomDataBlockTags \n sim.writeCustomDataBlock \n sim.setReferencedHandles \n sim.getReferencedHandles \n sim.isDynamicallyEnabled \n sim.getObjectColor \n sim.setObjectColor \n\n See also:\n  object parameter functions  and  parameters related to scene objects .\n \n \n \n simGetObject \n simGetObjectUid \n simIsHandle \n simRemoveObject \n simRemoveModel \n simGetObjectAlias \n simSetObjectAlias \n simGetObjects \n simGetObjectsInTree \n simGetObjectParent \n simSetObjectParent \n simGetObjectChild \n simGetObjectMatrix \n simSetObjectMatrix \n simGetObjectPose \n simSetObjectPose \n simGetObjectPosition \n simSetObjectPosition \n simGetObjectOrientation \n simSetObjectOrientation \n simGetObjectQuaternion \n simSetObjectQuaternion \n simGetObjectType \n simGetObjectSel \n simSetObjectSel \n simGetObjectSizeFactor \n simCopyPasteObjects \n simScaleObject \n simScaleObjects \n simGetObjectProperty \n simSetObjectProperty \n simGetObjectSpecialProperty \n simSetObjectSpecialProperty \n simGetObjectVelocity \n simReadCustomDataBlock \n simReadCustomDataBlockTags \n simWriteCustomDataBlock \n simSetReferencedHandles \n simGetReferencedHandles \n simIsDynamicallyEnabled \n simGetObjectColor \n simSetObjectColor \n \n \n Object size / scaling \n \n sim.getObjectSizeFactor \n sim.scaleObject \n sim.scaleObjects \n sim.getShapeBB \n sim.setShapeBB \n \n \n \n simGetObjectSizeFactor \n simScaleObject \n simScaleObjects \n \n \n Collections \n \n sim.createCollection \n sim.destroyCollection \n sim.addItemToCollection \n sim.getCollectionObjects \n \n \n \n simCreateCollectionEx \n simDestroyCollection \n simAddItemToCollection \n simGetCollectionObjects \n \n \n Serial port \n \n sim.serialCheck \n sim.serialClose \n sim.serialOpen \n sim.serialRead \n sim.serialSend \n \n \n \n simSerialCheck \n simSerialClose \n simSerialOpen \n simSerialRead \n simSerialSend \n \n \n Rendering \n \n sim.addDrawingObject \n sim.addDrawingObjectItem \n sim.removeDrawingObject \n sim.getShapeColor \n sim.setShapeColor \n sim.getObjectColor \n sim.setObjectColor \n sim.changeEntityColor \n sim.restoreEntityColor \n sim.getGenesisEvents \n \n \n \n simAddDrawingObject \n simAddDrawingObjectItem \n simRemoveDrawingObject \n simGetShapeColor \n simSetShapeColor \n simGetObjectColor \n simSetObjectColor \n \n \n Particle objects \n \n sim.addParticleObject \n sim.addParticleObjectItem \n sim.removeParticleObject \n \n \n \n simAddParticleObject \n simAddParticleObjectItem \n simRemoveParticleObject \n \n \n Models \n \n sim.getModelProperty \n sim.setModelProperty \n sim.saveModel \n sim.loadModel \n \n \n \n simGetModelProperty \n simSetModelProperty \n simSaveModel \n simLoadModel \n \n \n Object selection \n \n sim.getObjectSelection \n sim.setObjectSelection \n \n \n \n simGetObjectSel \n simSetObjectSel \n \n \n Object creation \n \n sim.createDummy \n sim.createForceSensor \n sim.createHeightfieldShape \n sim.createJoint \n sim.createMeshShape \n sim.createProximitySensor \n sim.createPrimitiveShape \n sim.createVisionSensor \n sim.createOctree \n sim.createPointCloud \n sim.createTexture \n sim.generateTextShape \n sim.generateShapeFromPath \n \n \n \n simCreateDummy \n simCreateForceSensor \n simCreateHeightfieldShape \n simCreateJoint \n simCreateMeshShape \n simCreateProximitySensor \n simCreatePrimitiveShape \n simCreateVisionSensor \n simCreateOctree \n simCreatePointCloud \n simCreateTexture \n simGenerateShapeFromPath \n \n \n Scripts \n \n sim.getRandom \n sim.getScript \n sim.isHandle \n sim.addScript \n sim.initScript \n sim.removeScript \n sim.callScriptFunction \n sim.executeScriptString \n sim.getApiFunc \n sim.getApiInfo \n sim.handleChildScripts \n sim.handleCustomizationScripts \n sim.handleAddOnScripts \n sim.handleSandboxScript \n sim.setScriptText \n sim.registerScriptFunction \n sim.registerScriptVariable \n sim.registerScriptFuncHook \n sim.getStackTraceback \n sim.isDeprecated \n\n See also:\n  functions related to script parameters \n \n \n \n simGetScriptHandleEx \n simIsHandle \n simAddScript \n simInitScript \n simRemoveScript \n simCallScriptFunction \n simCallScriptFunctionEx \n simExecuteScriptString \n simGetApiFunc \n simGetApiInfo \n simHandleMainScript \n simResetScript \n simGetScriptProperty \n simGetScriptText \n simSetScriptText \n simRegisterScriptCallbackFunction \n simRegisterScriptVariable \n simRegisterScriptFuncHook \n simIsDeprecated \n \n \n Simulation \n \n sim.startSimulation \n sim.pauseSimulation \n sim.stopSimulation \n sim.getSimulationState \n sim.getSimulationTime \n sim.getSimulationTimeStep \n sim.getRealTimeSimulation \n \n \n \n simStartSimulation \n simPauseSimulation \n simStopSimulation \n simAdvanceSimulationByOneStep \n simGetSimulationState \n simGetSimulationTime \n simGetSimulationTimeStep \n simGetSimulationPassesPerRenderingPass \n simSetSimulationPassesPerRenderingPass \n simGetRealTimeSimulation \n simAdjustRealTimeTimer \n simIsRealTimeSimulationStepNeeded \n \n \n Threads \n \n sim.getThreadAutomaticSwitch \n sim.getThreadExitRequest \n sim.getThreadSwitchTiming \n sim.getThreadSwitchAllowed \n sim.handleExtCalls \n sim.setThreadAutomaticSwitch \n sim.setThreadSwitchTiming \n sim.setThreadSwitchAllowed \n sim.switchThread \n \n \n Custom scripts \n \n sim.registerScriptFunction \n sim.registerScriptVariable \n sim.registerScriptFuncHook \n \n \n \n simRegisterScriptCallbackFunction \n simRegisterScriptVariable \n simRegisterScriptFuncHook \n \n \n Transformations \n \n sim.buildMatrix \n sim.buildMatrixQ \n sim.buildPose \n sim.getEulerAnglesFromMatrix \n sim.getQuaternionFromMatrix \n sim.multiplyMatrices \n sim.interpolateMatrices \n sim.invertMatrix \n sim.getObjectMatrix \n sim.setObjectMatrix \n sim.getObjectPose \n sim.setObjectPose \n sim.getObjectPosition \n sim.setObjectPosition \n sim.getObjectOrientation \n sim.setObjectOrientation \n sim.getObjectQuaternion \n sim.setObjectQuaternion \n sim.getObjectChildPose \n sim.setObjectChildPose \n sim.multiplyVector \n sim.getRotationAxis \n sim.rotateAroundAxis \n sim.getObjectVelocity \n sim.reorientShapeBoundingBox \n sim.alphaBetaGammaToYawPitchRoll \n sim.yawPitchRollToAlphaBetaGamma \n\n See also:\n  packing/unpacking functions \n \n \n \n simBuildMatrix \n simBuildMatrixQ \n simBuildPose \n simGetEulerAnglesFromMatrix \n simGetQuaternionFromMatrix \n simMultiplyMatrices \n simInterpolateMatrices \n simInvertMatrix \n simGetObjectMatrix \n simSetObjectMatrix \n simGetObjectPose \n simSetObjectPose \n simGetObjectPosition \n simSetObjectPosition \n simGetObjectOrientation \n simSetObjectOrientation \n simGetObjectQuaternion \n simSetObjectQuaternion \n simGetObjectChildPose \n simSetObjectChildPose \n simTransformVector \n simGetRotationAxis \n simRotateAroundAxis \n simGetObjectVelocity \n simReorientShapeBoundingBox \n \n \n Messaging \n \n sim.addLog \n sim.loadModule \n sim.unloadModule \n sim.getSimulatorMessage \n sim.serialCheck \n sim.serialClose \n sim.serialOpen \n sim.serialRead \n sim.serialSend \n sim.setInt32Signal \n sim.getInt32Signal \n sim.clearInt32Signal \n sim.setFloatSignal \n sim.getFloatSignal \n sim.clearFloatSignal \n sim.setDoubleSignal \n sim.getDoubleSignal \n sim.clearDoubleSignal \n sim.setStringSignal \n sim.getStringSignal \n sim.clearStringSignal \n sim.getSignalName \n sim.waitForSignal \n sim.auxiliaryConsoleClose \n sim.auxiliaryConsoleOpen \n sim.auxiliaryConsolePrint \n sim.persistentDataRead \n sim.persistentDataWrite \n sim.getPersistentDataTags \n sim.getMatchingPersistentDataTags \n sim.callScriptFunction \n sim.executeScriptString \n sim.getObjectUid \n sim.getGenesisEvents \n sim.broadcastMsg \n sim.pushUserEvent \n \n \n \n simAddLog \n simSetLastError \n simLoadModule \n simUnloadModule \n simGetSimulatorMessage \n simSerialCheck \n simSerialClose \n simSerialOpen \n simSerialRead \n simSerialSend \n simSetInt32Signal \n simGetInt32Signal \n simClearInt32Signal \n simSetFloatSignal \n simGetFloatSignal \n simClearFloatSignal \n simSetDoubleSignal \n simGetDoubleSignal \n simClearDoubleSignal \n simSetStringSignal \n simGetStringSignal \n simClearStringSignal \n simGetSignalName \n simAuxiliaryConsoleClose \n simAuxiliaryConsoleOpen \n simAuxiliaryConsolePrint \n simPersistentDataRead \n simPersistentDataWrite \n simGetPersistentDataTags \n simCallScriptFunctionEx \n simExecuteScriptString \n simGetObjectUid \n \n \n Signals \n \n sim.setInt32Signal \n sim.getInt32Signal \n sim.clearInt32Signal \n sim.setFloatSignal \n sim.getFloatSignal \n sim.clearFloatSignal \n sim.setDoubleSignal \n sim.getDoubleSignal \n sim.clearDoubleSignal \n sim.setStringSignal \n sim.getStringSignal \n sim.clearStringSignal \n sim.getSignalName \n sim.waitForSignal \n\n See also:\n  data packing/unpacking .\n  persistent data .\n \n \n \n simSetInt32Signal \n simGetInt32Signal \n simClearInt32Signal \n simSetFloatSignal \n simGetFloatSignal \n simClearFloatSignal \n simSetDoubleSignal \n simGetDoubleSignal \n simClearDoubleSignal \n simSetStringSignal \n simGetStringSignal \n simClearStringSignal \n simGetSignalName \n \n \n Persistent Data \n \n sim.persistentDataRead \n sim.persistentDataWrite \n sim.getPersistentDataTags \n sim.getMatchingPersistentDataTags \n \n \n \n simPersistentDataRead \n simPersistentDataWrite \n simGetPersistentDataTags \n \n \n Custom data blocks \n \n sim.readCustomTableData \n sim.writeCustomTableData \n sim.readCustomDataBlock \n sim.readCustomDataBlockTags \n sim.writeCustomDataBlock \n\n See also:\n  data packing/unpacking .\n \n \n \n simReadCustomDataBlock \n simReadCustomDataBlockTags \n simWriteCustomDataBlock \n \n \n Textures \n \n sim.getTextureId \n sim.getShapeTextureId \n sim.readTexture \n sim.saveImage \n sim.loadImage \n sim.getScaledImage \n sim.transformImage \n sim.writeTexture \n sim.createTexture \n sim.setShapeTexture \n \n \n \n simApplyTexture \n simGetTextureId \n simGetShapeTextureId \n simReadTexture \n simSaveImage \n simLoadImage \n simGetScaledImage \n simTransformImage \n simWriteTexture \n simCreateTexture \n simSetShapeTexture \n \n \n Blocking functions \n \n sim.wait \n sim.waitForSignal \n sim.moveToConfig \n sim.moveToPose \n sim.serialRead \n \n \n Auxiliary consoles  \n \n sim.auxiliaryConsoleClose \n sim.auxiliaryConsoleOpen \n sim.auxiliaryConsolePrint \n sim.auxiliaryConsoleShow \n\n See also:\n  Custom user interfaces .\n \n \n \n simAuxiliaryConsoleClose \n simAuxiliaryConsoleOpen \n simAuxiliaryConsolePrint \n simAuxiliaryConsoleShow \n \n \n Text/code editors \n \n sim.textEditorClose \n sim.textEditorGetInfo \n sim.textEditorOpen \n sim.textEditorShow \n\n See also:\n  Custom user interfaces .\n \n \n Import/export \n \n sim.importShape \n sim.importMesh \n sim.exportMesh \n sim.createTexture \n sim.loadImage \n sim.saveImage \n sim.generateTextShape \n\n See also:\n  Assimp plugin API reference .\n \n \n \n simImportShape \n simImportMesh \n simExportMesh \n simCreateTexture \n simLoadImage \n simSaveImage \n \n \n Pages and views \n \n sim.floatingViewAdd \n sim.floatingViewRemove \n sim.adjustView \n sim.cameraFitToView \n \n \n \n simFloatingViewAdd \n simFloatingViewRemove \n simAdjustView \n simCameraFitToView \n \n \n Ruckig motion library \n \n sim.moveToConfig \n sim.moveToPose \n sim.ruckigPos \n sim.ruckigVel \n sim.ruckigStep \n sim.ruckigRemove \n \n \n \n simRuckigPos \n simRuckigVel \n simRuckigStep \n simRuckigRemove \n \n \n Packing / unpacking \n \n sim.packTable \n sim.unpackTable \n sim.packUInt8Table \n sim.unpackUInt8Table \n sim.packUInt16Table \n sim.unpackUInt16Table \n sim.packUInt32Table \n sim.unpackUInt32Table \n sim.packInt32Table \n sim.unpackInt32Table \n sim.packFloatTable \n sim.unpackFloatTable \n sim.packDoubleTable \n sim.unpackDoubleTable \n sim.copyTable \n sim.transformBuffer \n \n \n \n simPackTable \n simUnpackTable \n \n \n Stacks \n \n sim.packTable \n sim.unpackTable \n \n \n \n simCreateStack \n simReleaseStack \n simCopyStack \n simPushNullOntoStack \n simPushBoolOntoStack \n simPushInt32OntoStack \n simPushFloatOntoStack \n simPushDoubleOntoStack \n simPushStringOntoStack \n simPushUInt8TableOntoStack \n simPushInt32TableOntoStack \n simPushFloatTableOntoStack \n simPushDoubleTableOntoStack \n simPushTableOntoStack \n simInsertDataIntoStackTable \n simGetStackSize \n simPopStackItem \n simMoveStackItemToTop \n simIsStackValueNull \n simGetStackBoolValue \n simGetStackInt32Value \n simGetStackFloatValue \n simGetStackDoubleValue \n simGetStackStringValue \n simGetStackTableInfo \n simGetStackUInt8Table \n simGetStackInt32Table \n simGetStackFloatTable \n simGetStackDoubleTable \n simUnfoldStackTable \n simDebugStack \n simPackTable \n simUnpackTable \n \n \n Object parameters \n \n sim.getObjectInt32Param \n sim.setObjectInt32Param \n sim.getObjectFloatParam \n sim.setObjectFloatParam \n sim.getObjectStringParam \n sim.setObjectStringParam \n \n \n \n simGetObjectInt32Param \n simSetObjectInt32Param \n simGetObjectFloatParam \n simSetObjectFloatParam \n simGetObjectStringParam \n simSetObjectStringParam \n \n \n Script parameters \n \n sim.getScriptInt32Param \n sim.setScriptInt32Param \n sim.getScriptStringParam \n sim.setScriptStringParam \n \n \n \n simGetScriptInt32Param \n simSetScriptInt32Param \n simGetScriptStringParam \n simSetScriptStringParam \n \n \n Simulator parameters \n \n sim.setArrayParam \n sim.getArrayParam \n sim.setBoolParam \n sim.getBoolParam \n sim.setInt32Param \n sim.getInt32Param \n sim.setFloatParam \n sim.getFloatParam \n sim.setStringParam \n sim.getStringParam \n sim.setNamedStringParam \n sim.getNamedStringParam \n \n \n \n simSetArrayParam \n simGetArrayParam \n simSetBoolParam \n simGetBoolParam \n simSetInt32Param \n simGetInt32Param \n simSetFloatParam \n simGetFloatParam \n simSetStringParam \n simGetStringParam \n simSetNamedStringParam \n simGetNamedStringParam \n simGetUInt64Parameter \n \n \n Simulator named parameters \n \n sim.setNamedStringParam \n sim.getNamedStringParam \n sim.getNamedBoolParam \n sim.getNamedFloatParam \n sim.getNamedInt32Param \n \n \n \n simSetNamedStringParam \n simGetNamedStringParam \n \n \n Physics engine parameters \n \n sim.getEngineFloatParam \n sim.getEngineInt32Param \n sim.getEngineBoolParam \n sim.setEngineFloatParam \n sim.setEngineInt32Param \n sim.setEngineBoolParam \n \n \n \n simGetEngineFloatParam \n simGetEngineInt32Param \n simGetEngineBoolParam \n simSetEngineFloatParam \n simSetEngineInt32Param \n simSetEngineBoolParam \n \n \n Other commands \n \n sim.addLog \n sim.announceSceneContentChange \n sim.getNavigationMode \n sim.setNavigationMode \n sim.getPage \n sim.setPage \n sim.getModuleName \n sim.getNavigationMode \n sim.getSystemTime \n sim.refreshDialogs \n sim.setThreadSwitchTiming \n sim.switchThread \n sim.getExplicitHandling \n sim.setExplicitHandling \n sim.launchExecutable \n sim.quitSimulator \n sim.getExtensionString \n sim.textEditorClose \n sim.textEditorGetInfo \n sim.textEditorOpen \n sim.textEditorShow \n sim.getUserVariables \n sim.isDeprecated \n sim.moduleEntry \n sim.getGenesisEvents \n sim.pushUserEvent \n \n \n \n simAddLog \n simAnnounceSceneContentChange \n simGetNavigationMode \n simSetNavigationMode \n simGetPage \n simSetPage \n simGetLastError \n simSetLastError \n simGetModuleName \n simGetNavigationMode \n simRefreshDialogs \n simGetExplicitHandling \n simSetExplicitHandling \n simQuitSimulator \n simGetExtensionString \n simOpenTextEditor \n simCreateBuffer \n simReleaseBuffer \n simIsDeprecated \n simModuleEntry \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'APIFunctions.html'}, {'title': 'sdfPlugin', 'text': '\n \n \n \n \n SDF importer plugin \n The SDF  file format (*.sdf) is supported for import operations via the  simExtSDF  plugin. Next to  API functions related to the URDF format , the plugin also offers a GUI dialog accessible via [Menu bar --> Plugins --> SDF import...]: \n \n [SDF plugin dialog] \n \n Ignore missing required values (SDF parser) : ignores required elements that are missing (if some format specifications are not respected).\n \n Assign collision links to layer 9 : hides collision links in layer 9 (layer 9 is off by default).\n \n Assign joints to layer 10 : hides joints in layer 10 (layer 10 is off by default).\n \n Convex decompose non-convex collision links : decomposes non-convex respondable shapes into convex shapes. This item should always be checked, since convex shapes perform faster and are more stable during dynamic collision response calculations.\n \n Show convex decomposition dialog : allows to adjust the way how the convex decomposition operates.\n \n Create visual links if none : creates an artificial visual element if the link doesn\'t define one.\n \n Center model above ground : centers the imported model above the ground.\n \n Prepare model definition if feasable : tags the root object as "model base" and adapts the other objects accordingly (e.g. clicking an object in the model will select the whole model instead of an individual object).\n \n Alternate local respondable masks : when checked, alternates the local collision masks so that adjacent respondable shapes won\'t react to collision. If unckecked, then all respondable shapes will only react to collision with objects outside of the model.\n \n Enable position control for revolute and prismatic joints : if checked, then revolute and prismatic joints will be in position control mode. Joint force/torque and upper regulation velocity are taken from the SDF file. \n Import : triggers the import operation.\n \n \n \n \n \n', 'tags': '', 'url': 'sdfPlugin.html'}, {'title': 'SDFPluginAPIreference', 'text': '\n SDF Plugin API reference \n API functions for SDF input/output. \n simSDF.dump \n simSDF.import \n \n \n \n simSDF.dump\n \n \n \n                                                    Description\n                                                 \n Inspect the structure of a SDF file. Can be useful for tracking bugs. \n \n \n Lua synopsis \n simSDF.dump(string fileName) \n \n \n \n Lua parameters \n \n fileName  (string): SDF file path \n \n \n Lua return values \n - \n \n \n Python synopsis \n simSDF.dump(string fileName) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simSDF.import\n \n \n \n                                                    Description\n                                                 \n Import a SDF file into the current scene. \n \n \n Lua synopsis \n simSDF.import(string fileName, ImportOptions options={}) \n \n \n \n Lua parameters \n \n \n fileName  (string): SDF file path \n \n options  (ImportOptions, default: {}):  \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simSDF.import(string fileName, ImportOptions options={}) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n \n Data structures \n Data structures are used to pass complex data around. Create data structures in Lua in the form of a map, e.g.:  {line_size=3, add_to_legend=false, selectable=true} \n \n ImportOptions\n \n \n \n                                                Description\n                                             \n \n \n \n Fields \n \n \n fileName  (string, default: nil):  \n \n ignoreMissingValues  (bool, default: false):  \n \n hideCollisionLinks  (bool, default: true):  \n \n hideJoints  (bool, default: true):  \n \n convexDecompose  (bool, default: true):  \n \n showConvexDecompositionDlg  (bool, default: false):  \n \n createVisualIfNone  (bool, default: true):  \n \n centerModel  (bool, default: true):  \n \n prepareModel  (bool, default: true):  \n \n noSelfCollision  (bool, default: true):  \n \n positionCtrl  (bool, default: true):  \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'SDFPluginAPIreference.html'}, {'title': 'aviRecorder', 'text': '\n \n \n \n \n Video exporter \n CoppeliaSim has an embedded video recorder that allows the user to record the  page ,  scene hierarchy  and  model browser  areas as a video file (click  here  and  here  for credits related to the video recording functionality). Dialogs, menu bar, toolbars and popup menus are not recorded. By default, the video recorder will record every rendered frame and generate a movie with 30 frames per second. Remember that depending on the used codec, the recording procedure might drastically slow down the  simulation . The video recorder dialog can be accessed with [Menu bar --> Tools --> Video recorder] or by clicking following toolbar button: \n \n \n [Video recorder toolbar button] \n \n \n [Video recorder dialog] \n \n Launch at next simulation start : will launch a recording process next time the simulation start button is hit. \n \n Record now! : starts recording a video file immediately. Press Stop  recording!  to end the recording process. \n \n Record window content : records exclusively the content of the main CoppeliaSim window (no dialogs will be recorded). \n \n Record desktop content : records the content of the desktop. With systems with several monitors, you can specify the desktop index via variable  desktopRecordingIndex  in file  system/usrset.txt . \n \n Show cursor : if enabled, then the cursor will be visible in the video file. \n \n Show button states : if enabled, then the mouse button states, as well as the ctrl- and shift-key states will be visible in the video file. \n \n Hide information text : if enabled, then the  overlay text at the top of the main view  will not be visible. \n \n Select : allows selecting the video file location. \n Output type : the encoder/container that will be used for the video. The offered selection depends on the encoders on your system. It often helps to install a video player (e.g. such as VLC), which will automatically install a few additional encoders. \n X displayed frames result in 1 recorded frame : allows specifying what frames should be recorded.\n \n Automatic frame rate : the frame rate will be adjusted in a way so that x simulation seconds correspond to x video seconds.\n \n Frame rate : indicates the number of frames the video file will display in one second.\n \n \n \n \n \n', 'tags': '', 'url': 'aviRecorder.html'}, {'title': 'AssimpPluginAPIreference', 'text': "\n Assimp Plugin API reference \n Plugin for importing CAD files \n simAssimp.exportMeshes \n simAssimp.exportShapes \n simAssimp.exportShapesDlg \n simAssimp.getExportFormat \n simAssimp.getImportFormat \n simAssimp.importMeshes \n simAssimp.importShapes \n simAssimp.importShapesDlg \n \n \n \n simAssimp.exportMeshes\n \n \n \n                                                    Description\n                                                 \n Exports the specified mesh data. \n \n \n Lua synopsis \n simAssimp.exportMeshes(table allVertices, \ntable allIndices, string filename, string formatId, float scaling=1.0, \nint upVector=sim_assimp_upvect_z, int options=0) \n \n \n \n Lua parameters \n \n \n allVertices  (table): A table containing tables of vertices (one table entry per mesh) \n \n allIndices  (table): A table containing tables of indices (one table entry per mesh) \n \n filename  (string): The filename including its extension \n \n formatId  (string): see simAssimp.getExportFormat \n \n scaling  (float, default: 1.0): The desired mesh scaling. \n \n upVector  (int, default: sim_assimp_upvect_z): The desired up-vector (see  simAssimp.upVector ) \n \n options  (int, default: 0): Export flags (256=silent) \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simAssimp.exportMeshes(list allVertices, \nlist allIndices, string filename, string formatId, float scaling=1.0, \nint upVector=sim_assimp_upvect_z, int options=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simAssimp.exportShapes\n \n \n \n                                                    Description\n                                                 \n Exports the specified shapes. Depending \non the fileformat, several files will be created (e.g. myFile.obj, \nmyFile.mtl, myFile_2180010.png, etc.) \n \n \n Lua synopsis \n simAssimp.exportShapes(int[] shapeHandles,\n string filename, string formatId, float scaling=1.0, int \nupVector=sim_assimp_upvect_z, int options=0) \n \n \n \n Lua parameters \n \n \n shapeHandles  (table of int): The handles of the shapes to export \n \n filename  (string): The filename including its extension \n \n formatId  (string): see simAssimp.getExportFormat \n \n scaling  (float, default: 1.0): The desired mesh scaling. \n \n upVector  (int, default: sim_assimp_upvect_z): The desired up-vector (see  simAssimp.upVector ) \n \n options  (int, default: 0): Export flags (1=drop \ntextures, 2=ignore colors, 4=drop normals, 8=export only visible, \n256=silent, 512=coordinates relative to first shape's frame) \n \n \n \n Lua return values \n \n \n \n Python synopsis \n simAssimp.exportShapes(list shapeHandles, \nstring filename, string formatId, float scaling=1.0, int \nupVector=sim_assimp_upvect_z, int options=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simAssimp.exportShapesDlg\n \n \n \n                                                    Description\n                                                 \n Offers export parameters via dialog, before calling simAssimp.export \n \n \n Lua synopsis \n simAssimp.exportShapesDlg(string filename, int[] shapeHandles) \n \n \n \n Lua parameters \n \n \n filename  (string): The filename (including extension) of the CAD data \n \n shapeHandles  (table of int): The handles of the shapes to export \n \n \n \n Lua return values \n - \n \n \n Python synopsis \n simAssimp.exportShapesDlg(string filename, list shapeHandles) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simAssimp.getExportFormat\n \n \n \n                                                    Description\n                                                 \n Allows to loop through supported file formats for export \n \n \n Lua synopsis \n string formatDescription, string formatExtension, string formatId=simAssimp.getExportFormat(int index) \n \n \n \n Lua parameters \n \n index  (int): Zero-based index \n \n \n Lua return values \n \n \n formatDescription  (string): The description of the file format at the specified index, or an empty string \n \n formatExtension  (string): The file extension of the file format at the specified index, or an empty string \n \n formatId  (string): The file format ID at the specified index (needed when exporting), or an empty string \n \n \n \n Python synopsis \n string formatDescription, string formatExtension, string formatId=simAssimp.getExportFormat(int index) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simAssimp.getImportFormat\n \n \n \n                                                    Description\n                                                 \n Allows to loop through supported file formats for import \n \n \n Lua synopsis \n string formatDescription, string formatExtension=simAssimp.getImportFormat(int index) \n \n \n \n Lua parameters \n \n index  (int): Zero-based index \n \n \n Lua return values \n \n \n formatDescription  (string): The description of the file format at the specified index, or an empty string \n \n formatExtension  (string): The file extension of the file format at the specified index, or an empty string \n \n \n \n Python synopsis \n string formatDescription, string formatExtension=simAssimp.getImportFormat(int index) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simAssimp.importMeshes\n \n \n \n                                                    Description\n                                                 \n Imports the specified files as mesh data \n \n \n Lua synopsis \n table allVertices, table \nallIndices=simAssimp.importMeshes(string filenames, float scaling=0.0, \nint upVector=sim_assimp_upvect_auto, int options=0) \n \n \n \n Lua parameters \n \n \n filenames  (string): The filenames (semicolon-separated), including their extensions \n \n scaling  (float, default: 0.0): The desired mesh scaling. 0.0 for automatic scaling \n \n upVector  (int, default: sim_assimp_upvect_auto): The desired up-vector (see  simAssimp.upVector ) \n \n options  (int, default: 0): Import flags (8=do not \noptimize meshes, 16=keep inditical vertices, 32=one mesh per file, \n128=ignore up vector coded in fileformat (e.g. Collada), 256=silent) \n \n \n \n Lua return values \n \n \n allVertices  (table): A table containing tables of vertices (one table entry per mesh) \n \n allIndices  (table): A table containing tables of indices (one table entry per mesh) \n \n \n \n Python synopsis \n list allVertices, list \nallIndices=simAssimp.importMeshes(string filenames, float scaling=0.0, \nint upVector=sim_assimp_upvect_auto, int options=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simAssimp.importShapes\n \n \n \n                                                    Description\n                                                 \n Imports the specified files as shapes \n \n \n Lua synopsis \n int[] \nshapeHandles=simAssimp.importShapes(string filenames, int \nmaxTextureSize=512, float scaling=0.0, int \nupVector=sim_assimp_upvect_auto, int options=0) \n \n \n \n Lua parameters \n \n \n filenames  (string): The filenames (semicolon-separated), including their extensions \n \n maxTextureSize  (int, default: 512): The desired maximum texture size (textures will be scaled) \n \n scaling  (float, default: 0.0): The desired mesh scaling. 0.0 for automatic scaling \n \n upVector  (int, default: sim_assimp_upvect_auto): The desired up-vector (see  simAssimp.upVector ) \n \n options  (int, default: 0): Import flags (1=drop \ntextures, 2=ignore colors, 4=ignore transparency, 8=do not optimize \nmeshes, 16=keep identical vertices, 32=generate one shape per file, \n64=shapes have aligned orientations, 128=ignore up vector coded in \nfileformat (e.g. Collada), 256=silent) \n \n \n \n Lua return values \n \n shapeHandles  (table of int): Handles of imported shapes \n \n \n Python synopsis \n list \nshapeHandles=simAssimp.importShapes(string filenames, int \nmaxTextureSize=512, float scaling=0.0, int \nupVector=sim_assimp_upvect_auto, int options=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simAssimp.importShapesDlg\n \n \n \n                                                    Description\n                                                 \n Offers import parameters via dialog, before calling simAssimp.import \n \n \n Lua synopsis \n int[] handles=simAssimp.importShapesDlg(string filename) \n \n \n \n Lua parameters \n \n filename  (string): The filename (including extension) of the CAD data \n \n \n Lua return values \n \n handles  (table of int): The handles of the imported shapes \n \n \n Python synopsis \n list handles=simAssimp.importShapesDlg(string filename) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n Constants \n Constants used in the various functions. Refer to each constant using  enumName.constantName , i.e.  simUI.curve_type.xy  for  xy  constant in  simUI.curve_type  enum. \n \n simAssimp.upVector\n \n \n auto : The up vector is automatically picked \n \n z : The up vector is along the file's Z-coordinate \n \n y : The up vector is along the file's Y-coordinate \n \n \n \n \n ,  ,  ,  , ", 'tags': '', 'url': 'AssimpPluginAPIreference.html'}, {'title': 'GLTFPluginAPIreference', 'text': '\n GLTF Plugin API reference \n Plugin for glTF format support \n simGLTF.animationFrameCount \n simGLTF.clear \n simGLTF.exportAllObjects \n simGLTF.exportAnimation \n simGLTF.exportObject \n simGLTF.exportObjects \n simGLTF.exportSelectedObjects \n simGLTF.exportShape \n simGLTF.loadASCII \n simGLTF.loadBinary \n simGLTF.recordAnimation \n simGLTF.saveASCII \n simGLTF.saveBinary \n simGLTF.serialize \n \n \n \n simGLTF.animationFrameCount\n \n \n \n                                                    Description\n                                                 \n Return count of animation frames. \n \n \n Lua synopsis \n int count=simGLTF.animationFrameCount() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n count  (int): count of frames \n \n \n Python synopsis \n int count=simGLTF.animationFrameCount() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.clear\n \n \n \n                                                    Description\n                                                 \n Clear all data stored in memory (geometry, material, animation, cache). \n \n \n Lua synopsis \n simGLTF.clear() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n - \n \n \n Python synopsis \n simGLTF.clear() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.exportAllObjects\n \n \n \n                                                    Description\n                                                 \n Export all objects to glTF model. \n \n \n Lua synopsis \n simGLTF.exportAllObjects() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n - \n \n \n Python synopsis \n simGLTF.exportAllObjects() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.exportAnimation\n \n \n \n                                                    Description\n                                                 \n Export animation data to glTF model. \n \n \n Lua synopsis \n simGLTF.exportAnimation() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n - \n \n \n Python synopsis \n simGLTF.exportAnimation() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.exportObject\n \n \n \n                                                    Description\n                                                 \n Export object to glTF model. \n \n \n Lua synopsis \n int nodeIndex=simGLTF.exportObject(int objectHandle) \n \n \n \n Lua parameters \n \n objectHandle  (int): handle of the object \n \n \n Lua return values \n \n nodeIndex  (int): index of the new node (may contain sub-nodes) \n \n \n Python synopsis \n int nodeIndex=simGLTF.exportObject(int objectHandle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.exportObjects\n \n \n \n                                                    Description\n                                                 \n Export objects to glTF model. \n \n \n Lua synopsis \n simGLTF.exportObjects(int[] objectHandles) \n \n \n \n Lua parameters \n \n objectHandles  (table of int): handles of the objects \n \n \n Lua return values \n - \n \n \n Python synopsis \n simGLTF.exportObjects(list objectHandles) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.exportSelectedObjects\n \n \n \n                                                    Description\n                                                 \n Export selected objects to glTF model. \n \n \n Lua synopsis \n simGLTF.exportSelectedObjects() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n - \n \n \n Python synopsis \n simGLTF.exportSelectedObjects() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.exportShape\n \n \n \n                                                    Description\n                                                 \n Export shape to glTF model. \n \n \n Lua synopsis \n int nodeIndex=simGLTF.exportShape(int shapeHandle, int parentHandle=-1, int parentNodeIndex=0) \n \n \n \n Lua parameters \n \n \n shapeHandle  (int): handle of the shape \n \n parentHandle  (int, default: -1): handle of the parent \nobject. if specified the matrix of the node will be relative to this. \nuse this in conjunction with parentNodeIndex parameter. \n \n parentNodeIndex  (int, default: 0): index of parent node \n \n \n \n Lua return values \n \n nodeIndex  (int): index of the new node (may contain sub-nodes) \n \n \n Python synopsis \n int nodeIndex=simGLTF.exportShape(int shapeHandle, int parentHandle=-1, int parentNodeIndex=0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.loadASCII\n \n \n \n                                                    Description\n                                                 \n Load an ASCII glTF model. \n \n \n Lua synopsis \n bool result, string warnings, string errors=simGLTF.loadASCII(string filepath) \n \n \n \n Lua parameters \n \n filepath  (string):  \n \n \n Lua return values \n \n \n result  (bool): true if success \n \n warnings  (string): warning message(s) \n \n errors  (string): error message(s) \n \n \n \n Python synopsis \n bool result, string warnings, string errors=simGLTF.loadASCII(string filepath) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.loadBinary\n \n \n \n                                                    Description\n                                                 \n Load a binary (.glb) glTF model. \n \n \n Lua synopsis \n bool result, string warnings, string errors=simGLTF.loadBinary(string filepath) \n \n \n \n Lua parameters \n \n filepath  (string):  \n \n \n Lua return values \n \n \n result  (bool): true if success \n \n warnings  (string): warning message(s) \n \n errors  (string): error message(s) \n \n \n \n Python synopsis \n bool result, string warnings, string errors=simGLTF.loadBinary(string filepath) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.recordAnimation\n \n \n \n                                                    Description\n                                                 \n Export animation data to glTF model. \n \n \n Lua synopsis \n simGLTF.recordAnimation(bool enable) \n \n \n \n Lua parameters \n \n enable  (bool): if true the plugin will record the pose of all objects during simulation \n \n \n Lua return values \n - \n \n \n Python synopsis \n simGLTF.recordAnimation(bool enable) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.saveASCII\n \n \n \n                                                    Description\n                                                 \n Save a glTF model to an ASCII file. \n \n \n Lua synopsis \n bool result=simGLTF.saveASCII(string filepath) \n \n \n \n Lua parameters \n \n filepath  (string):  \n \n \n Lua return values \n \n result  (bool): true if success \n \n \n Python synopsis \n bool result=simGLTF.saveASCII(string filepath) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.saveBinary\n \n \n \n                                                    Description\n                                                 \n Save a glTF model to a binary file. \n \n \n Lua synopsis \n bool result=simGLTF.saveBinary(string filepath) \n \n \n \n Lua parameters \n \n filepath  (string):  \n \n \n Lua return values \n \n result  (bool): true if success \n \n \n Python synopsis \n bool result=simGLTF.saveBinary(string filepath) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simGLTF.serialize\n \n \n \n                                                    Description\n                                                 \n Serialize glTF model to JSON string. \n \n \n Lua synopsis \n string json=simGLTF.serialize() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n \n json  (string): the JSON document \n \n \n Python synopsis \n string json=simGLTF.serialize() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'GLTFPluginAPIreference.html'}, {'title': 'commandLine', 'text': '\n \n \n \n \n Commands/settings \n You can adjust the way CoppeliaSim operates via a  plugin  or an  add-on , but you can also modify its behaviour via: \n command line  arguments \n the  overall settings file \n Additionally, you can also interact with CoppeliaSim via script functions and the  Lua commander . \n \n \n \n Command line\n \n When you start CoppeliaSim via the command line, you have following command line options that are supported:  \n -vXXX : sets the verbosity level, in the console. Default is  loadinfos . Other accepted values for  XXX  are  none ,  errors ,  warnings , loadinfos,  scripterrors ,  scriptwarnings ,  scriptinfos ,  infos ,   debug  ,  trace ,  tracelua  and  traceall . Plugins should output messages via  simAddLog  , scripts via  sim.addLog . Verbosity can change during runtime: from within CoppeliaSim, global verbosity can be adjusted with  sim.setInt32Param (sim.intparam_globalverbosity,verbosity), and plugin verbosity with  sim.setModuleInfo (pluginName,sim.moduleinfo_verbosity,verbosity). By default, plugin verbosity follows global verbosity. Command line verbosity setting can be overridden via the  verbosity  value in  system/usrset.txt . Additionally, console log messages can be filtered via the  consoleLogFilter  value in  system/usrset.txt ., or via  sim.setStringParam ( sim.stringparam_consolelogfilter ,filter). \n -wXXX : similar to the  -v  setting above, but for the verbosity level in the  status bar . Default is  scriptinfos . Status bar verbosity setting can be overridden via the  statusbarVerbosity  value in  system/usrset.txt . \n -xXXX : similar to the - v  or  -w  setting above, but for the verbosity level for simple dialogs. Default is  infos . Other accepted values for  XXX  are  none ,  errors ,  warnings  and  questions . Dialog verbosity setting can be overridden via the  dialogVerbosity  value in  system/usrset.txt . \n -c"XXX" : executes the script string XXX as soon as the sandbox script is initialized. \n -h : runs CoppeliaSim in headless mode (i.e. without any GUI). This option simply suppresses all GUI elements, but otherwise runs normally. For a true headless operation, use the headless library (i.e. rename  coppeliaSimLibHeadless.dll  (or similar) to  coppeliaSimLib.dll ). In that case keep in mind that  vision sensors  won\'t operate, unless they use the Pov-Ray rendering mode (and the  Pov-Ray plugin  is installed, binaries available  here ), and that their rendering will be drastically slower. \n -sXXX : automatically start the simulation.  XXX  represents an optional simulation time in milliseconds after which simulation should stop again. \n -q : automatically quits CoppeliaSim after the first simulation run ended. \n -aXXX  and/or  -bXXX : loads and runs an additional  add-on  specified via its filename (where  XXX  should contain the filename extension, e.g.  myAddon.lua ). \n -GYYY=XXX : named parameter:  YYY  represents the key,  XXX  the value, that can be queried within CoppeliaSim with the  sim.getNamedStringParam . \n -gXXX :  XXX  represents an optional argument that can be queried within CoppeliaSim with the  sim.stringparam_app_arg1 ... sim.stringparam_app_arg9 parameters. The argument can be used for various custom purposes. \n -gGUIITEMS_XXX : the argument can be used to disable specific GUI items. For that to happen, replace in above string  XXX  with a decimal bit-coded value taken from the  start-up options . \n XXX.ttt  or  XXX.simscene.xml : loads a  CoppeliaSim scene . \n XXX.ttm  or  XXX.simmodel.xml : loads a  CoppeliaSim model . \n XXX.brs : loads an XReality scene. \n XXX.brm : loads an XReality model. \n For example, to start CoppeliaSim in headless mode, load the scene  myScene.ttt , run the simulation for 5 seconds, then stop the simulation and automatically leave CoppeliaSim again, type from within the CoppeliaSim main folder: \n \n Windows: \n$ coppeliaSim.exe -h -s5000 -q myScene.ttt\n\n Linux: \n$ ./coppeliaSim.sh -h -s5000 -q myScene.ttt\n\n Mac: \n$ ./coppeliaSim.app/Contents/MacOS/coppeliaSim -h -s5000 -q ../Resources/myScene.ttt\n \n \n \n \n Overall settings file\n \n When CoppeliaSim starts, the file  system/usrset.txt  is read and values applied. Settings apply to various areas, such as: \n debugging \n rendering/display \n directories \n serialization \n messaging \n compatibility \n floating licence \n etc. \n \n \n \n Lua commander\n \n The Lua commander, implemented via the  simExtLuaCmd plugin , is a read-eval-print loop, that adds a text input to the CoppeliaSim status bar, which allows entering and executing Lua code on the fly, like in a terminal. The code can be run in the\xa0 sandbox script , or any other active script in CoppeliaSim. The behavior of the plugin can be controlled via [Menu bar --> Modules --> Lua commander]. It also offers its own  API functions . Additionally,  help()  will display usage tips. \n \n [Lua commander] \n \n \n \n \n \n', 'tags': '', 'url': 'commandLine.html'}, {'title': 'LuaCmdPluginAPIreference', 'text': '\n LuaCmd Plugin API reference \n API functions for LuaCommander plugin. \n simLuaCmd.clearHistory \n simLuaCmd.setArrayMaxItemsDisplayed \n simLuaCmd.setAutoAcceptCommonCompletionPrefix \n simLuaCmd.setDynamicCompletion \n simLuaCmd.setEnabled \n simLuaCmd.setFloatPrecision \n simLuaCmd.setHistoryRemoveDups \n simLuaCmd.setHistorySize \n simLuaCmd.setHistorySkipRepeated \n simLuaCmd.setMapMaxDepth \n simLuaCmd.setMapShadowBufferStrings \n simLuaCmd.setMapShadowLongStrings \n simLuaCmd.setMapShadowSpecialStrings \n simLuaCmd.setMapSortKeysByName \n simLuaCmd.setMapSortKeysByType \n simLuaCmd.setPrintAllReturnedValues \n simLuaCmd.setResizeStatusbarWhenFocused \n simLuaCmd.setShowMatchingHistory \n simLuaCmd.setStringEscapeSpecials \n simLuaCmd.setStringLongLimit \n simLuaCmd.setWarnAboutMultipleReturnedValues \n \n \n \n simLuaCmd.clearHistory\n \n \n \n                                                    Description\n                                                 \n Clear command history \n \n \n Lua synopsis \n simLuaCmd.clearHistory() \n \n \n \n Lua parameters \n - \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.clearHistory() \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setArrayMaxItemsDisplayed\n \n \n \n                                                    Description\n                                                 \n Set the maximum number of items displayed when rendering an array \n \n \n Lua synopsis \n simLuaCmd.setArrayMaxItemsDisplayed(int n) \n \n \n \n Lua parameters \n \n n  (int): the maximum number of items \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setArrayMaxItemsDisplayed(int n) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setAutoAcceptCommonCompletionPrefix\n \n \n \n                                                    Description\n                                                 \n If all completions have a common prefix, that is automatically accepted if this option is set to true \n \n \n Lua synopsis \n simLuaCmd.setAutoAcceptCommonCompletionPrefix(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, common prefix is accepted \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setAutoAcceptCommonCompletionPrefix(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setDynamicCompletion\n \n \n \n                                                    Description\n                                                 \n Complete words using the selected script \n \n \n Lua synopsis \n simLuaCmd.setDynamicCompletion(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, dynamic completion will be used \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setDynamicCompletion(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setEnabled\n \n \n \n                                                    Description\n                                                 \n Enable/disable the plugin (i.e. show or hide the UI) \n \n \n Lua synopsis \n simLuaCmd.setEnabled(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, plugin is enabled \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setEnabled(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setFloatPrecision\n \n \n \n                                                    Description\n                                                 \n Number of significative digits to show \n \n \n Lua synopsis \n simLuaCmd.setFloatPrecision(int n) \n \n \n \n Lua parameters \n \n n  (int): number of significative digits \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setFloatPrecision(int n) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setHistoryRemoveDups\n \n \n \n                                                    Description\n                                                 \n Skip saving duplicate entries in command history \n \n \n Lua synopsis \n simLuaCmd.setHistoryRemoveDups(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, no duplicate entries will be saved \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setHistoryRemoveDups(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setHistorySize\n \n \n \n                                                    Description\n                                                 \n Maximum number of items to store in command history \n \n \n Lua synopsis \n simLuaCmd.setHistorySize(int n) \n \n \n \n Lua parameters \n \n n  (int): number of items \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setHistorySize(int n) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setHistorySkipRepeated\n \n \n \n                                                    Description\n                                                 \n Skip saving repeated entries in command history \n \n \n Lua synopsis \n simLuaCmd.setHistorySkipRepeated(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, more than one identical consecutive entries will not be saved \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setHistorySkipRepeated(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setMapMaxDepth\n \n \n \n                                                    Description\n                                                 \n Set map maximum rendering depth (use -1 for unlimited) \n \n \n Lua synopsis \n simLuaCmd.setMapMaxDepth(int n) \n \n \n \n Lua parameters \n \n n  (int): maximum depth \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setMapMaxDepth(int n) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setMapShadowBufferStrings\n \n \n \n                                                    Description\n                                                 \n Buffer strings (containing null chars) will be replaced by a placeholder \n \n \n Lua synopsis \n simLuaCmd.setMapShadowBufferStrings(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, buffer strings will be replaced by a placeholder \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setMapShadowBufferStrings(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setMapShadowLongStrings\n \n \n \n                                                    Description\n                                                 \n Long strings will be replaced by a placeholder \n \n \n Lua synopsis \n simLuaCmd.setMapShadowLongStrings(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, long strings will be replaced by a placeholder \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setMapShadowLongStrings(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setMapShadowSpecialStrings\n \n \n \n                                                    Description\n                                                 \n Strings containing special characters will be replaced by a placeholder \n \n \n Lua synopsis \n simLuaCmd.setMapShadowSpecialStrings(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, strings containing special characters will be replaced by a placeholder \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setMapShadowSpecialStrings(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setMapSortKeysByName\n \n \n \n                                                    Description\n                                                 \n Sort map keys by name \n \n \n Lua synopsis \n simLuaCmd.setMapSortKeysByName(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, map keys will be sorted by name \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setMapSortKeysByName(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setMapSortKeysByType\n \n \n \n                                                    Description\n                                                 \n Sort map keys by type \n \n \n Lua synopsis \n simLuaCmd.setMapSortKeysByType(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, map keys will be sorted by type \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setMapSortKeysByType(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setPrintAllReturnedValues\n \n \n \n                                                    Description\n                                                 \n Set whether to print all the returned values or only the first \n \n \n Lua synopsis \n simLuaCmd.setPrintAllReturnedValues(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, all returned values will be printed \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setPrintAllReturnedValues(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setResizeStatusbarWhenFocused\n \n \n \n                                                    Description\n                                                 \n Save alternative statusbar size for when the commander has the focus \n \n \n Lua synopsis \n simLuaCmd.setResizeStatusbarWhenFocused(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, alternate size will be used when widget has focus \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setResizeStatusbarWhenFocused(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setShowMatchingHistory\n \n \n \n                                                    Description\n                                                 \n History entries beginning with current buffer will be shown in preview. Use UP arrow to navigate matching entries. \n \n \n Lua synopsis \n simLuaCmd.setShowMatchingHistory(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, matching entries are shown \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setShowMatchingHistory(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setStringEscapeSpecials\n \n \n \n                                                    Description\n                                                 \n Escape special characters in strings \n \n \n Lua synopsis \n simLuaCmd.setStringEscapeSpecials(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, special characters will be escaped \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setStringEscapeSpecials(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setStringLongLimit\n \n \n \n                                                    Description\n                                                 \n Set the length threshold for strings \n \n \n Lua synopsis \n simLuaCmd.setStringLongLimit(int n) \n \n \n \n Lua parameters \n \n n  (int): the string length threshold \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setStringLongLimit(int n) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simLuaCmd.setWarnAboutMultipleReturnedValues\n \n \n \n                                                    Description\n                                                 \n Set whether to print a warning is there are multiple returned values, and only one value is displayed \n \n \n Lua synopsis \n simLuaCmd.setWarnAboutMultipleReturnedValues(bool b) \n \n \n \n Lua parameters \n \n b  (bool): if true, warning will be emitted \n \n \n Lua return values \n - \n \n \n Python synopsis \n simLuaCmd.setWarnAboutMultipleReturnedValues(bool b) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'LuaCmdPluginAPIreference.html'}, {'title': 'miscellaneousFunctionality', 'text': '\n \n \n \n \n Miscellaneous functionality \n Since CoppeliaSim can easily be extended via a  plugin  or an  add-on , the scope of functionality that can be achieved is virtually unlimited. Following plugin also ship with CoppeliaSim: \n CGAL plugin  (surface reconstruction). \n ICP plugin  (point cloud matching). \n Subprocess plugin  (launch and handle subprocesses). \n \n \n \n \n', 'tags': '', 'url': 'miscellaneousFunctionality.html'}, {'title': 'SurfRecPluginAPIreference', 'text': "\n SurfRec Plugin API reference \n API functions for surface reconstruction from point clouds \n simSurfRec.reconstruct_scale_space \n \n \n \n simSurfRec.reconstruct_scale_space\n \n \n \n                                                    Description\n                                                 \n Reconstruct a mesh from the given point cloud \n \n \n Lua synopsis \n int \nshapeHandle=simSurfRec.reconstruct_scale_space(int pointCloudHandle, int\n iterations=4, int neighbors=12, int samples=300, float \nsquared_radius=-1.0) \n \n \n \n Lua parameters \n \n \n pointCloudHandle  (int): handle of the point cloud \n \n iterations  (int, default: 4): number of iterations \n \n neighbors  (int, default: 12): number of neighbors a point's neighborhood should contain on average \n \n samples  (int, default: 300): number of points sampled to estimate the neighborhood radius \n \n squared_radius  (float, default: -1.0): neighborhood \nsquared radius used for principal component analysis. if this is \npositive, neighbors and samples will be ignored \n \n \n \n Lua return values \n \n shapeHandle  (int): handle of the shape with the reconstructed mesh, or -1 if failed \n \n \n Python synopsis \n int \nshapeHandle=simSurfRec.reconstruct_scale_space(int pointCloudHandle, int\n iterations=4, int neighbors=12, int samples=300, float \nsquared_radius=-1.0) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n \n \n ,  ,  ,  , ", 'tags': '', 'url': 'SurfRecPluginAPIreference.html'}, {'title': 'ICPPluginAPIreference', 'text': '\n ICP Plugin API reference \n \n simICP.match \n simICP.matchToShape \n \n \n \n simICP.match\n \n \n \n                                                    Description\n                                                 \n Match two point clouds. \n \n \n Lua synopsis \n float[] m=simICP.match(int model_handle, int template_handle, float outlier_treshold=-1) \n \n \n \n Lua parameters \n \n \n model_handle  (int): handle to model point cloud (model will be the static part) \n \n template_handle  (int): handle to template point cloud (template will be the part to register to the model) \n \n outlier_treshold  (float, default: -1): outlier treshold (-1 = no treshold) \n \n \n \n Lua return values \n \n m  (table of float): transformation matrix (12 elements) \n \n \n Python synopsis \n list m=simICP.match(int model_handle, int template_handle, float outlier_treshold=-1) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simICP.matchToShape\n \n \n \n                                                    Description\n                                                 \n Match point clouds to shape. \n \n \n Lua synopsis \n float[] m=simICP.matchToShape(int model_handle, int template_handle, float outlier_treshold=-1) \n \n \n \n Lua parameters \n \n \n model_handle  (int): handle to model shape (model will be the static part) \n \n template_handle  (int): handle to template point cloud (template will be the part to register to the model) \n \n outlier_treshold  (float, default: -1): outlier treshold (-1 = no treshold) \n \n \n \n Lua return values \n \n m  (table of float): transformation matrix (12 elements) \n \n \n Python synopsis \n list m=simICP.matchToShape(int model_handle, int template_handle, float outlier_treshold=-1) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'ICPPluginAPIreference.html'}, {'title': 'SubprocessPluginAPIreference', 'text': '\n Subprocess Plugin API reference \n API functions for subprocess \n simSubprocess.exec \n simSubprocess.execAsync \n simSubprocess.isRunning \n simSubprocess.kill \n simSubprocess.wait \n \n \n \n simSubprocess.exec\n \n \n \n                                                    Description\n                                                 \n Execute a subprocess. \n \n \n Lua synopsis \n int exitCode, string output=simSubprocess.exec(string programPath, string[] args, string input="", exec_opts opts={}) \n \n \n \n Lua parameters \n \n \n programPath  (string): Program path. \n \n args  (table of string): Program arguments. \n \n input  (string, default: ""): Data passed to stdin. \n \n opts  (exec_opts, default: {}): Options. see  exec_opts \n \n \n \n \n Lua return values \n \n \n exitCode  (int):  \n \n output  (string):  \n \n \n \n Python synopsis \n int exitCode, string output=simSubprocess.exec(string programPath, list args, string input="", exec_opts opts={}) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simSubprocess.execAsync\n \n \n \n                                                    Description\n                                                 \n Execute a subprocess without waiting for termination. \n \n \n Lua synopsis \n string handle=simSubprocess.execAsync(string programPath, string[] args, exec_opts opts={}) \n \n \n \n Lua parameters \n \n \n programPath  (string): Program path. \n \n args  (table of string): Program arguments. \n \n opts  (exec_opts, default: {}): Options. see  exec_opts \n \n \n \n \n Lua return values \n \n handle  (string):  \n \n \n Python synopsis \n string handle=simSubprocess.execAsync(string programPath, list args, exec_opts opts={}) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simSubprocess.isRunning\n \n \n \n                                                    Description\n                                                 \n Check wether a subprocess previously launched with  simSubprocess.execAsync  is running. \n \n \n Lua synopsis \n bool running=simSubprocess.isRunning(string handle) \n \n \n \n Lua parameters \n \n handle  (string):  \n \n \n Lua return values \n \n running  (bool):  \n \n \n Python synopsis \n bool running=simSubprocess.isRunning(string handle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simSubprocess.kill\n \n \n \n                                                    Description\n                                                 \n Forcefully terminate a subprocess previously launched with  simSubprocess.execAsync . \n \n \n Lua synopsis \n int exitCode=simSubprocess.kill(string handle) \n \n \n \n Lua parameters \n \n handle  (string):  \n \n \n Lua return values \n \n exitCode  (int):  \n \n \n Python synopsis \n int exitCode=simSubprocess.kill(string handle) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n simSubprocess.wait\n \n \n \n                                                    Description\n                                                 \n Wait for termination of a subprocess previously launched with  simSubprocess.execAsync . If subprocess terminates, the exit code is returned. \n \n \n Lua synopsis \n int exitCode=simSubprocess.wait(string handle, float timeout=5) \n \n \n \n Lua parameters \n \n \n handle  (string):  \n \n timeout  (float, default: 5):  \n \n \n \n Lua return values \n \n exitCode  (int):  \n \n \n Python synopsis \n int exitCode=simSubprocess.wait(string handle, float timeout=5) \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n \n Data structures \n Data structures are used to pass complex data around. Create data structures in Lua in the form of a map, e.g.:  {line_size=3, add_to_legend=false, selectable=true} \n \n exec_opts\n \n \n \n                                                Description\n                                             \n \n \n \n Fields \n \n \n useSearchPath  (bool, default: true): Resolve program name searching in PATH entries. \n \n openNewConsole  (bool, default: false): Win32-specific flag. \n \n \n \n \n                                                See also\n                                             \n \n \n \n \n \n \n ,  ,  ,  , ', 'tags': '', 'url': 'SubprocessPluginAPIreference.html'}, {'title': 'writingCode', 'text': '\n \n \n \n \n Writing code in and around CoppeliaSim \n CoppeliaSim is a highly customizable simulator: every aspect of a  simulation  can be customized. Moreover, the simulator itself can be customized and tailored so as to behave exactly as desired. This is allowed through an elaborate  Application Programming Interface  (API). 6+ different programming or coding approaches are supported, each having particular advantages (and obviously also disadvantages) over the others, but all six are mutually compatible (i.e. can be used at the same time, or even hand-in-hand). The control entity of a  model ,  scene , or the simulator itself can be located inside: \n an  embedded script  (i.e. customizing a simulation (i.e. a  scene  or  models ) via scripting): this method, which consists in writing  Lua  or  Python  scripts, is very easy and flexible, with guaranteed compatibility with every other default CoppeliaSim installations (as long as customized API functions are not used, or are used with distributed  plugins ). This method allows customizing a particular simulation, a simulation scene, and to a certain extent the simulator itself. This is the easiest and most used programming approach. \n an  add-on  or  the sandbox script : this method, which consists in writing Lua or Python scripts, allows to quickly customize the simulator itself. Add-ons (or the sandbox script) can start automatically and run in the background, or they can be called as functions (e.g. convenient when writing importers/exporters). Add-ons should not be  specific to a certain simulation or model, they should rather offer a more generic, simulator-bound functionality. \n a  plugin  (i.e. customizing the simulator and/or a simulation via a plugin): this method basically consists in writing a plugin for CoppeliaSim.  Oftentimes, plugins are only used to provide a simulation with  customized API commands , and so are used in conjunction with the first method. Other times, plugins are used to provide CoppeliaSim with a special functionality requiring either fast calculation capability (scripts are most of the time slower than compiled languages),  a specific  interface to a hardware device (e.g. a real robot), or a special communication interface with the outside world. \n a  remote API  client (i.e. customizing the simulator and/or a simulation via a remote API client application): this method allows an external application (e.g. located on a robot, another machine, etc.) to connect to CoppeliaSim in a very easy way, using remote API commands. \n a  ROS node  (i.e. customizing the simulator and/or a simulation via a ROS node): this method allows an external application (e.g. located on a robot, another machine, etc.) to connect to CoppeliaSim via  ROS , the Robot Operating System. \n a node talking  TCP/IP ,  ZeroMQ , etc.: this method allows an external application (e.g. located on a robot, another machine, etc.) to connect to CoppeliaSim via various communication means. \n \nAbove 6 methods are also discussed in the  external controller tutorial . Following table describes in detail the respective advantages and disadvantages of each method:\n \n \n [Possible control methods in and around CoppeliaSim] \n \n \n \n \n \n', 'tags': '', 'url': 'writingCode.html'}, {'title': 'scripts', 'text': "\n \n \n \n \n Scripts \n CoppeliaSim is a highly customizable simulator: almost every step of a  simulation  is user-defined. Additionally, the simulator itself can also be customized to a large extent. This flexibility is allowed through an integrated script interpreter ( Lua ) and an external script interpreter ( Python ). Both operate in almost the same fashion,  except for small differences . For more information on Lua, refer to the  Lua crash course  section and the  online documentation . \n \n [Lua and Python logo] \n \n CoppeliaSim extends Lua's and Python's API function and adds CoppeliaSim specific commands that can be recognized by their  sim -prefixes (e.g.  sim.getObjectPosition ). For a list of all CoppeliaSim specific API functions, refer to the  regular API . New, customized API functions can also be registered from a  plugin . Refer to the  related API-functions  for more information. \n \n Several types of scripts are supported in CoppeliaSim:  the sandbox script ,  add-ons , and  embedded scripts  (themselves composed of a  main script ,  child scripts  and  customization scripts ). An embedded script is a script that is embedded in a  scene  (or  model ), i.e. a script that is part of the scene and that will be saved and loaded together with the rest of the scene (or model). On the other hand, the sandbox script and add-ons are not associated with any specific scene, model or object, and will run across all scenes in a similar way.  \n \n [Script types] \n \n Scripts are invoked via  callback functions  by CoppeliaSim, and follow a  specific execution order . They can  run threaded or non-threaded . \n CoppeliaSim scripts may be published under any license. \n \n \n \n \n", 'tags': '', 'url': 'scripts.html'}, {'title': 'embeddedScripts', 'text': "\n \n \n \n \n Embedded scripts \n CoppeliaSim supports, next to  the sandbox script  and  add-ons , also embedded scripts: an embedded script is a script that is embedded in a  scene  (or  model ), i.e. a script that is part of the scene and that will be saved and loaded together with the rest of the scene (or model). There are different types of embedded scripts that are supported. Each type has specific features and application areas: \n \n [Embedded script types] \n \n Two major types of embedded scripts are supported:  \n Simulation scripts : simulation scripts are scripts that are executed only during simulation, and that are used to customize a simulation or a simulation model. The main simulation loop is handled via the  main script , and models/robots can be controlled via  child scripts . \n Customization scripts : those are scripts that can also be executed while simulation is not running, and that are used to customize a simulation scene or a specific model. \n \n It is useful to remember that some script types are associated with  scene objects  (attached to scene objects, i.e.  associated  scripts) such as child scripts and customization scripts. Associated scripts, which form the basis of CoppeliaSim's distributed control architecture, share the convenient property to be automatically duplicated if their associated object is duplicated. \n Embedded scripts, and all scripts in general, are invoked via  callback functions  by CoppeliaSim, and follow a  specific execution order . They can  run threaded or non-threaded . \n \n \n \n \n", 'tags': '', 'url': 'embeddedScripts.html'}, {'title': 'simulationScripts', 'text': "\n \n \n \n \n Simulation scripts \n Simulation  scripts  play the central role in a simulation, and are only executed while a simulation is running. There two types of simulation scripts:  \n The main script : by default, each  scene  has a main script that handles all the functionality (that is is charge of calling child scripts (see hereafter)). Without main script, a  simulation  cannot run. The main script can be customized, but it is preferable to do all the customization work in child scripts. \n \n Child scripts : each  scene object  can be associated with a child script that can handle a specific part of a simulation. The most common use for a child script is to have it control a  model  (e.g. a robot). Since child scripts  are attached to scene objects (i.e. they are  associated  scripts), they will also be duplicated during a copy-and-paste operation, which is an important feature that allows a simulation scene to be easily scalable.  Associated  scripts form the basis of CoppeliaSim's distributed control architecture. \n Following are the main differences between the main script and a child script: \n there can only be one main script. There can be an unlimited number of child scripts. \n the main script is independent and should preferably not be customized. Child scripts are associated with scene objects and should be customized. \n the main script is never duplicated in a copy/paste operation of scene objects. Child scripts will duplicate themselves together with their associated scene object. \n child scripts support a few more  callback functions  than the main script. \n Simulation scripts, and all scripts in general, are mainly invoked via  system callback functions  by CoppeliaSim, and follow a precise  execution order  in relation with other script types. They can  run threaded or non-threaded . \n \n \n \n \n", 'tags': '', 'url': 'simulationScripts.html'}, {'title': 'mainScript', 'text': "\n \n \n \n \n The main script  \n A main script is a  simulation script . By default, each  scene  in CoppeliaSim will have one main script. It contains the basic code that allows a  simulation  to run. Without main script, a running simulation won't do anything. \n The main script contains a collection of  callbacks functions  that are appropriately called by the system. Except for the initialization callback, all other callbacks are optional. The default main script is typically segmented in 4  callback functions:  \n the initialization function:  sysCall_init . This callback function is not optional. It will be executed one time just at the beginning of a simulation. The code is in charge of preparing a simulation, etc. \n \n the actuation function:  sysCall_actuation . This callback function will be executed in each simulation pass. The code is in charge of handling all the actuation functionality of the simulation. One command is of particular interest:  sim.handleChildScripts , which calls  child scripts'   sysCall_actuation  callback functions. Without that commands,  child scripts  won't execute, or won't execute their actuation function, and specific  model  functionality or behavior won't operate as intended.   \n \n the sensing function:  sysCall_sensing . This callback function will be executed in each simulation pass. The code is in charge of handling all the sensing functionality of the simulation ( proximity sensors , etc.) in a generic way. One command is of particular interest:  sim.handleChildScripts , which  calls  child scripts'   sysCall_sensing  callback functions. Without that commands,  child scripts  won't  execute their sensing function, and specific  model  functionality or behavior won't operate as intended. \n \n the restoration function:  sysCall_cleanup . This function will be executed one time just before a simulation ends. The code is in charge of restoring  object's  initial configuration, clearing sensor states, etc. \n \n \nFollowing is the typical main script, slightly simplified:\n \n \nfunction  sysCall_init ()\n    -- Initialization part:\nend\n\nfunction  sysCall_actuation ()\n    -- Actuation part:\n    sim.handleChildScripts(sim.syscb_actuation)\n    sim.handleCustomizationScripts(sim.syscb_actuation)\n    sim.handleAddOnScripts(sim.syscb_actuation)\n    sim.handleSandboxScript(sim.syscb_actuation)\n    sim.handleJointMotion()\n    sim.handleDynamics(sim.getSimulationTimeStep())\nend\n\nfunction  sysCall_sensing ()\n    -- Sensing part:\n    sim.handleSensingStart()\n    sim.handleProximitySensor(sim.handle_all_except_explicit)\n    sim.handleVisionSensor(sim.handle_all_except_explicit)\n    sim.handleChildScripts(sim.syscb_sensing)\n    sim.handleCustomizationScripts(sim.syscb_sensing)\n    sim.handleAddOnScripts(sim.syscb_sensing)\n    sim.handleSandboxScript(sim.syscb_sensing)\nend\n\nfunction  sysCall_cleanup ()\n    -- Clean-up part:\n    sim.handleChildScripts(sim.syscb_cleanup)\n    sim.resetProximitySensor(sim.handle_all_except_explicit)\n    sim.resetVisionSensor(sim.handle_all_except_explicit)\nend\n\nfunction  sysCall_suspend ()\n    sim.handleChildScripts(sim.syscb_suspend)\n    sim.handleCustomizationScripts(sim.syscb_suspend)\n    sim.handleAddOnScripts(sim.syscb_suspend)\n    sim.handleSandboxScript(sim.syscb_suspend)\nend\n\nfunction  sysCall_suspended ()\n    sim.handleChildScripts(sim.syscb_suspended)\n    sim.handleCustomizationScripts(sim.syscb_suspended)\n    sim.handleAddOnScripts(sim.syscb_suspended)\n    sim.handleSandboxScript(sim.syscb_suspended)\nend\n\nfunction  sysCall_resume ()\n    sim.handleChildScripts(sim.syscb_resume)\n    sim.handleCustomizationScripts(sim.syscb_resume)\n    sim.handleAddOnScripts(sim.syscb_resume)\n    sim.handleSandboxScript(sim.syscb_resume)\nend \n There are however many more  system callback functions  the main script can use to react to various events. \n The main script is not supposed to be modified. The reason for this is following: one of CoppeliaSim's strength is that any  model  (robot, actuator, sensor, etc) can be copied into a  scene  and is immediately operational. When modifying the main script, you run the risk that models won't perform as expected anymore (e.g. if your main script lacks the command sim.handleChildScripts then all models copied into the scene won't operate at all). Another reason is that keeping a default main script allows old scenes to easily adjust for new functionality (e.g. if a new CoppeliaSim version introduces a neat command sim.doMagic(), then old scenes will automatically be updated to have that command also called in their main script). \n \n If however, for a reason or another you really need to modify the main script of a scene, you can do this by double-clicking the light-red script icon next to the world icon at the top of the  scene hierarchy : \n \n \n [Main script icon] \n \n Most of child script's system callback functions are called from the main script, via the  sim.handleChildScripts  function, which  operates in a cascading fashion  upon the scene hierarchy and the child scripts attached to  individual scene object.  \n If you look at the default main script, you can notice that the actuation function allows actuating or modifying the scene content (e.g. sim.handleDynamics, etc.), while the sensing function allows sensing and probing the scene content (e.g. sim.handleProximitySensor, etc.). Following illustrates what happens in the default main script when a mobile robot equipped with a  proximity sensor  is simulated: \n \n \n [Default actuation - sensing - display sequence] \n \n With above's sequence in mind,  child scripts  will always read (with  sim.readProximitySensor ) the proximity sensor's state from previous sensing (which happened at the end of previous simulation pass, inside of the main script, with  sim.handleProximitySensor ), then react to obstacles. \n If you need to explicitely handle a sensor, then make sure to always do it while in the sensing section, otherwise you might end-up with situations where the display appears wrong as illustrated in following figure: \n \n \n [Sensing - actuation - display sequence] \n \n As does the main script have an actuation-sensing sequence, so do  child scripts . \n \n \n \n \n", 'tags': '', 'url': 'mainScript.html'}, {'title': 'childScripts', 'text': "\n \n \n \n \n Child scripts  \n A child script is a  simulation script . CoppeliaSim supports an unlimited number of child scripts per  scene . Each child script represents a small collection of routines allowing handling a particular function in a  simulation . Child scripts are attached to (or  associated with )  scene objects , and they can be easily recognized from their script icon in the  scene hierarchy : \n \n [A child script associated with object  Robot ] \n Double-clicking the script icon allows opening the  script editor . You can change properties of a given script via the  script dialog . You can attach a new child script to an object by selecting the object, then navigating to [menu bar --> Add --> Associated child script].  \n   A child script's association with a scene object has important and positive consequences:  \n Very good portability : child scripts will be saved/loaded together with their associated object. Using child scripts, you are able to create extremely portable code and simulation  models  that do not need to rely on any system specific plugin. A fully functional model can be contained in a single file (usable without modification across various platforms), which is not the case when relying on  plugins  for model control. Additionally, and for the same reason, models relying on child scripts require no maintenance over time (e.g. a new OS version will not require you to adjust portions of code or recompilation, as you might have to do when using  plugins ). \n Inherent scalability : if an object that has an attached child script is duplicated, its child script will also be duplicated. The duplicated child script's content will be identical to the original child script's content, however, the duplicated child script will  know  that is was duplicated and redirect object access correctly, if relative paths were used for object access. Refer to the section on  accessing scene objects programmatically  for more details. \n No conflict between different model versions : if you modify the child script of a given model (e.g. to customize it to your needs), this will have no consequence on other similar models. This is a much more critical aspect when relying on  plugins  instead of child scripts for model control: indeed, with plugins you always run the risk of having conflicts with previous plugin versions. \n Very easy synchronization with the simulation loop : child scripts can run  threaded or non-threaded , and can be easily synchronized with the simulation loop, which represents a powerful feature. \n Child scripts can run  threaded or non-threaded code . Since they only run when simulation is running, they should exclusively be used to handle simulation-time tasks. \n As do other script types, child scripts should mainly contain a collection of functions. The entrance functions are   callback functions . Functions that are not  running threaded  (i.e. that are not running in a coroutine) should not be blocking. This means that every time they are called, they should perform some task and then return control. If control is not returned, then the whole  simulation  halts. Child script functions are called by the  main script  at least twice per simulation step from the main script's actuation and sensing functions. The system will also call other  system callback functions  where appropriate (e.g. during child script initialization, clean-up, etc).  \n Child scripts also follow a  precise calling or execution order : by default, child scripts are called starting with leaf objects (or childless objects), and ending with root objects (or parentless objects). A child script is typically segmented into a collection of  system callback functions , the most important ones are:  \n the initialization function:  sysCall_init . This system callback function is the only one that is not optional. It will be executed just one time (the first time the child script is called). This can be at the beginning of a simulation, but also in the middle of a simulation: remember that objects associated with child scripts can be copy/pasted into a  scene  at any time, also when a simulation is running. Usually you would put some initialization code as well as handle retrieval in this part. Or, if your code is meant to run threaded, then you would prepare one or several  coroutines  in that part. \n \n the actuation function:  sysCall_actuation . This part will be executed in each simulation step, during the actuation phase of a simulation step. Refer to the  main script  default code for more details about the actuation phase, but typically, you would do some actuation in this part (no sensing). Or, if an actuation function is meant to run threaded, then you would resume the coroutine of that function in that part. \n \n the sensing function:  sysCall_sensing . This part will be executed in each simulation step, during the sensing phase of a simulation step. Refer to the  main script  default code for more details about the sensing phase, but typically, you would only do sensing in this part (no actuation). Or, if a sensing function is meant to run threaded, then you would resume the coroutine of that function in that part. \n \n the restoration function:  sysCall_cleanup . This part will be executed one time just before a simulation ends, or before the script is destroyed.  \n \n \n \n \n", 'tags': '', 'url': 'childScripts.html'}, {'title': 'customizationScripts', 'text': "\n \n \n \n \n Customization scripts  \n Customization scripts are  embedded scripts  that can be used to customize a simulation scene to a great extent. They are attached to (or  associated with )  scene objects , and they can be easily recognized from their dark script icon in the  scene hierarchy : \n \n [A customization script associated with object  Robot ] \n Double-clicking the script icon allows opening the  script editor . You can change properties of a given script, or associate it with another object via the  script dialog . You can attach a new customization script to an object by selecting the object, then navigating to [menu bar --> Add --> Associated customization script].  \n Following are customization script's main properties: \n they are executed all the time (within a same scene): when simulation is running, as well as when simulation is not running. \n they are attached to (or associated with) scene objects (i.e. they are  associated  scripts). Associated scripts form the basis of CoppeliaSim's distributed control architecture, and share the convenient property to be automatically duplicated if their associated object is duplicated.  \n Above properties allow customization scripts to share some of the best features of  add-ons  and  child scripts . Customization scripts allow the creation of customizable models for instance: imagine a  model  that was dropped into a scene, and that is able to configure or adapt itself, even when simulation is not running. This could be a robot where the user can adjust the various link lengths with a single slider repositioning. \n Customization scripts should contain a collection of  callback functions . Those should not be blocking. This means that every time they are called, they should perform some task and then return control. If control is not returned, then the whole application halts. Customization script functions are called by the system often, but also by the  main script , and follow a precise  execution order  in relation with other script types.  \n A customization script can  run threaded or non-threaded , and should be segmented in several  system callback functions . If possible, do not use customization scripts to run simulation code, which is anyway best handled via  child scripts . \n \n \n \n \n", 'tags': '', 'url': 'customizationScripts.html'}, {'title': 'scriptProperties', 'text': '\n \n \n \n \n Script dialog \n The script dialog is located at [Menu bar --> Tools --> Scripts]. Alternatively, it can also be accessed through its toolbar button: \n \n \n [Script toolbar button] \n \n \n [Script dialog] \n \n Script listing : all scripts that are loaded. Scripts can be removed by using the delete-key. A double-click opens the script in the  script editor . A script can also be opened with a double-click on a script icon in the  scene hierarchy . \n \n Disabled : indicates whether the script is enabled or disabled. For a given  model , it is also possible to disable all of its child- and customization scripts in the  model dialog . \n \n Execution priority : specifies the execution priority for a script. The execution priority relates only to same-type scripts, and only to scripts that are siblings in the scene hierarchy. More details can be found  here .  \n Tree traveral : specifies when a script is executed, in relation to the scripts attached further down in the scene hierarchy (its  descendants scripts ). With  reverse , the descendant scripts are first executed, with  forward , the descendant scripts are executed last.  Same as parent  uses the same tree traversal as the first ancestor script. The tree traversal relates only to same-type scripts. More details can be found  here .  \n \n \n \n \n', 'tags': '', 'url': 'scriptProperties.html'}, {'title': 'scriptEditor', 'text': '\n \n \n \n \n Script editor \n The script editor allows editing the various scripts in CoppeliaSim. It is opened by double-clicking a script in the  script dialog , or by double-clicking a script icon in the  scene hierarchy . \n \n \n [Script editor] \n \n The script editor has following features that make the code edition easier: \n auto-completion \n call tips \n syntax highlighting \n Highlighting of all occurrences of the selected word \n source folding/unfolding \n search and replace function \n no need for explicit saving \n jump to specific function \n undo/redo \n inspection/edition of included files \n open of the documentation for the API function/constant under the mouse pointer, via the context menu \n The API functions can easily be accessed by typing the first 3 letters (usually  sim ). When a script was modified, there is no need to explicitly save the changes: closing the script editor, saving the scene or starting a  simulation  will automatically apply the changes to the script. When a simulation is running, modifications to a given script will only take effect once a new simulation run is started. The user can also explicitely restart/reset a given script, for changes to take immediately effect. \n If you have recurring functions you wish to access from a given script, or if you simply wish to run code from an external file, you can do this with following for a Lua script: \n \nrequire "myExternalLuaFile"\n \n and for a Python script: \n \n#pythonWrapper(myExternalLuaFile)  \n \n In that case, make sure the file is named  myExternalLuaFile.lua  or  myExternalLuaFile.py , and do not forget to distribute it together with your scene or model, since that code will not be part of a CoppeliaSim file anymore. Searched path are usually following: \n <CoppeliaSim executable>/ \n <CoppeliaSim executable>/lua/ \n <CoppeliaSim executable>/python/ \n <current scene path>/ \n <additional search path>/  (this path can be specified with variable  additionalLuaPath  in file  system/usrset.txt ) \n Files included via the  require  directive can be opened in the same script editor by opening the popup menu over the file name. \n \n \n \n \n', 'tags': '', 'url': 'scriptEditor.html'}, {'title': 'addOns', 'text': '\n \n \n \n \n Add-ons \n An add-on is a  script  running in CoppeliaSim, that can act in a similar way as a  plugin :\nit is automatically loaded at program start-up, and allows CoppeliaSim\'s\nfunctionality to be extended by user-written functionality or\nfunctions; it persists across all opened scenes, and is executed\nconstantly, effectively running in the\nbackground. Add-ons can run  threaded or non-threaded , should be segmented into several  system callback functions , and follow a precise  execution order  in relation with other script types. They share a lot of properties with  the sandbox script . \n Add-ons should be written in a text file located in the\n  same folder as the main application, with following naming convention:  simAddOnXXXX.lua  (even add-ons containing Python code). Add-ons that do not follow above naming convention can still be loaded and run via  command line options . \n By default, add-ons will automatically start when CoppeliaSim starts, e.g.: \n \nfunction sysCall_init()\n    print("Executing the initialization section. Starting together with CoppeliaSim")\nend\n\nfunction sysCall_addOnScriptSuspend()     print("Ending... (triggered by the user)")\n    return {cmd=\'cleanup\'} -- end this add-on. The cleanup section will be called end\n\nfunction sysCall_cleanup()\n    print("Executing the clean-up section")\nend \n \n An add-on can also be manually started and stopped from the add-on menu (Lua only), e.g.: \n \nfunction sysCall_info()     return {autoStart=false} end\n\nfunction sysCall_init()\n    print("Executing the initialization section. Start triggered by the user")\nend\n\nfunction sysCall_addOnScriptSuspend()     print("Ending... (triggered by the user)")\n    return {cmd=\'cleanup\'} -- end this add-on. end\n \n \n An add-on can also be suspended/resumed from the add-on menu, e.g.: \n ...\n\nfunction sysCall_addOnScriptSuspend()     print("Suspending the add-on... (triggered by the user)")\nend\n\nfunction sysCall_addOnScriptResume()     print("Resuming the add-on... (triggered by the user)")\nend\n\n... \n \n An add-on can also act as a simple function triggered by the user (Lua only), e.g.: \n \nfunction sysCall_info()     return {autoStart=false} end\n\nfunction sysCall_init()\n    print("Executing the initialization section. Start triggered by the user")\n    -- execute some functions here, e.g. import something\n    return {cmd=\'cleanup\'} -- end this add-on.\nend \n \n An add-on can also display a customized name in the Modules\' menu (Lua only), e.g.: \n \nfunction sysCall_info()     return {menu=\'Exporters//My exporter\'} end\n \n \n For more information about add-ons, have a look at the add-ons located in the installation folder. \n \n \n \n \n', 'tags': '', 'url': 'addOns.html'}, {'title': 'sandboxScript', 'text': "\n \n \n \n \n The sandbox script \n The sandbox script is quite similar to an  add-on :\nit is automatically loaded at program start-up, and allows CoppeliaSim's\nfunctionality to be extended by user-written functionality or\nfunctions. In addition to that, the sandbox script is extensively used in CoppeliaSim's  Lua commander plugin (read-eval-print loop), that adds a text input to the CoppeliaSim status bar, allowing entering and executing code on the fly, like in a terminal. It is persistent across all opened scenes, and is executed\nconstantly, effectively running in the\nbackground. For that reason, it should only execute minimalistic code everytime called, since the whole application would otherwise slow down.\nThe sandbox script is called via  system callback functions , and follows a precise  execution order  in relation with other script types. \n The sandbox script is loaded from  system/sndbxscpt.txt  at start-up, can run  threaded or non-threaded , and should be segmented into several  system callback functions .  \n \n \n \n \n", 'tags': '', 'url': 'sandboxScript.html'}, {'title': 'scriptExecution', 'text': "\n \n \n \n \n Script execution order \n Scripts  are not executed in a random fashion: script type, script location and script settings can influence when (in relation to others) a script is being executed. A simple rule to remember is: the more  important  or  persistent  a script is, the later it will be called/executed.  \n Execution order is first based on script type. We have following order, from first executed to last executed: \n child scripts  are called \n customization scripts  are called \n add-on scripts  are called \n the sandbox script  is called \n Because child scripts are  simulation scripts , they will only run as long as the simulation is running (i.e. they are not  persistent ). This is not the case  with customization scripts, add-ons and the sandbox script, which run also after a simulation stop. Additionally, add-ons and the sandbox script also continue to run when switching to a different scene. Above sequence makes sense since  important  scripts can be designed to rely and operate on data produced by less  important  scripts. \n  As an example, the callback  sysCall_sensing  will be called in following sequence: first in child scripts, then in customization scripts, in add-ons, and finally in the sandbox script. \n Within a script type, the execution order is a function of a script's position in the scene hierarchy, and its following 2  script settings : \n Execution priority : specifies the execution priority for a script. The execution priority relates only to same-type scripts, and only to scripts that are siblings in the scene hierarchy.  \n \n [Script execution order based on  execution priority  setting] \n Tree traveral : specifies when a script is executed, in relation to the scripts attached further down in the scene hierarchy (its  descendants scripts ). With  reverse , the descendant scripts are first executed, with  forward , the descendant scripts are executed last.  Same as parent  uses the same tree traversal as the first ancestor script. The tree traversal relates only to same-type scripts. Default is  reverse . \n \n [Script execution order based on  tree traversal  setting] \n  Following diagram illustrates a concret example scene: \n \n [Example scene and child script execution order] \n \n \n \n \n", 'tags': '', 'url': 'scriptExecution.html'}, {'title': 'threadedAndNonThreadedCode', 'text': "\n \n \n \n \n Threaded and non-threaded script code \n Any type of script can run  threaded  and/or  non-threaded  script functions.  \n \n Non-threaded code\n \n The entrance to a script is always originating from  callback functions  which are not running threaded, and should not be blocking. This means that every time they are called, they should perform some task and then return control. If control is not returned, then CoppeliaSim will halt.  \n Non-threaded code is inherently synchronized  with the simulation loop. \n While non-threaded Lua code executes in the same thread as CoppeliaSim and is thus quite efficient, non-threaded Python code operates in a slightly different manner: CoppeliaSim will launch a new process which will connect to CoppeliaSim via socket communication. Everything happens  under the hood , the main difference is however that Python code will start and run slower than Lua code. See also the other  differences between Lua and Python scripts . \n \n \n Threaded code\n \n In a Lua script, threading is achieved via  coroutines , that CoppeliaSim will preemptively interrupt (i.e. yield, or switch) at regular intervals, and resume at a later point.  \n On the other hand, CoppeliaSim will handle threading of a Python script by launching a new process which will connect to CoppeliaSim via socket communication, which happens  under the hood , the main difference is however that Python code will start slower than Lua code. See also the other  differences between Lua and Python scripts . \n In the context of threaded code, we will refer to  threads  and  coroutines ,  interrupt ,  yield  and  switch , in an interchangeable manner. \n \xa0 \n Lua specific \n Lua threaded code has several weaknesses compared to Lua non-threaded code if not programmed appropriately: it can waste some processing time. Following shows a typical threaded function in a Lua script (i.e.  coroutineMain ), which however is not perfect since  it is wasting precious computation time  in the loop: \n \n \nfunction sysCall_init()\n    corout=coroutine.create(coroutineMain) -- create the coroutine\nend\n\nfunction sysCall_actuation()\n    if coroutine.status(corout)~='dead' then\n        local ok,errorMsg=coroutine.resume(corout) -- resume the coroutine\n        if errorMsg then\n            error(debug.traceback(corout,errorMsg),2)\n        end\n    end\nend\n\nfunction coroutineMain()\n    while true do\n        print('simulation time: ',sim.getSimulationTime())\n    end\nend \n By default a Lua threaded code section will execute for about 1-2 milliseconds before automatically interrupting or  switching  and giving control back to the caller. This default behavior can be changed with the  sim.setThreadSwitchTiming  or  sim.setThreadAutomaticSwitch . Once the current thread was switched, it will resume next time the coroutine is resumed (which often is in next simulation step. The thread switching is automatic and is handled by CoppeliaSim (occurs after the specified time), but the  sim.switchThread  command allows to explicitely switch when needed. Using above three commands, a perfect synchronization with the main simulation loop can be achieved. Following Lua code shows code synchronization with the main simulation loop: \n \n \nfunction sysCall_init()\n    sim.setThreadAutomaticSwitch(false) -- forbid automatic switches\n    corout=coroutine.create(coroutineMain)\nend\n\nfunction sysCall_actuation()\n    if coroutine.status(corout)~='dead' then\n        local ok,errorMsg=coroutine.resume(corout)\n        if errorMsg then\n            error(debug.traceback(corout,errorMsg),2)\n        end\n    end\nend\n\nfunction coroutineMain()\n    while true do\n        print('simulation time: ',sim.getSimulationTime())\n        sim.switchThread() -- resume in next simulation step\n    end\nend \n Above while loop will now execute exactly once for each main simulation step and not waste time reading and printing the simulation time over and over for same the simulation step.\n \n \xa0 \n Python specific \n Python threaded code shares similar properties as Lua threaded code, regarding synchronization with CoppeliaSim's simulation loop. Following shows a typical threaded function in a Python script (i.e.  threadMain ), which is not synchronized: \n \n#python\n\ndef sysCall_thread():\n    sim.setThreadAutomaticSwitch(True) # allow automatic switches\n    while sim.getThreadExitRequest() == False:\n        print('simulation time: '+str(sim.getSimulationTime()))\n \n By default, a Python threaded code section will operate in a  stepped fashion , but this can be changed with  sim.setThreadAutomaticSwitch (True) and  sim.switchThread . Once the current thread was switched, it will resume in next simulation step. Following Python code shows code synchronization with the main simulation loop: \n \n#python\n\ndef sysCall_thread():\n    sim.setThreadAutomaticSwitch(False) # forbid automatic switches\n    while sim.getThreadExitRequest() == False:\n        print('simulation time: '+str(sim.getSimulationTime()))\n        sim.switchThread() # resume in next simulation step\n \n Above while loop will now execute exactly once for each main simulation step and not waste time reading and printing the simulation time over and over for the same simulation step.\n \n \xa0 \n With threads in general, some operation should not be interrupted in order to execute correctly (imagine moving several objects in a loop). In that case, you can temporarily forbid thread switches with the  sim.setThreadAutomaticSwitch  function. \n Finally, several  blocking functions  are specifically meant to be running from within threaded code, e.g.  sim.moveToConfig : those functions will handle thread switching for you, at the appropriate time, in order to operate hand-in-hand,  stepped ,  with the simulation loop. \n \n \n \n \n", 'tags': '', 'url': 'threadedAndNonThreadedCode.html'}, {'title': 'callbackFunctions', 'text': '\n \n \n \n \n Callback functions \n Callbacks or callback functions are script functions that are triggered by a specific event. They represent the only entrance into script code. They can be categorized into user callbacks, and system callbacks: \n user callback functions are directly triggered by user code, or a plugin. This happens for instance when the user calls a script function in a different script via  sim.callScriptFunction , or when the user clicks a  custom UI  button, which triggers a custom event. User callback functions can usually run in  any type of script . \n system callback functions on the other hand are triggered by CoppeliaSim when a certain event happens, for instance when a script is initialized, or before switching to another scene. System callback functions have fixed function names, such as  sysCall_init  or  sysCall_beforeInstanceSwitch . Not all system callback functions can be handled by all types of scripts, e.g. some can only run in an  add-on  (e.g.  sysCall_addOnScriptSuspend ). \n While most system callback functions operate in a relatively straight-forward manner and are easy to understand (see further down for a complete list of system callback functions), some require a little bit more explanations: \n Dynamics callback functions  are called by the physics engine  before and after each dynamics simulation step. \n The  contact callback function  is called by the physics engine for each contact pair. \n Joint callback functions  are called by the physics engine for custom joint control. \n Vision callback functions  are called whenever an new image is acquires or applied. \n Trigger callback functions  are called when a certain trigger event is fired. \n User config callback functions  are called when the user double-clicks a user parameter icon. \n \n Following is a list of all supported system callback functions. Most support returning {cmd=\'cleanup\'} or {cmd=\'restart\'} to end or restart the script. Refer to the comments in the code below for details about individual functions: \n \nfunction  sysCall_info ()\n    -- Lua only. Can be used to specify initial configuration data. E.g. in case of an add-on: \n    return {autoStart=false,menu=\'menu1\\nmenu2\\nadd-on name\',menuEnabled=true}\nend\n\nfunction  sysCall_init ()\n    -- Do some initialization here. \n    -- Either sysCall_init or sysCall_thread is required with Python scripts.\nend\n\nfunction  sysCall_thread ()\n    -- Python only. Entry point for threaded scripts.\n    -- Either sysCall_thread or sysCall_init is required.\nend\n\nfunction  sysCall_cleanup ()\n    -- Do some clean-up here.\nend\n\nfunction  sysCall_nonSimulation ()\n    -- Is executed when simulation is not running. \n    -- Not for  simulation scripts .\nend\n\nfunction  sysCall_beforeSimulation ()\n    -- Simulation is about to start. \n    -- Not for  simulation scripts .\nend\n\nfunction  sysCall_afterSimulation ()\n    -- Simulation has just ended. \n    -- Not for  simulation scripts .\nend\n\nfunction  sysCall_actuation ()\n    -- Put some actuation code here.\nend\n\nfunction  sysCall_sensing ()\n    -- Put some sensing code here.\nend\n\nfunction  sysCall_suspend ()\n    -- Simulation is about to be suspended.\nend\n\nfunction  sysCall_suspended ()\n    -- Simulation is suspended.\nend\n\nfunction  sysCall_resume ()\n    -- Simulation is about to resume.\nend\n\nfunction  sysCall_realTimeIdle ()\n    -- Is executed when idle in real-time mode\nend\n\nfunction  sysCall_beforeInstanceSwitch ()\n    -- About to switch to another scene.\n    -- Not for  simulation scripts .\nend\n\nfunction  sysCall_afterInstanceSwitch ()\n    -- Switched to another scene. \n    -- Not for  simulation scripts .\nend\n\nfunction  sysCall_beforeSave ()\n    -- About to save the scene, or about to set an undo/redo point\nend\n\nfunction  sysCall_afterSave ()\n    -- After the scene was saved , or after an undo/redo point was set\nend\n\nfunction  sysCall_beforeCopy (inData)\n    -- Before one or several objects will be copied. Can be reentrant. Disabled by default for Python.\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..key.." will be copied")\n    end\nend\n\nfunction  sysCall_afterCopy (inData)\n    -- After one or several objects were copied. Can be reentrant. Disabled by default for Python.\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..key.." was copied")\n    end\nend\n\nfunction  sysCall_afterCreate (inData)\n    -- After one or several objects were created. Can be reentrant. Disabled by default for Python.\n    for i,#inData.objectHandles,1 do\n        print("Object with handle "..inData.objectHandles[i].." was created")\n    end\nend\n\nfunction  sysCall_beforeDelete (inData)\n    -- Before one or several objects will be deleted. Can be reentrant. Disabled by default for Python.\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..key.." will be deleted")\n    end\n    -- inData.allObjects indicates if all objects in the scene will be deleted\nend\n\nfunction  sysCall_afterDelete (inData)\n    -- After one or several objects were deleted. Can be reentrant. Disabled by default for Python.\n    for key,value in pairs(inData.objectHandles) do\n        print("Object with handle "..key.." was deleted")\n    end\n    -- inData.allObjects indicates if all objects in the scene were deleted\nend\n\n function  sysCall_beforeMainScript ()\n    -- Lua only. Can be used to step a simulation in a custom manner.\n    local outData={doNotRunMainScript=false} -- when true, then the main script won\'t be executed\n    return outData\nend\n\nfunction  sysCall_addOnScriptSuspend ()\n    -- Add-on script execution is about to be suspended.\n    -- Only for  add-on scripts .\nend\n\nfunction  sysCall_addOnScriptResume ()\n    -- Add-on script execution is about to be resumed.\n    -- Only for  add-on scripts .\nend\n\nfunction  sysCall_dynCallback (inData)\n    -- See the  dynamics callback function  section for details. Disabled by default for Python.\n    -- Only for  customization scripts  and  child scripts .\nend\n\nfunction  sysCall_jointCallback (inData)\n    -- See the  joint callback function  section for details. Disabled by default for Python.\n    -- Only for  customization scripts  and  child scripts .\n    return outData\nend\n\nfunction  sysCall_contactCallback (inData)\n    -- See the  contact callback function  section for details. Disabled by default for Python.\n    -- Only for  customization scripts  and  child scripts .\n    return outData\nend\n\nfunction  sysCall_vision (inData)\n    -- See the  vision callback function  section for details. Disabled by default for Python.\n    -- Only for  customization scripts  and  child scripts .\n    return outData\nend\n\nfunction  sysCall_trigger (inData)\n    -- See the  trigger callback function  section for details. Disabled by default for Python.\n    -- Only for  customization scripts  and  child scripts .\n    return outData\nend\n\nfunction  sysCall_userConfig ()\n    -- See the  user config callback function  section for details.\n    -- Only for  customization scripts .\nend\n\n function  sysCall_moduleEntry (inData)\n    -- Called when a user module menu entry is selected, e.g.\n    print(\'Following module menu entry was selected: \'..inData.handle)\n    -- See the  sim.moduleEntry  for details.\nend\n\n function  sysCall_msg (message,origin)\n    -- Synchronously called when  sim.broadcastMsg  is called. Can be reentrant. Disabled by default for Python. \nend\n\n function  sysCall_event (inData)\n    -- Called when something (mainly visual for now) changes. Can be reentrant. Disabled by default for Python. \n    -- Mainly used to synchronize an external viewer/renderer with CoppeliaSim.\n    -- See also  sim.getGenesisEvents \nend\n\n function  sysCall_ext (string funcName,inData)\n    -- Lua only. When this function is present, then all external calls to a script function, i.e. user callbacks,\n    -- will be intercepted (the original function will be shadowed). If only monitoring is desired,\n    -- then one should use  sim.registerScriptFuncHook  on this function.\nend \n \n \n \n \n', 'tags': '', 'url': 'callbackFunctions.html'}, {'title': 'dynCallbackFunctions', 'text': '\n \n \n \n \n Dynamics callback functions \n Child script s, or  customization scripts  can include a dynamics callback function, which is one of many  system callback functions . When present, then the physics engine will call the callback function with appropriate arguments, before and after each dynamics simulation step. The dynamics callback function might be called quite often, normally 10*2 times per simulation step (remember that the physics engine time step, by default, is 10 times smaller that the simulation time step). For that reason, keep things simple, in order to avoid slowing down the simulation. \n Following represents a simple dynamics  callback function: \n \n \nfunction  sysCall_dynCallback (inData)\n    -- This function gets called often, so it might slow down the simulation\n    --     (this is called twice at each dynamic simulation step, by default 20x more often than a child script)\n    -- We have:\n    -- inData.passCnt : the current dynamics calculation pass. 1-10 by default. See next item for details.\n    -- inData.totalPasses : the number of dynamics calculation passes for each "regular" simulation pass.\n    --                      10 by default (i.e. 10*5ms=50ms which is the default simulation time step)\n    -- inData.dynStepSize : the step size used for the dynamics calculations (by default 5ms)\n    -- inData.afterStep :  false  when called before, and  true  after a dynamics step was computed.\n\n    local txt=string.format(" the %ith dynamics calculation step (out of %i steps)",inData.passCnt,inData.totalPasses)\n    if inData.afterStep then\n        txt="After"..txt\n    else\n        txt="Before"..txt\n    end\n    print(txt)\nend \n In Python, a dynamics callback function can only be implemented via a non-threaded script, and it should be explicitly activated with a luaExec command: \n \n#python\n#luaExec additionalFuncs={\'sysCall_dynCallback\'}\n\ndef  sysCall_dynCallback (inData):\n    pass \n \n \n \n \n', 'tags': '', 'url': 'dynCallbackFunctions.html'}, {'title': 'jointCallbackFunctions', 'text': '\n \n \n \n \n Joint callback functions \n Child script s, or  customization scripts  can include a joint callback function, which is one of many  system callback functions . When present for a given joint, then it will be called by CoppeliaSim in various situations:  \n When the joint is in kinematic mode: a call to  sim.setJointTargetPosition  or  sim.setJointTargetVelocity  will trigger the joint callback function. If not present in a script attached to the given joint, then the call will be redirected to the  main script  that offers a default behaviour, i.e. a specific motion profile will be applied \n When the joint is in dynamic mode, is  dynamically enabled , and is set to custom control: the physics engine will trigger the joint callback function for each dynamics simulation step, which is quite often, normally 10 times per simulation step for a given joint \n  Joint callback functions enable the user to customize the control loop for specific joints in order to write low-level control algorithms. \n Following represents a simple PID joint callback function, for a joint in dynamic mode: \n \n \nfunction  sysCall_jointCallback (inData)\n    -- inData.mode : sim.jointmode_kinematic or sim.jointmode_dynamic\n    --\n    -- inData.handle : the handle of the joint associated with this script\n    -- inData.revolute : whether the joint associated with this script is revolute or prismatic\n    -- inData.cyclic : whether the joint associated with this script is cyclic or not\n    -- inData.lowLimit : the lower limit of the joint associated with this script (if the joint is not cyclic)\n    -- inData.highLimit : the higher limit of the joint associated with this script (if the joint is not cyclic)\n    -- inData.currentPos : the current position\n    -- inData.targetPos : the desired position (if joint is dynamic, or when sim.setJointTargetPosition was called)\n    -- inData.targetVel : the desired velocity (if joint is dynamic, or when sim.setJointTargetVelocity was called)\n    -- inData.initVel : the desired initial velocity (if joint is kinematic and when sim.setJointTargetVelocity\n    --                  was called with a 4th argument)\n    -- inData.errorValue : targetPos-currentPos (with revolute cyclic joints, the shortest cyclic distance)\n    -- inData.maxVel : a maximum velocity, taken from sim.setJointTargetPosition or \n    --                 sim.setJointTargetVelocity\'s 3rd argument)\n    -- inData.maxAccel : a maximum acceleration, taken from sim.setJointTargetPosition or\n    --                   sim.setJointTargetVelocity\'s 3rd argument)\n    -- inData.maxJerk : a maximum jerk, taken from sim.setJointTargetPosition or\n    --                  sim.setJointTargetVelocity\'s 3rd argument)\n    -- inData.first : whether this is the first call from the physics engine, since the joint\n    --                was initialized (or re-initialized) in it.\n    -- inData.passCnt : the current dynamics calculation pass. 1-10 by default\n    -- inData.totalPasses : the number of dynamics calculation passes for each "regular" simulation pass.\n    -- inData.effort : the last force or torque that acted on this joint along/around its axis. With Bullet,\n    --                 torques from joint limits are not taken into account\n    -- inData.dynStepSize : the step size used for the dynamics calculations (by default 5ms)\n    -- inData.force : the joint force/torque, as set via sim.setJointTargetForce\n    -- inData.velUpperLimit : the joint velocity upper limit\n\n    if inData.first then\n        PID_P=0.1\n        PID_I=0\n        PID_D=0\n        pidCumulativeErrorForIntegralParam=0\n    end\n    \n    -- The control happens here:\n    -- 1. Proportional part:\n    local ctrl=inData.errorValue*PID_P\n    \n    -- 2. Integral part:\n    if PID_I~=0 then\n        pidCumulativeErrorForIntegralParam=pidCumulativeErrorForIntegralParam+inData.errorValue*inData.dynStepSize\n    else\n        pidCumulativeErrorForIntegralParam=0\n    end\n    ctrl=ctrl+pidCumulativeErrorForIntegralParam*PID_I\n    \n    -- 3. Derivative part:\n    if not inData.first then\n        ctrl=ctrl+(inData.errorValue-pidLastErrorForDerivativeParam)*PID_D/inData.dynStepSize\n    end\n    pidLastErrorForDerivativeParam=inData.errorValue\n    \n    -- 4. Calculate the velocity needed to reach the position in one dynamic time step:\n    local maxVelocity=ctrl/inData.dynStepSize -- max. velocity allowed.\n    if (maxVelocity>inData.velUpperLimit) then\n        maxVelocity=inData.velUpperLimit\n    end\n    if (maxVelocity<-inData.velUpperLimit) then\n        maxVelocity=-inData.velUpperLimit\n    end\n    local forceOrTorqueToApply=inData.maxForce -- the maximum force/torque that the joint will be able to exert\n\n    -- 5. Following data must be returned to CoppeliaSim:\n    firstPass=false\n    local outData={}\n    outData.velocity=maxVelocity\n    outData.force=forceOrTorqueToApply\n    return outData\n    \n    -- Expected return data:\n    -- For kinematic joints:\n    -- outData={position=pos, velocity=vel, immobile=false}\n    -- \n    -- For dynamic joints:\n    -- outData={force=f, velocity=vel}\nend \n In Python, a joint callback function can only be implemented via a non-threaded script, and it should be explicitly activated with a luaExec command: \n \n#python\n#luaExec additionalFuncs={\'sysCall_jointCallback\'}\n\ndef  sysCall_jointCallback (inData):\n    pass \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'jointCallbackFunctions.html'}, {'title': 'contactCallbackFunction', 'text': "\n \n \n \n \n The contact callback function \n Child script s, or  customization scripts  can include  a contact callback function, which is one of many  system callback functions . When present, and the physics engine detected a collision between two  respondable  shapes, then the contact callback function will be called with appropriate arguments, allowing the user to customize the handling of contacts. The contact callback function might be called very often, sometimes more than several hundred  times per simulation step (remember also that by default, the physics engine will be called 10 times for one simulation step). For that reason, keep things simple, in order to avoid slowing down the simulation. \n Following represents a typical contact callback function: \n \n \nfunction  sysCall_contactCallback (inData)\n    -- Will objects with inData.handle1 and inData.handle2 respond to dynamic collision?\n    local retData={}\n    retData.ignoreContact=false -- handle contact here\n    retData.collisionResponse=true -- shapes will collide\n\n    if inData.engine==sim.physics_bullet then\n        retData.bullet={}\n        retData.bullet.friction=0\n        retData.bullet.restitution=0\n    end\n\n    if inData.engine==sim.physics_ode then\n        retData.ode={}\n        retData.ode.maxContacts=16\n        retData.ode.mu=0\n        retData.ode.mu2=0\n        retData.ode.bounce=0\n        retData.ode.bounceVel=0\n        retData.ode.softCfm=0\n        retData.ode.softErp=0\n        retData.ode.motion1=0\n        retData.ode.motion2=0\n        retData.ode.motionN=0\n        retData.ode.slip1=0\n        retData.ode.slip2=0\n        retData.ode.fDir1={0,0,0}\n        local mode=1 -- bit-coded. See below\n        -- 1=dContactMu2\n        -- 2=dContactFDir1\n        -- 4=dContactBounce\n        -- 8=dContactSoftERP\n        -- 16=dContactSoftCFM\n        -- 32=dContactMotion1\n        -- 64=dContactMotion2\n        -- 128=dContactSlip1\n        -- 256=dContactSlip2\n        -- 512=dContactApprox1_1\n        -- 1024=dContactApprox1_2\n        -- 2048=dContactApprox1\n        retData.ode.contactMode=mode\n    end\n\n    if inData.engine==sim.physics_vortex then\n    end\n\n    if inData.engine==sim.physics_newton then\n        retData.newton={}\n        retData.newton.staticFriction=0\n        retData.newton.kineticFriction=0\n        retData.newton.restitution=0\n    end\n\n    return(retData)\nend \n In Python, a contact callback function can only be implemented via a non-threaded script, and it should be explicitly activated with a luaExec command: \n \n#python\n#luaExec additionalFuncs={'sysCall_contactCallback'}\n\ndef  sysCall_contactCallback (inData):\n    pass \n \n \n \n \n", 'tags': '', 'url': 'contactCallbackFunction.html'}, {'title': 'visionCallbackFunctions', 'text': "\n \n \n \n \n Vision callback functions \n Child script s, or  customization scripts  can include a vision callback function (which is one of many  system callback functions ), when associated with a  vision sensor . When present for a given vision sensor, then the system will call the callback function everytime a new image was acquired or applied, allowing the user to perform image processing. This is the case with following API functions:  sim.handleVisionSensor ,  sim.checkVisionSensor ,  sim.checkVisionSensorEx , and  sim.setVisionSensorImg . \n Some conditions apply as to the location of the vision callback function: if a vision callback function is present in a child script as well as in a customization script, both attached to the vision sensor, then the child script will be called first, and the customization script second. \n Following represents an empty  vision callback function: \n \n \nfunction  sysCall_vision (inData)\n    -- We have:\n    -- inData.handle : the handle of the vision sensor.\n    -- inData.resolution : the x/y resolution of the vision sensor\n    -- inData.clippingPlanes : the near and far clipping planes of the vision sensor\n    -- inData.viewAngle : the view angle of the vision sensor (if in persp. proj. mode)\n    -- inData.orthoSize : the ortho size of the vision sensor (if in orth. proj. mode)\n    -- inData.perspectiveOperation : true if the sensor is in persp. proj. mode\n\n    local outData={}\n    outData.trigger=false -- true if the sensor should trigger\n    outData.packedPackets={} -- a table of packed packets. Can be accessed via e.g. sim.readVisionSensor\n    return outData\nend\n \n \n Image processing can be performed by using various API functions. The  vision plugin  exports a few very simple image processing functions. Many more image processing functions are supported via the  image plugin  (OpenCV wrapper). \n Following represents a simple edge detection vision callback function, that triggers and returns a packet of data  (based on the vision plugin functions): \n \n \nfunction  sysCall_vision (inData)\n    simVision.sensorImgToWorkImg(inData.handle)\n    simVision.edgeDetectionOnWorkImg(inData.handle,0.1)\n    simVision.workImgToSensorImg(inData.handle)\n\n    local outData={}\n    outData.trigger=true\n    local packetData={1.0,42.123,129.3}\n    outData.packedPackets={sim.packFloatTable(packetData)}\n    return outData\nend\n \n \n Following represents a vision callback function, that draws a circle onto the acquired image (based on the image plugin functions): \n \n \nfunction  sysCall_vision (inData)\n    local imgHandle=simIM.readFromVisionSensor(inData.handle)\n    local center={inData.resolution[1]/2,inData.resolution[2]/2}\n    local radius=(inData.resolution[1]+inData.resolution[2])/8\n    simIM.circle(imgHandle,center,radius,{255,0,255},4)\n    simIM.writeToVisionSensor(imgHandle,inData.handle)\n    simIM.destroy(imgHandle)\nend \n In Python, a vision callback function can only be implemented via a non-threaded script, and it should be explicitly activated with a luaExec command: \n \n#python\n#luaExec additionalFuncs={'sysCall_vision'}\n\ndef  sysCall_vision (inData):\n    pass \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'visionCallbackFunctions.html'}, {'title': 'triggerCallbackFunctions', 'text': "\n \n \n \n \n Trigger callback functions \n Child script s, or  customization scripts  can include a trigger callback function (which is one of many  system callback functions ), when associated with a  vision sensor  or a  proximity sensor .  \n Some conditions apply as to the location of the trigger callback function: if a trigger callback function is present in a child script as well as in a customization script, both attached to the object triggering, then the child script will be called first, and the customization script second. \n A vision sensor can generate the trigger signal inside of the  vision callback function . The trigger callback (if present) is then called as in following example: \n \n \nfunction  sysCall_trigger (inData)\n    -- We have:\n    -- inData.handle : the handle of the vision sensor.\n    -- inData.packedPackets : an array of data packets, packed (use sim.unpackFloatTable to unpack)\n    --    the first data packet always contains 15 auxiliary values about the acquired image:\n    --    - minimum of {intensity, red, green blue and depth value}\n    --    - maximum of {intensity, red, green blue and depth value}\n    --    - average of {intensity, red, green blue and depth value}\n\n    local outData={}\n    outData.trigger=true\n    return outData\nend\n \n \n A proximity sensor generates the trigger signal when an object is detected. The trigger callback (if present) is then called as in following example: \n \nfunction  sysCall_trigger (inData)\n    -- We have:\n    -- inData.handle : the handle of the proximity sensor.\n    -- inData.detectedObjectHandle : handle of detected object\n    -- inData.detectedPoint : detected point, relative to sensor frame\n    -- inData.normalVector : normal vector at detected point, relative to sensor frame\n\n    local outData={}\n    outData.trigger=true\n    return outData\nend\n \n \n In Python, a trigger callback function can only be implemented via a non-threaded script, and it should be explicitly activated with a luaExec command: \n \n#python\n#luaExec additionalFuncs={'sysCall_trigger'}\n\ndef  sysCall_trigger (inData):\n    pass \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'triggerCallbackFunctions.html'}, {'title': 'userConfigCallbackFunctions', 'text': '\n \n \n \n \n User config callback functions \n A  customization script  that includes a user config callback function (which is one of many  system callback functions ), will display a configuration dialog icon, in the scene hierarchy: \n \n [Configuration dialog icon] \n \n  When double-cliked, the user config callback function is triggered. This can be used as a convenient way of displaying a  custom user interface  to the user, that is specific to the  object / model  the customization script is attached to. User data can be read and written to objects with  sim.readCustomDataBlock / sim.writeCustomDataBlock  for instance: \n \n [Custom configuration dialog] \n \n \nfunction sysCall_init()\n    modelHandle=sim.getObject(\'.\')\nend\n\nfunction sysCall_userConfig()\n    local xml =[[<ui title="Robot" closeable="true" modal="true" layout="form" on-close="customUiClosed">\n            <label text="Max. velocity:" />\n            <edit id="1" value="-" on-editing-finished="velocityChanged"/>\n            <label text="Max. acceleration:" />\n            <edit id="2" value="-" on-editing-finished="accelerationChanged"/>\n    </ui>]]\n    local ui=simUI.create(xml)\n    local data=readData()\n    simUI.setEditValue(ui,1,tostring(data.maxVel))\n    simUI.setEditValue(ui,2,tostring(data.maxAccel))\nend\n\nfunction customUiClosed(ui)\n    simUI.destroy(ui)\nend\n\nfunction velocityChanged(ui,id,val)\n    local data=readData()\n    val=tonumber(val)\n    if val then\n        if val<0.1 then\n            val=0.1\n        end\n        if val>0.5 then\n            val=0.5 \n        end\n        data.maxVel=val\n    end\n    simUI.setEditValue(ui,id,tostring(data.maxVel))\n    writeData(data)\nend\n\nfunction accelerationChanged(ui,id,val)\n    local data=readData()\n    val=tonumber(val)\n    if val then\n        if val<0.01 then\n            val=0.01\n        end\n        if val>0.2 then\n            val=0.2 \n        end\n        data.maxAccel=val\n    end\n    simUI.setEditValue(ui,id,tostring(data.maxAccel))\n    writeData(data)\nend\n\nfunction readData()\n    local data=sim.readCustomDataBlock(modelHandle,\'RobotParams\')\n    if data then\n        data=sim.unpackTable(data)\n    else\n        data={}\n        data.maxVel=0.2\n        data.maxAccel=0.05\n    end\n    return data\nend\n\nfunction writeData(data)\n    sim.writeCustomDataBlock(modelHandle,\'RobotParams\',sim.packTable(data))\nend \n \n You may also use the  configUI  module for quicker set-up of custom configuration dialog, that will also automatically write data to custom data blocks: \n \n [Custom configuration dialog based on  configUI  module] \n \n \nrequire \'configUi\'\n\nfunction sysCall_init()\n    local schema={\n        floatInput={\n            default=0.1,\n            maximum=4,\n            minimum=0.05,\n            name="float input",\n            type="float",\n            ui={\n                control="spinbox",\n                tab="Tab 1",order=1,col=1\n            },\n        },\n        intInput={\n            default=1,\n            maximum=10,\n            minimum=0,\n            name="int input",\n            type="int",\n            ui={\n                control="spinbox",\n                tab="Tab 1",order=2,col=2\n            },\n        },\n        checkbox1={\n            type=\'bool\',\n            name=\'checkbox1\',\n            default=true,\n            ui={tab="Tab 1",order=3,col=1},\n        },\n        checkbox2={\n            type=\'bool\',\n            name=\'checkbox2\',\n            default=false,\n            ui={tab="Tab 1",order=4,col=2},\n        },\n        colorselect={\n            type=\'color\',\n            name=\'color select\',\n            default={1,0,1},\n            ui={tab="Tab 2",order=5,col=1,},\n        },\n        stringInput={\n            default="Hello",\n            name="string input",\n            type="string",\n            ui={\n                tab="Tab 2",order=6,col=2\n            },\n        },\n        floatSlider={\n            default=0.5,\n            maximum=1,\n            minimum=0,\n            name="float slider",\n            type="float",\n            ui={\n                control="slider",\n                tab="Tab 2",order=7,col=1\n            },\n        },\n        intSlider={\n            default=1,\n            maximum=10,\n            minimum=0,\n            name="int slider",\n            type="int",\n            ui={\n                control="slider",\n                tab="Tab 2",order=8,col=2\n            },\n        },\n        choices1={\n            default=2,\n            choices={"option 1","option 2","option 3"},\n            name="combo choices",\n            type="choices",\n            ui={\n                control="combo",\n                tab="Tab 3",order=9,col=1\n            },\n        },\n        choices2={\n            default=1,\n            choices={"option 1","option 2","option 3"},\n            name="radio choices",\n            type="choices",\n            ui={\n                control="radio",\n                tab="Tab 3",order=10,col=1\n            },\n        },\n    }\n    sim.writeCustomDataBlock(sim.getObject(\'.\'),\'__schema__\',sim.packTable(schema))\n    configUi=ConfigUI(\'myModelType\',nil,modificationCallback)\nend\n\nfunction modificationCallback(config)\n    local objectHandle=sim.getObject(\'.\')\n    local txt="Object \'"..sim.getObjectAlias(objectHandle,5).."\' just changed.\\nNew parameters are:"\n    print(txt)\n    print(config)\nend \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'userConfigCallbackFunctions.html'}, {'title': 'luaPythonDifferences', 'text': '\n \n \n \n \n Lua vs Python scripts \n The way Lua and Python scripts are handled in CoppeliaSim (next to differences related to the language itself) displays small differences, which are discussed here: \n Python scripts require a  #python  header tag as the very first instruction/comment: \n #python\n\ndef sysCall_init():\n    print("Hello world!")\n \n Lua code always executes in the same thread as CoppeliaSim and is thus quite fast. Python code on the other hand is launched in a new process, which connects to CoppeliaSim via socket communication. This implies that Python code will usually start and run slower than Lua code. \n Python scripts are handled via Lua wrapper code, which handles the launch and communication of each Python script. Auxiliary Lua code can be passed via the  luaExec  command, within a Python comment section. That code must come immediately after the  #python  header tag: \n #python\n#luaExec wrapper=\'myWrapperCode\' -- looks for myWrapperCode.lua in Lua\'s search path\n#luaExec additionalPaths={\'c:/path1\',\'c:/path2\'} -- adds additional Python module search paths\n#luaExec additionalIncludePaths={\'c:/Python38\',\'c:/path2\'} -- adds additional paths to search for the include file\n\'\'\'luaExec\nfunction myLuaFunction()\n    -- do something here\nend\n\'\'\'\n\ndef sysCall_init():\n    print("Hello world!")\n \n The import directive does not work when importing the primary Python file, and following should be used instead: \n #python\ninclude myExternalFile\n\n# myExternalFile is the pythonScript name or path (absolute or relative), without quotes nor the ending \'.py\'\n# searched paths include:\n# <CoppeliaSim executable path>/ \n# <CoppeliaSim executable path>/python \n# <current scene path>/ \n# <additional path>/ (see system/usrset.txt and value \'additionalPythonPath\')\n# additional include paths passed via #luaExec additionalIncludePaths={\'c:/Python38\'}\n \n Threaded Lua code, since implemented via coroutines, will always block while executing (i.e. CoppeliaSim won\'t handle any other task during that time). This is most of the time not noticeable, except when calling blocking functions that are foreign to CoppeliaSim. Threaded Python code on the other hand, will never block when executing, also with functions that are foreign to CoppeliaSim. \n Python threaded scripts do not have an initialization nor clean-up callback. They should thus handle initialization and clean-up within their  sysCall_thread  function: \n #python\n\ndef sysCall_thread():\n    sim.setThreadAutomaticSwitch(True)\n    # Do some initialization here, e.g.:\n    h = sim.getObject(\'/myCube\')\n    originalColor = sim.getObjectColor(h,0,sim.colorcomponent_ambient_diffuse)\n    sim.setObjectColor(h,0,sim.colorcomponent_ambient_diffuse,[1,0,0])\n    \n    # Handle the main loop here, e.g.:\n    while sim.getThreadExistRequest() == False:\n        print(sim.getObjectPosition(h,-1))\n        \n    # Do some clean-up here:\n    sim.setObjectColor(h,0,sim.colorcomponent_ambient_diffuse,originalColor)\n \n Python threaded scripts should explicitly enable thread automatic switching, otherwise CoppeliaSim will block (or wait until  sim.switchThread  is called): \n #python\n\ndef sysCall_thread():\n    sim.setThreadAutomaticSwitch(True)\n    while sim.getThreadExistRequest() == False:\n        pass\n \n Python threaded scripts will need to call a message pump (via  sim.handleExtCalls ) in order to have user callback functions to be serviced: \n #python\n\ndef sysCall_thread():\n    sim.setThreadAutomaticSwitch(True)\n    xml =\'<ui title="Custom UI"> <button text="Click me!" on-click="click_callback"/> </ui>\'\n    ui=simUI.create(xml)\n    while sim.getThreadExistRequest() == False:\n        sim.handleExtCalls()\n    simUI.destroy(ui)\n\ndef click_callback(ui,button):\n    print("button was clicked!")\n \n Lua callback functions are always reentrant, while Python callback functions are usually non-reentrant. A workaround to this is to have Lua assist Python like in following example, where Python would call a Lua function: \n #python\n\'\'\'luaExec\nfunction myLuaFunction()\n    print("Hello")\nend\n\'\'\'\n\ndef sysCall_init():\n    object=sim.getScriptInt32Param(sim.handle_self,sim.scriptintparam_objecthandle)\n    path=sim.getObjectAlias(object,1)\n    sim.callScriptFunction(\'myLuaFunction@\'+path,sim.scripttype_childscript)\n \n Some rare API functions will only be availabe in Lua, while other only in Python. \n The word  table  in the documentation refers to array-like or map-like items in Lua, while in Python, it refers to either  lists  or  dicts . \n Finally remember that Python lists have a zero-based numbering, while Lua array-like tables have a 1-based numbering. \n \n \n \n \n', 'tags': '', 'url': 'luaPythonDifferences.html'}, {'title': 'luaCrashCourse', 'text': '\n \n \n \n \n Lua crash course \n Following crash course is an extremely condensed extract from the official Lua reference manual. For more details refer to the  Lua website  and to the numerous examples contained in the demo scenes. \n \n \n \n Lexical conventions\n \n \nLua is a case sensitive language. "and", "And" or "AND" are not the same.  \n \nFollowing are Lua keywords: \n \nand       break     do        else      elseif\nend       false     for       function  if\nin        local     nil       not       or\nrepeat    return    then      true      until     while \n \nFollowing strings denote other tokens: \n \n+     -     *     /     %     ^     #\n==    ~=    <=    >=    <     >     =\n(     )     {     }     [     ]\n;     :     ,     .     ..    ... \n \nLiteral strings can be delimited by matching single or double quotes (e.g. \'hello\' or "hello")  \n \nA comment starts with a double hyphen (--) anywhere outside of a string. e.g.: \n \na=4 -- variable a is now 4! \n \n \n Types and values\n \n \nLua is a dynamically typed language which means that variables do not have types; only values do.\n \n \nThere are 8 basic types in Lua: \n \n nil        type of the value nil whose main property is to be different from any other value.\n          It usually represents the absence of a useful value\n bool    values false and true (both nil and false make a condition false;\n          any other value makes it true)\n number     both integer and floating-point numbers (has internally two distinct\n          representations: integer and float)\n string     arrays of characters (strings may contain any 8-bit character,\n          including embedded zeros)\n function   Lua functions\n userdata   can hold arbitrary C data (corresponds to a block of raw memory)\n thread     independent threads of execution used to implement coroutines\n table      arrays that can hold values of any type except nil \n \n \n Variables\n \n There are 3 kinds of variables: global variables, local variables and table fields. Any variable is assumed to be global unless explicitely declared as local \n \nBefore the first assignment to a variable, its value is nil \n Square brackets are used to index a table (e.g. value=table[x]). The first value in a table is at position 1 (and not 0 as for C arrays) \n \n \n \n Statements\n \n Lua allows multiple assignments. The syntax for assignments defines a list of variables on the left side and a list of expressions on the right side. The elements in both lists are separated by commas: \n \nx,y,z = myTable[1],myTable[2],myTable[3] \n \nRelational operators (always result in  false  or  true ) \n \n ==      equality\n ~=      negation of equality\n <       smaller than\n >       bigger than\n <=      smaller or equal than\n >=      bigger or equal than \n \n If  control structure (by example): \n \nif value1==value2 then\n    print(\'value1 and value2 are same!\')\nend \n \n For  control structure (by example): \n \nfor i=1,4,1 do -- count from 1 to 4 with increments of 1\n    print(i)\nend \n \n While  control structure (by example): \n \ni=0 while i~=4 do     i=i+1 end \n \n Repeat  control structure (by example): \n \ni=0 repeat     i=i+1 until i==4 \n \n Table  operations (by example): \n \nmyTable={\'firstValue\',2,3} -- builds a table with 3 values print(myTable[1]) -- prints the first element in the table table.insert(myTable,4) -- appends the number 4 to the table \n \nConcatenation (by example): \n \na=\' hello\' b=\' world\' c=a..b -- c contains \'hello world\' \n \nLength operator #: \n \nstringLength=#\'hello world\' tableSize=#{1,2,3,4,5}\n \n \n \n \n Bitwise operators\n \n Lua supports the following bitwise operators: \n \n&: bitwise AND\n|: bitwise OR\n~: bitwise exclusive OR\n>>: right shift\n<<: unary bitwise NOT\n~: unary bitwise NOT \n \n \n \n Coroutines or threads\n \n Coroutines are easily created and resumed with: \n \n-- Create a coroutine:\ncorout=coroutine.create(coroutineMain)\n\n-- Start/resume a coroutine:\nif coroutine.status(corout)~=\'dead\' then\n    local ok,errorMsg=coroutine.resume(corout)\n    if errorMsg then\n        error(debug.traceback(corout,errorMsg),2)\n    end\nend\n\n-- The coroutine itself:\nfunction coroutineMain()\n    while true do\n        -- some code\n    end\nend \n \n \n \n \n', 'tags': '', 'url': 'luaCrashCourse.html'}, {'title': 'plugins', 'text': '\n \n \n \n \n Plugins \n A plugin is a shared library (e.g. a dll) that is automatically loaded by CoppeliaSim\'s  main client application  at program start-up, or dynamically loaded/unloaded via  sim.loadModule / sim.unloadModule . It allows CoppeliaSim\'s functionality to be extended by user-written functions (in a similar way as with  add-ons ). The language can be any language able to generate a shared library and able to call exported C-functions (e.g. in the case of Java, refer to  GCJ  and  IKVM ). A plugin can also be used as a  wrapper  for running code written in other languages or even written for other microcontrollers (e.g. a plugin was written that handles and executes code for Atmel microcontrollers). \n \n Plugins are usually used to customize the simulator and/or a particular simulation. Often, plugins are only used to provide a simulation with  custom script commands , and so are used in conjunction with  scripts . Other times, plugins are used to provide CoppeliaSim with a special functionality requiring either fast calculation capability (scripts are most of the times slower than compiled languages) or an interface to a hardware device (e.g. a real robot). \n \n Each plugin is required to have following 3 entry point procedures: \n \n \nextern "C" __declspec(dllexport) unsigned char simStart(void* reserved,int reservedInt); extern "C" __declspec(dllexport) void simEnd(); extern "C" __declspec(dllexport) void* simMessage(int message,int* auxiliaryData,void* customData,int* replyData);\n \n If one procedure is missing then the plugin will be unloaded and won\'t be operational. Refer to the  console window  at start-up for the loading status of plugins. Following briefly describes above three entry point purpose: \n \n \n \n simStart\n \n This procedure will be called one time just after the main client application loaded the plugin. The procedure should: \n \n check whether the version of CoppeliaSim is same or higher than the one that was used to develop the plugin (just make sure all commands you use in the plugin are supported!). \n \n allocate memory, and prepare GUI related initialization work (if required). \n \n \nregister custom script functions (if required).\n \n \nregister custom script variables (if required) .\n \n return the version number of this plugin if initialization was successful, otherwise 0. If 0 is returned, the plugin is unloaded and won\'t be operational. Due to backward compatibility, the version number is limited to values between 1 and 255. To overcome this limitation, one can additionaly also use following API functions:  simSetModuleInfo  /  simGetModuleInfo . \n \n \n \n \n simEnd\n \n This procedure will be called one time just before the simulation loop exits. The procedure should release all resources reserved since  simStart  was called. \n \n \n \n simMessage\n \n This procedure will be called very often while the simulator is running. The procedure is in charge of monitoring messages of interest and reacting to them. It is important to react to following events (best by intercepting the  sim_message_eventcallback_instancepass  message) depending on your plugin\'s task: \n When objects were created, destroyed, scaled, or when models are loaded: make sure you reflect the change in the plugin (i.e. synchronize the plugin with the scene content) \n When scenes were loaded or the undo/redo functionality called: make sure you erase and reconstruct all plugin objects that are linked to the scene content \n When the scene was switched: make sure you erase and reconstruct all plugin objects that are linked to the scene content. In addition to this, remember that a scene switch will discard handles of following items: \n signals \n drawing objects \n etc. \n When the simulator is in an edit mode: make sure you disable any "special functionality" provided by the plugin, until the edit mode was ended. In particular, make sure you do not programmatically select  scene objects . \n When a simulation was launched: make sure you initialize your plugin elements if needed \n When a simulation ended: make sure you release any memory and plugin elements that are only required during simulation \n When the object selection state was changed, or a dialog refresh message was sent: make sure you actualize the dialogs that the plugin displays \n Refer to the messages of type  sim_message_eventcallback_  for more details. When writing plugins several additional points have to be observed or taken into account:\n \n Plugins have to be put into the same directory as the  main client application  and respect following naming:  simExtXXXX.dll  (Windows),  libsimExtXXXX.dylib  (Mac OSX),  libsimExtXXXX.so  (Linux), where  XXXX  is the name of the plugin. Use at least 4 characters and don\'t use underscores since the plugin would be ignored (however you should use underscores when your plugin itself loads some additional libraries (e.g. language resources like  simExtXXXX_de.dll , etc.)). \n \n When registering customized script functions or script variables, use a prefix and stick to it for all functions and variables that the module registers (e.g.  simLab.testMemory() ,  simLab.errorValue , etc.). \n \n  Threads created in the plugin should be used very carefully, and should never call any simulator command (use them for background calculations or communication with hardware).\n \n When outputting messages, use  simAddLog . \n You are free to compile your plugin with whatever compiler you wish. If, however, you wish to write a Qt plugin (i.e. a plugin using the Qt framework) you should remember following: \n You are required to compile the plugin with the  same Qt version as the one used to compile CoppeliaSim. Have a look at the CoppeliaSim [Help --> About] menu bar item for details about Qt version \n You should compile the plugin with the same compiler as  CoppeliaSim \n \nFor more information on plugins, refer to following  repositories:\n \n simExtPluginSkeleton : represents a plugin template that you can use to create your own plugin. See also  simExtSkel \n \n simExtVision : a plugin that handles specific vision tasks (e.g. simulation of the Velodyne sensor, or simulation of an omnidirectional camera). \n \n simExtBubbleRob : illustrates how to add customized script functions and how to handle several specific  models . Refer also to the  related plugin tutorial . \n \n simExtK3 : the plugin related to the KheperaIII model. \n \n simExtROS : the ROS package allowing you to build the  ROS Interface  for CoppeliaSim.  \n simExtROS2 : the ROS 2 package allowing you to build the  ROS 2 Interface  for CoppeliaSim. \n simExtMTB : illustrates a Qt plugin which  integrates a robot language interpreter (or other emulator) into CoppeliaSim. Refer also to its  related tutorial .\n \n \n CoppeliaSim plugins may be published under any license. \n \n \n \n \n', 'tags': '', 'url': 'plugins.html'}, {'title': 'mainClientApplication', 'text': "\n \n \n \n \n The main client application \n CoppeliaSim is a function library: without main client application (or  main application , or  main loop ), CoppeliaSim cannot run. The default main client application that comes with the installation package is  coppeliaSim.exe  (Windows), or  coppeliaSim  (MacOSX and Linux). Beware that under MacOSX, the client application as well as several other items (e.g. libraries) are contained inside of a package or bundle ( coppeliaSim.app ):  coppeliaSim.app/Contents/MacOS/coppeliaSim . \n The main client application is a small executable that handles following main tasks: \n \n \nit runs the simulator with  simRunSimulator .  \n \nit loads and unloads  plugins  with  simLoadModule  and  simUnloadModule \n \nit loads a  scene  or  model  file that was double-clicked with  simLoadScene  or  simLoadModel \n \nit handles running  simulations  with  simHandleMainScript  and  simAdvanceSimulationByOneStep \n coppeliaSimClientApplication  requires  following files for compilation and running that applications (the easiest is however to simply copy the newly built main application into CoppeliaSim Pro / CoppeliaSim Edu / CoppeliaSim Player installation folder): \n \n simLib.h ,   simLib.cpp  and  simConst.h : files required to dynamically load and bind to CoppeliaSim library \n coppeliaSim.dll  /  libcoppeliaSim.dylib  /  libcoppeliaSim.so : the CoppeliaSim library  \n \n lua5.3.dll  (or similar): library required for the Lua functionality  \n qscintilla2.dll  (or similar): library required for the scintilla editor \n QtCore5.dll ,  QtGui5.dll , etc. (or similar): libraries of the Qt framework \n \nCoppeliaSim's  system  folder and all its content (required for proper initialization, etc.)  \n The main client application can be customized. This is however not recommended and should only be used when writing  scripts  and/or  plugins  won't work for your purpose, since the risk of losing compatibility with the default CoppeliaSim behavior is high if not properly implemented. \n \n \n \n \n", 'tags': '', 'url': 'mainClientApplication.html'}, {'title': 'accessingSceneObjects', 'text': '\n \n \n \n \n Accessing scene objects programmatically \n When programming in and around CoppeliaSim, you will always need to reference  scene objects . You do this with handles, that you obtain via  sim.getObject , which expects an object path as input argument. The object path can be expressed in an absolute manner, but also in a relative manner in case of  associated code . \n In both cases, the path to the object can often be simplified. You may also use wildcards, and optionally specify the object sequence or order in a given scene hierarchy. Or simply fetch the n-th object that matches a specific path/alias. \n \n Note : until CoppeliaSim V4.2.0, object access was based on  object names  (with  sim.getObjectHandle ), which are now deprecated (but still functional for backward compatibility). We however highly recommend to use object paths as described below, to retrieve object handles. Object paths can easily be identified since they start with one of following characters:  / ,  .  or  : \n Deprecated object names are not displayed anymore in the scene hierarchy (where object aliases are displayed instead). You can however still see the deprecated name of an object by selecting it: it will be displayed at the top of the rendering page. \n \n \n \n Access from  unassociated  code \n Unassociated  code is code that is not attached to any scene object. This includes all the code written for  plugins ,  add-ons ,  remote API  clients, external  ROS  nodes, and  the main script . \n In that case, you simply specify the object\'s absolute path, in order to retrieve its handle. If the object alias is unique, the path to the object can be simplified. You may also use wildcards, and optionally specify the object sequence in a given scene hierarchy. Or simply fetch the n-th object that matches a specific path: \n \n// e.g. inside of a c/c++ plugin:\n\n// using the full  Object  path:\nint objectHandle=simGetObject("/Path/to/Object",-1,-1,0);\n\n// if object with alias  Object  is unique:\nint objectHandle=simGetObject("/Object",-1,-1,0); \n\n// handle of the first  Robot , in a given tree:\nint robotHandle=simGetObject("/Robot[0]",-1,-1,0);\n \n// handle of the second  Robot , in a given tree:\nint robotHandle=simGetObject("/Robot[1]",-1,-1,0);\n\n// find all objects starting with prefix  Mobile :\nint i=0\nwhile (true)\n{\n    int objectHandle=simGetObject("/Mobile*",i++,-1,1);\n    if (objectHandle<0)\n        break;\n}  \n \n# e.g. inside of a Python ZeroMQ remote API client:\n\n# using the full  Object  path:\nobjectHandle=sim.getObject("/Path/to/Object")\n\n# if object with alias  Object  is unique:\nobjectHandle=sim.getObject("/Object")\n\n# handle of the first  Robot , in a given tree:\nrobotHandle=sim.getObject("/Robot[0]") \n\n# handle of the second  Robot , in a given tree:\nrobotHandle=sim.getObject("/Robot[1]") \n \n \n \n \n Access from  associated  code\n \n Associated  code is code that is associated with a scene object (i.e.  attached  to a scene object). This includes all the code written for  child scripts  or  customization scripts . \n In that case, objects can also be accessed in an absolute manner, but additionally, object access can also operate in a relative manner (relative to the current script/object (  ./  ), or relative to the model containing current script (  :/  ) ): \n \n// e.g. inside of child or customization script:\n\n-- returns the object this script is attached to:\nlocal objectHandle=sim.getObject(".") \n\n-- returns the parent object this script is attached to:\nlocal parentHandle=sim.getObject("..") \n\n-- returns the model this script is contained in:\nlocal modelHandle=sim.getObject(":") \n\n-- returns the parent model this script is contained in:\nlocal parentModelHandle=sim.getObject("::") \n\n-- returns the first object in the current tree, that starts with  Object :\nlocal objectHandle=sim.getObject("./Object*") \n\n-- returns the first  Object  in the current model tree:\nlocal objectHandle=sim.getObject(":/Object") \n\n-- returns the 4th  Leg  in the current model tree:\nlegHandle=sim.getObject(":/Leg[3]") \n\n-- parse through all  Leg  objects the current model tree:\nlocal i=0\nwhile true do\n    local legHandle=sim.getObject(":/Leg",{index=i,noError=true})\n    if legHandle<0 then\n        break\n    end\n    i=i+1\nend\n\n-- returns the first  Object  in the tree of  AnotherObject :\nlocal objectHandle=sim.getObject("./Object",{proxy=AnotherObject})  \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'accessingSceneObjects.html'}, {'title': 'explicitHandling', 'text': "\n \n \n \n \n Explicit and non-explicit calls \n Some objects, such as  proximity sensors , normally require  handling  or calculations to be performed once per simulation step, to reflect a possible change in the scene. This handling can be done implicitely or explicitely, and those objects have a special setting related to that: an  explicit handling  flag. By default that flag is unchecked, which means that the object will be implicitely handled via the  main script . Indeed the following main script code will be executed and handle said objects once per simulation step: \n \nsim.handleProximitySensor(sim.handle_all_except_explicit) \n Above code will perform proximity sensor computations, and any other script can then read the up-to-date calculation results with: \n \nlocal calculationResult=sim.readProximitySensor(sensorHandle) \n Above code, unlike the previous, will not compute anything, but just read the calculation result. This is very convenient when calculation need to happen exactly once per simulation step and/or the calculation result is required by several scripts. \n If however, an object requires less or more frequent calculations (e.g. several calculations within a same simulation step), then above mechanism does not work. In that case, the object should be flagged as  explicit handling : from that moment on, the main script will not handle that object anymore, and it is the responsibility of another script to do this. For instance if the proximity sensor should only be handled once every other simulation step, a  child script  could include following code: \n \nfunction sysCall_init()\n    sensorHandle=sim.getObject('/myProximitySensor')\nend\n\nfunction sysCall_sensing()\n    handleSensor=not handleSensor\n    if handleSensor then\n        sim.handleProximitySensor(sensorHandle)\n    end\nend \n If new calculations need to be performed several times within a same simulation step (e.g. because an object or the sensor itself is moved more frequently), one could write: \n \nfunction sysCall_init()\n    sensorHandle=sim.getObject('/myProximitySensor')\nend\n\nfunction sysCall_sensing()\n    for i=1,10,1 do\n        local pos=sim.getObjectPosition(sensorHandle,-1)\n        pos[3]=i/10\n        sim.setObjectPosition(sensorHandle,-1,pos) -- e.g. move the sensor\n        local calculationResults=sim.handleProximitySensor(sensorHandle)\n    end\nend\n \n \n \n \n \n", 'tags': '', 'url': 'explicitHandling.html'}, {'title': 'apisOverview', 'text': '\n \n \n \n \n CoppeliaSim API framework \n Within CoppeliaSim, one can distinguish between two group of functions: \n the regular API : those are functions made available by CoppeliaSim itself, and can be seen as the main functions. They are grouped under the  sim  namespace, e.g.  sim.getObject . \n the other API functions: those are functions made available by specific  plugins . Each plugin groups its functions under a unique namespace, e.g.  simOMPL ,  simUI ,  simIK , etc. Description and API references to those functions can be found in the  functionality section . \n From an external application, there are  many different API mechanisms available to communicate and interact with CoppeliaSim . \n \n \n \n \n', 'tags': '', 'url': 'apisOverview.html'}, {'title': 'apiFunctions', 'text': '\n \n \n \n \n Regular API reference \n The list of API functions below allows you to access many CoppeliaSim parameters . There are however too many parameters in CoppeliaSim to have a specific API function for each one of them.  Auxiliary  parameters can be accessed via a set of given functions that use  object parameter IDs . Refer also to  the  global parameter IDs . \nAll units going to, or coming from the API are in meters, kilograms, seconds and  radians  or a combination of those (unless otherwise explicitly indicated).\n \n File operations \n \n sim.closeScene \n sim.saveScene \n sim.loadScene \n sim.saveModel \n sim.loadModel \n sim.importShape \n sim.importMesh \n sim.exportMesh \n sim.launchExecutable \n sim.createTexture \n \n \n \n simCloseScene \n simSaveScene \n simLoadScene \n simSaveModel \n simLoadModel \n simDoesFileExist \n simImportShape \n simImportMesh \n simExportMesh \n simCreateTexture \n \n \n General object handle retrieval \n \n sim.getObject \n sim.getObjectFromUid \n sim.isHandle \n sim.getObjects \n sim.getObjectsInTree \n sim.getCollectionObjects \n sim.setReferencedHandles \n sim.getReferencedHandles \n \n \n \n simGetObject \n simGetObjectFromUid \n simIsHandle \n simGetObjects \n simGetObjectsInTree \n simGetCollectionObjects \n simSetReferencedHandles \n simGetReferencedHandles \n \n \n General functionality handling \n \n sim.handleChildScripts \n sim.handleCustomizationScripts \n sim.handleAddOnScripts \n sim.handleSandboxScript \n \n \n \n simHandleMainScript \n \n \n Collision detection \n \n sim.checkCollision \n sim.checkCollisionEx \n \n \n \n simCheckCollision \n simCheckCollisionEx \n \n \n Minimum distance calculation \n \n sim.checkDistance \n \n \n \n simCheckDistance \n \n \n Dynamics \n \n sim.handleDynamics \n sim.setJointTargetPosition \n sim.setJointTargetVelocity \n sim.readForceSensor \n sim.getJointForce \n sim.getJointTargetForce \n sim.setJointTargetForce \n sim.addForce \n sim.addForceAndTorque \n sim.getVelocity \n sim.getLinkDummy \n sim.setLinkDummy \n sim.resetDynamicObject \n sim.addParticleObject \n sim.addParticleObjectItem \n sim.removeParticleObject \n sim.getContactInfo \n sim.getShapeMass \n sim.setShapeMass \n sim.getShapeInertia \n sim.setShapeInertia \n sim.computeMassAndInertia \n sim.createForceSensor \n sim.convexDecompose \n sim.getQHull \n sim.getDecimatedMesh \n sim.isDynamicallyEnabled \n sim.setShapeMaterial \n\n See also:\n  physics engine parameter functions .\n \n \n \n simHandleDynamics \n simSetJointTargetPosition \n simSetJointTargetVelocity \n simReadForceSensor \n simGetJointForce \n simGetJointTargetForce \n simSetJointTargetForce \n simAddForce \n simAddForceAndTorque \n simGetVelocity \n simGetLinkDummy \n simSetLinkDummy \n simResetDynamicObject \n simAddParticleObject \n simAddParticleObjectItem \n simRemoveParticleObject \n simGetContactInfo \n simGetShapeMass \n simSetShapeMass \n simGetShapeInertia \n simSetShapeInertia \n simComputeMassAndInertia \n simCreateForceSensor \n simConvexDecompose \n simGetQHull \n simGetDecimatedMesh \n simIsDynamicallyEnabled \n simSetShapeMaterial \n \n \n Proximity sensors \n \n sim.handleProximitySensor \n sim.readProximitySensor \n sim.resetProximitySensor \n sim.checkProximitySensor \n sim.checkProximitySensorEx \n sim.checkProximitySensorEx2 \n sim.createProximitySensor \n\n See also:\n  object parameter functions  and  parameters related to proximity sensors .\n \n \n \n simHandleProximitySensor \n simReadProximitySensor \n simResetProximitySensor \n simCheckProximitySensor \n simCheckProximitySensorEx \n simCheckProximitySensorEx2 \n simCreateProximitySensor \n \n \n Vision sensors \n \n sim.handleVisionSensor \n sim.readVisionSensor \n sim.resetVisionSensor \n sim.checkVisionSensor \n sim.checkVisionSensorEx \n sim.getVisionSensorDepth \n sim.getVisionSensorImg \n sim.setVisionSensorImg \n sim.adjustView \n sim.createVisionSensor \n sim.getExtensionString \n\n See also:\n  object parameter functions  and  parameters related to vision sensors .\n \n \n \n simHandleVisionSensor \n simReadVisionSensor \n simResetVisionSensor \n simCheckVisionSensor \n simCheckVisionSensorEx \n simGetVisionSensorDepth \n simGetVisionSensorImg \n simSetVisionSensorImg \n simAdjustView \n simCreateVisionSensor \n simGetExtensionString \n \n \n Force sensors \n \n sim.readForceSensor \n sim.createForceSensor \n\n See also:\n  object parameter functions  and  parameters related to force sensors .\n \n \n \n simReadForceSensor \n simCreateForceSensor \n \n \n Joints \n \n sim.setJointPosition \n sim.getJointPosition \n sim.setJointTargetPosition \n sim.getJointTargetPosition \n sim.setJointTargetVelocity \n sim.getJointTargetVelocity \n sim.getJointVelocity \n sim.getObjectChildPose \n sim.setObjectChildPose \n sim.setJointInterval \n sim.getJointInterval \n sim.getJointType \n sim.createJoint \n sim.setJointMode \n sim.getJointMode \n sim.setJointDependency \n sim.getJointDependency \n sim.getJointForce \n sim.getJointTargetForce \n sim.setJointTargetForce \n\n See also:\n  object parameter functions  and  parameters related to joints .\n  physics engine parameter functions .\n \n \n \n simSetJointPosition \n simGetJointPosition \n simSetJointTargetPosition \n simGetJointTargetPosition \n simSetJointTargetVelocity \n simGetJointTargetVelocity \n simGetJointVelocity \n simGetObjectChildPose \n simSetObjectChildPose \n simSetJointInterval \n simGetJointInterval \n simGetJointType \n simCreateJoint \n simSetJointMode \n simGetJointMode \n simSetJointDependency \n simGetJointDependency \n simGetJointForce \n simGetJointTargetForce \n simSetJointTargetForce \n \n \n Shapes \n \n sim.addForce \n sim.addForceAndTorque \n sim.getVelocity \n sim.getShapeColor \n sim.setShapeColor \n sim.getShapeTextureId \n sim.setShapeTexture \n sim.createMeshShape \n sim.createPrimitiveShape \n sim.createHeightfieldShape \n sim.getShapeMesh \n sim.getShapeViz \n sim.getShapeGeomInfo \n sim.getShapeMass \n sim.setShapeMass \n sim.getShapeInertia \n sim.setShapeInertia \n sim.computeMassAndInertia \n sim.groupShapes \n sim.ungroupShape \n sim.importShape \n sim.convexDecompose \n sim.getQHull \n sim.getDecimatedMesh \n sim.reorientShapeBoundingBox \n sim.setShapeMaterial \n sim.getShapeBB \n sim.setShapeBB \n sim.getExtensionString \n sim.generateTextShape \n\n See also:\n  object parameter functions  and  parameters related to shapes .\n  physics engine parameter functions .\n \n \n \n simAddForce \n simAddForceAndTorque \n simGetVelocity \n simGetShapeColor \n simSetShapeColor \n simGetShapeTextureId \n simSetShapeTexture \n simCreateMeshShape \n simCreatePrimitiveShape \n simCreateHeightfieldShape \n simGetShapeMesh \n simGetShapeViz \n simApplyTexture \n simGetShapeGeomInfo \n simGetShapeMass \n simSetShapeMass \n simGetShapeInertia \n simSetShapeInertia \n simComputeMassAndInertia \n simGroupShapes \n simUngroupShape \n simImportShape \n simConvexDecompose \n simGetQHull \n simGetDecimatedMesh \n simReorientShapeBoundingBox \n simSetShapeMaterial \n simGetExtensionString \n \n \n Graphs \n \n sim.addGraphStream \n sim.setGraphStreamTransformation \n sim.setGraphStreamValue \n sim.addGraphCurve \n sim.destroyGraphCurve \n sim.duplicateGraphCurveToStatic \n sim.handleGraph \n sim.resetGraph \n\n See also:\n  object parameter functions  and  parameters related to graphs .\n \n \n \n simAddGraphStream \n simSetGraphStreamTransformation \n simSetGraphStreamValue \n simAddGraphCurve \n simDestroyGraphCurve \n simDuplicateGraphCurveToStatic \n simHandleGraph \n simResetGraph \n \n \n Lights \n \n sim.getLightParameters \n sim.setLightParameters \n sim.getExtensionString \n\n See also:\n  object parameter functions  and  parameters related to lights .\n \n \n \n simGetLightParameters \n simSetLightParameters \n simGetExtensionString \n \n \n Cameras \n \n sim.cameraFitToView \n sim.adjustView \n sim.getExtensionString \n\n See also:\n  object parameter functions  and  parameters related to cameras .\n \n \n \n simCameraFitToView \n simAdjustView \n simGetExtensionString \n \n \n Dummies \n \n sim.createDummy \n sim.getLinkDummy \n sim.setLinkDummy \n\n See also:\n  object parameter functions  and  parameters related to dummies .\n \n \n \n simCreateDummy \n simGetLinkDummy \n simSetLinkDummy \n \n \n OC trees \n \n sim.createOctree \n sim.insertVoxelsIntoOctree \n sim.removeVoxelsFromOctree \n sim.insertObjectIntoOctree \n sim.subtractObjectFromOctree \n sim.getOctreeVoxels \n sim.checkOctreePointOccupancy \n\n See also:\n  object parameter functions  and  parameters related to OC trees .\n \n \n \n simCreateOctree \n simInsertVoxelsIntoOctree \n simRemoveVoxelsFromOctree \n simInsertObjectIntoOctree \n simSubtractObjectFromOctree \n simGetOctreeVoxels \n simCheckOctreePointOccupancy \n \n \n Point clouds \n \n sim.createPointCloud \n sim.getPointCloudOptions \n sim.setPointCloudOptions \n sim.insertPointsIntoPointCloud \n sim.removePointsFromPointCloud \n sim.subtractObjectFromPointCloud \n sim.intersectPointsWithPointCloud \n sim.insertObjectIntoPointCloud \n sim.getPointCloudPoints \n\n See also:\n  object parameter functions  and  parameters related to point clouds .\n \n \n \n simCreatePointCloud \n simGetPointCloudOptions \n simSetPointCloudOptions \n simInsertPointsIntoPointCloud \n simRemovePointsFromPointCloud \n simSubtractObjectFromPointCloud \n simIntersectPointsWithPointCloud \n simInsertObjectIntoPointCloud \n simGetPointCloudPoints \n \n \n Paths \n \n sim.createPath \n sim.getConfigDistance \n sim.getPathLengths \n sim.getPathInterpolatedConfig \n sim.resamplePath \n sim.generateTimeOptimalTrajectory \n sim.generateShapeFromPath \n sim.getClosestPosOnPath \n \n \n simGenerateShapeFromPath \n simGetClosestPosOnPath \n \n \n Scene objects \n \n sim.getObject \n sim.getObjectUid \n sim.isHandle \n sim.removeObject \n sim.removeModel \n sim.getObjectAlias \n sim.setObjectAlias \n sim.getObjects \n sim.getObjectsInTree \n sim.getObjectParent \n sim.setObjectParent \n sim.getObjectChild \n sim.getObjectMatrix \n sim.setObjectMatrix \n sim.getObjectPose \n sim.setObjectPose \n sim.getObjectPosition \n sim.setObjectPosition \n sim.getObjectOrientation \n sim.setObjectOrientation \n sim.getObjectQuaternion \n sim.setObjectQuaternion \n sim.getObjectType \n sim.getObjectSelection \n sim.setObjectSelection \n sim.getObjectSizeFactor \n sim.copyPasteObjects \n sim.scaleObject \n sim.scaleObjects \n sim.getObjectProperty \n sim.setObjectProperty \n sim.getObjectSpecialProperty \n sim.setObjectSpecialProperty \n sim.getObjectVelocity \n sim.readCustomTableData \n sim.writeCustomTableData \n sim.readCustomDataBlock \n sim.readCustomDataBlockTags \n sim.writeCustomDataBlock \n sim.setReferencedHandles \n sim.getReferencedHandles \n sim.isDynamicallyEnabled \n sim.getObjectColor \n sim.setObjectColor \n\n See also:\n  object parameter functions  and  parameters related to scene objects .\n \n \n \n simGetObject \n simGetObjectUid \n simIsHandle \n simRemoveObject \n simRemoveModel \n simGetObjectAlias \n simSetObjectAlias \n simGetObjects \n simGetObjectsInTree \n simGetObjectParent \n simSetObjectParent \n simGetObjectChild \n simGetObjectMatrix \n simSetObjectMatrix \n simGetObjectPose \n simSetObjectPose \n simGetObjectPosition \n simSetObjectPosition \n simGetObjectOrientation \n simSetObjectOrientation \n simGetObjectQuaternion \n simSetObjectQuaternion \n simGetObjectType \n simGetObjectSel \n simSetObjectSel \n simGetObjectSizeFactor \n simCopyPasteObjects \n simScaleObject \n simScaleObjects \n simGetObjectProperty \n simSetObjectProperty \n simGetObjectSpecialProperty \n simSetObjectSpecialProperty \n simGetObjectVelocity \n simReadCustomDataBlock \n simReadCustomDataBlockTags \n simWriteCustomDataBlock \n simSetReferencedHandles \n simGetReferencedHandles \n simIsDynamicallyEnabled \n simGetObjectColor \n simSetObjectColor \n \n \n Object size / scaling \n \n sim.getObjectSizeFactor \n sim.scaleObject \n sim.scaleObjects \n sim.getShapeBB \n sim.setShapeBB \n \n \n \n simGetObjectSizeFactor \n simScaleObject \n simScaleObjects \n \n \n Collections \n \n sim.createCollection \n sim.destroyCollection \n sim.addItemToCollection \n sim.getCollectionObjects \n \n \n \n simCreateCollectionEx \n simDestroyCollection \n simAddItemToCollection \n simGetCollectionObjects \n \n \n Serial port \n \n sim.serialCheck \n sim.serialClose \n sim.serialOpen \n sim.serialRead \n sim.serialSend \n \n \n \n simSerialCheck \n simSerialClose \n simSerialOpen \n simSerialRead \n simSerialSend \n \n \n Rendering \n \n sim.addDrawingObject \n sim.addDrawingObjectItem \n sim.removeDrawingObject \n sim.getShapeColor \n sim.setShapeColor \n sim.getObjectColor \n sim.setObjectColor \n sim.changeEntityColor \n sim.restoreEntityColor \n sim.getGenesisEvents \n \n \n \n simAddDrawingObject \n simAddDrawingObjectItem \n simRemoveDrawingObject \n simGetShapeColor \n simSetShapeColor \n simGetObjectColor \n simSetObjectColor \n \n \n Particle objects \n \n sim.addParticleObject \n sim.addParticleObjectItem \n sim.removeParticleObject \n \n \n \n simAddParticleObject \n simAddParticleObjectItem \n simRemoveParticleObject \n \n \n Models \n \n sim.getModelProperty \n sim.setModelProperty \n sim.saveModel \n sim.loadModel \n \n \n \n simGetModelProperty \n simSetModelProperty \n simSaveModel \n simLoadModel \n \n \n Object selection \n \n sim.getObjectSelection \n sim.setObjectSelection \n \n \n \n simGetObjectSel \n simSetObjectSel \n \n \n Object creation \n \n sim.createDummy \n sim.createForceSensor \n sim.createHeightfieldShape \n sim.createJoint \n sim.createMeshShape \n sim.createProximitySensor \n sim.createPrimitiveShape \n sim.createVisionSensor \n sim.createOctree \n sim.createPointCloud \n sim.createTexture \n sim.generateTextShape \n sim.generateShapeFromPath \n \n \n \n simCreateDummy \n simCreateForceSensor \n simCreateHeightfieldShape \n simCreateJoint \n simCreateMeshShape \n simCreateProximitySensor \n simCreatePrimitiveShape \n simCreateVisionSensor \n simCreateOctree \n simCreatePointCloud \n simCreateTexture \n simGenerateShapeFromPath \n \n \n Scripts \n \n sim.getRandom \n sim.getScript \n sim.isHandle \n sim.addScript \n sim.initScript \n sim.removeScript \n sim.callScriptFunction \n sim.executeScriptString \n sim.getApiFunc \n sim.getApiInfo \n sim.handleChildScripts \n sim.handleCustomizationScripts \n sim.handleAddOnScripts \n sim.handleSandboxScript \n sim.setScriptText \n sim.registerScriptFunction \n sim.registerScriptVariable \n sim.registerScriptFuncHook \n sim.getStackTraceback \n sim.isDeprecated \n\n See also:\n  functions related to script parameters \n \n \n \n simGetScriptHandleEx \n simIsHandle \n simAddScript \n simInitScript \n simRemoveScript \n simCallScriptFunction \n simCallScriptFunctionEx \n simExecuteScriptString \n simGetApiFunc \n simGetApiInfo \n simHandleMainScript \n simResetScript \n simGetScriptProperty \n simGetScriptText \n simSetScriptText \n simRegisterScriptCallbackFunction \n simRegisterScriptVariable \n simRegisterScriptFuncHook \n simIsDeprecated \n \n \n Simulation \n \n sim.startSimulation \n sim.pauseSimulation \n sim.stopSimulation \n sim.getSimulationState \n sim.getSimulationTime \n sim.getSimulationTimeStep \n sim.getRealTimeSimulation \n \n \n \n simStartSimulation \n simPauseSimulation \n simStopSimulation \n simAdvanceSimulationByOneStep \n simGetSimulationState \n simGetSimulationTime \n simGetSimulationTimeStep \n simGetSimulationPassesPerRenderingPass \n simSetSimulationPassesPerRenderingPass \n simGetRealTimeSimulation \n simAdjustRealTimeTimer \n simIsRealTimeSimulationStepNeeded \n \n \n Threads \n \n sim.getThreadAutomaticSwitch \n sim.getThreadExitRequest \n sim.getThreadSwitchTiming \n sim.getThreadSwitchAllowed \n sim.handleExtCalls \n sim.setThreadAutomaticSwitch \n sim.setThreadSwitchTiming \n sim.setThreadSwitchAllowed \n sim.switchThread \n \n \n Custom scripts \n \n sim.registerScriptFunction \n sim.registerScriptVariable \n sim.registerScriptFuncHook \n \n \n \n simRegisterScriptCallbackFunction \n simRegisterScriptVariable \n simRegisterScriptFuncHook \n \n \n Transformations \n \n sim.buildMatrix \n sim.buildMatrixQ \n sim.buildPose \n sim.getEulerAnglesFromMatrix \n sim.getQuaternionFromMatrix \n sim.multiplyMatrices \n sim.interpolateMatrices \n sim.invertMatrix \n sim.getObjectMatrix \n sim.setObjectMatrix \n sim.getObjectPose \n sim.setObjectPose \n sim.getObjectPosition \n sim.setObjectPosition \n sim.getObjectOrientation \n sim.setObjectOrientation \n sim.getObjectQuaternion \n sim.setObjectQuaternion \n sim.getObjectChildPose \n sim.setObjectChildPose \n sim.multiplyVector \n sim.getRotationAxis \n sim.rotateAroundAxis \n sim.getObjectVelocity \n sim.reorientShapeBoundingBox \n sim.alphaBetaGammaToYawPitchRoll \n sim.yawPitchRollToAlphaBetaGamma \n\n See also:\n  packing/unpacking functions \n \n \n \n simBuildMatrix \n simBuildMatrixQ \n simBuildPose \n simGetEulerAnglesFromMatrix \n simGetQuaternionFromMatrix \n simMultiplyMatrices \n simInterpolateMatrices \n simInvertMatrix \n simGetObjectMatrix \n simSetObjectMatrix \n simGetObjectPose \n simSetObjectPose \n simGetObjectPosition \n simSetObjectPosition \n simGetObjectOrientation \n simSetObjectOrientation \n simGetObjectQuaternion \n simSetObjectQuaternion \n simGetObjectChildPose \n simSetObjectChildPose \n simTransformVector \n simGetRotationAxis \n simRotateAroundAxis \n simGetObjectVelocity \n simReorientShapeBoundingBox \n \n \n Messaging \n \n sim.addLog \n sim.loadModule \n sim.unloadModule \n sim.getSimulatorMessage \n sim.serialCheck \n sim.serialClose \n sim.serialOpen \n sim.serialRead \n sim.serialSend \n sim.setInt32Signal \n sim.getInt32Signal \n sim.clearInt32Signal \n sim.setFloatSignal \n sim.getFloatSignal \n sim.clearFloatSignal \n sim.setDoubleSignal \n sim.getDoubleSignal \n sim.clearDoubleSignal \n sim.setStringSignal \n sim.getStringSignal \n sim.clearStringSignal \n sim.getSignalName \n sim.waitForSignal \n sim.auxiliaryConsoleClose \n sim.auxiliaryConsoleOpen \n sim.auxiliaryConsolePrint \n sim.persistentDataRead \n sim.persistentDataWrite \n sim.getPersistentDataTags \n sim.getMatchingPersistentDataTags \n sim.callScriptFunction \n sim.executeScriptString \n sim.getObjectUid \n sim.getGenesisEvents \n sim.broadcastMsg \n sim.pushUserEvent \n \n \n \n simAddLog \n simSetLastError \n simLoadModule \n simUnloadModule \n simGetSimulatorMessage \n simSerialCheck \n simSerialClose \n simSerialOpen \n simSerialRead \n simSerialSend \n simSetInt32Signal \n simGetInt32Signal \n simClearInt32Signal \n simSetFloatSignal \n simGetFloatSignal \n simClearFloatSignal \n simSetDoubleSignal \n simGetDoubleSignal \n simClearDoubleSignal \n simSetStringSignal \n simGetStringSignal \n simClearStringSignal \n simGetSignalName \n simAuxiliaryConsoleClose \n simAuxiliaryConsoleOpen \n simAuxiliaryConsolePrint \n simPersistentDataRead \n simPersistentDataWrite \n simGetPersistentDataTags \n simCallScriptFunctionEx \n simExecuteScriptString \n simGetObjectUid \n \n \n Signals \n \n sim.setInt32Signal \n sim.getInt32Signal \n sim.clearInt32Signal \n sim.setFloatSignal \n sim.getFloatSignal \n sim.clearFloatSignal \n sim.setDoubleSignal \n sim.getDoubleSignal \n sim.clearDoubleSignal \n sim.setStringSignal \n sim.getStringSignal \n sim.clearStringSignal \n sim.getSignalName \n sim.waitForSignal \n\n See also:\n  data packing/unpacking .\n  persistent data .\n \n \n \n simSetInt32Signal \n simGetInt32Signal \n simClearInt32Signal \n simSetFloatSignal \n simGetFloatSignal \n simClearFloatSignal \n simSetDoubleSignal \n simGetDoubleSignal \n simClearDoubleSignal \n simSetStringSignal \n simGetStringSignal \n simClearStringSignal \n simGetSignalName \n \n \n Persistent Data \n \n sim.persistentDataRead \n sim.persistentDataWrite \n sim.getPersistentDataTags \n sim.getMatchingPersistentDataTags \n \n \n \n simPersistentDataRead \n simPersistentDataWrite \n simGetPersistentDataTags \n \n \n Custom data blocks \n \n sim.readCustomTableData \n sim.writeCustomTableData \n sim.readCustomDataBlock \n sim.readCustomDataBlockTags \n sim.writeCustomDataBlock \n\n See also:\n  data packing/unpacking .\n \n \n \n simReadCustomDataBlock \n simReadCustomDataBlockTags \n simWriteCustomDataBlock \n \n \n Textures \n \n sim.getTextureId \n sim.getShapeTextureId \n sim.readTexture \n sim.saveImage \n sim.loadImage \n sim.getScaledImage \n sim.transformImage \n sim.writeTexture \n sim.createTexture \n sim.setShapeTexture \n \n \n \n simApplyTexture \n simGetTextureId \n simGetShapeTextureId \n simReadTexture \n simSaveImage \n simLoadImage \n simGetScaledImage \n simTransformImage \n simWriteTexture \n simCreateTexture \n simSetShapeTexture \n \n \n Blocking functions \n \n sim.wait \n sim.waitForSignal \n sim.moveToConfig \n sim.moveToPose \n sim.serialRead \n \n \n Auxiliary consoles  \n \n sim.auxiliaryConsoleClose \n sim.auxiliaryConsoleOpen \n sim.auxiliaryConsolePrint \n sim.auxiliaryConsoleShow \n\n See also:\n  Custom user interfaces .\n \n \n \n simAuxiliaryConsoleClose \n simAuxiliaryConsoleOpen \n simAuxiliaryConsolePrint \n simAuxiliaryConsoleShow \n \n \n Text/code editors \n \n sim.textEditorClose \n sim.textEditorGetInfo \n sim.textEditorOpen \n sim.textEditorShow \n\n See also:\n  Custom user interfaces .\n \n \n Import/export \n \n sim.importShape \n sim.importMesh \n sim.exportMesh \n sim.createTexture \n sim.loadImage \n sim.saveImage \n sim.generateTextShape \n\n See also:\n  Assimp plugin API reference .\n \n \n \n simImportShape \n simImportMesh \n simExportMesh \n simCreateTexture \n simLoadImage \n simSaveImage \n \n \n Pages and views \n \n sim.floatingViewAdd \n sim.floatingViewRemove \n sim.adjustView \n sim.cameraFitToView \n \n \n \n simFloatingViewAdd \n simFloatingViewRemove \n simAdjustView \n simCameraFitToView \n \n \n Ruckig motion library \n \n sim.moveToConfig \n sim.moveToPose \n sim.ruckigPos \n sim.ruckigVel \n sim.ruckigStep \n sim.ruckigRemove \n \n \n \n simRuckigPos \n simRuckigVel \n simRuckigStep \n simRuckigRemove \n \n \n Packing / unpacking \n \n sim.packTable \n sim.unpackTable \n sim.packUInt8Table \n sim.unpackUInt8Table \n sim.packUInt16Table \n sim.unpackUInt16Table \n sim.packUInt32Table \n sim.unpackUInt32Table \n sim.packInt32Table \n sim.unpackInt32Table \n sim.packFloatTable \n sim.unpackFloatTable \n sim.packDoubleTable \n sim.unpackDoubleTable \n sim.copyTable \n sim.transformBuffer \n \n \n \n simPackTable \n simUnpackTable \n \n \n Stacks \n \n sim.packTable \n sim.unpackTable \n \n \n \n simCreateStack \n simReleaseStack \n simCopyStack \n simPushNullOntoStack \n simPushBoolOntoStack \n simPushInt32OntoStack \n simPushFloatOntoStack \n simPushDoubleOntoStack \n simPushStringOntoStack \n simPushUInt8TableOntoStack \n simPushInt32TableOntoStack \n simPushFloatTableOntoStack \n simPushDoubleTableOntoStack \n simPushTableOntoStack \n simInsertDataIntoStackTable \n simGetStackSize \n simPopStackItem \n simMoveStackItemToTop \n simIsStackValueNull \n simGetStackBoolValue \n simGetStackInt32Value \n simGetStackFloatValue \n simGetStackDoubleValue \n simGetStackStringValue \n simGetStackTableInfo \n simGetStackUInt8Table \n simGetStackInt32Table \n simGetStackFloatTable \n simGetStackDoubleTable \n simUnfoldStackTable \n simDebugStack \n simPackTable \n simUnpackTable \n \n \n Object parameters \n \n sim.getObjectInt32Param \n sim.setObjectInt32Param \n sim.getObjectFloatParam \n sim.setObjectFloatParam \n sim.getObjectStringParam \n sim.setObjectStringParam \n \n \n \n simGetObjectInt32Param \n simSetObjectInt32Param \n simGetObjectFloatParam \n simSetObjectFloatParam \n simGetObjectStringParam \n simSetObjectStringParam \n \n \n Script parameters \n \n sim.getScriptInt32Param \n sim.setScriptInt32Param \n sim.getScriptStringParam \n sim.setScriptStringParam \n \n \n \n simGetScriptInt32Param \n simSetScriptInt32Param \n simGetScriptStringParam \n simSetScriptStringParam \n \n \n Simulator parameters \n \n sim.setArrayParam \n sim.getArrayParam \n sim.setBoolParam \n sim.getBoolParam \n sim.setInt32Param \n sim.getInt32Param \n sim.setFloatParam \n sim.getFloatParam \n sim.setStringParam \n sim.getStringParam \n sim.setNamedStringParam \n sim.getNamedStringParam \n \n \n \n simSetArrayParam \n simGetArrayParam \n simSetBoolParam \n simGetBoolParam \n simSetInt32Param \n simGetInt32Param \n simSetFloatParam \n simGetFloatParam \n simSetStringParam \n simGetStringParam \n simSetNamedStringParam \n simGetNamedStringParam \n simGetUInt64Parameter \n \n \n Simulator named parameters \n \n sim.setNamedStringParam \n sim.getNamedStringParam \n sim.getNamedBoolParam \n sim.getNamedFloatParam \n sim.getNamedInt32Param \n \n \n \n simSetNamedStringParam \n simGetNamedStringParam \n \n \n Physics engine parameters \n \n sim.getEngineFloatParam \n sim.getEngineInt32Param \n sim.getEngineBoolParam \n sim.setEngineFloatParam \n sim.setEngineInt32Param \n sim.setEngineBoolParam \n \n \n \n simGetEngineFloatParam \n simGetEngineInt32Param \n simGetEngineBoolParam \n simSetEngineFloatParam \n simSetEngineInt32Param \n simSetEngineBoolParam \n \n \n Other commands \n \n sim.addLog \n sim.announceSceneContentChange \n sim.getNavigationMode \n sim.setNavigationMode \n sim.getPage \n sim.setPage \n sim.getModuleName \n sim.getNavigationMode \n sim.getSystemTime \n sim.refreshDialogs \n sim.setThreadSwitchTiming \n sim.switchThread \n sim.getExplicitHandling \n sim.setExplicitHandling \n sim.launchExecutable \n sim.quitSimulator \n sim.getExtensionString \n sim.textEditorClose \n sim.textEditorGetInfo \n sim.textEditorOpen \n sim.textEditorShow \n sim.getUserVariables \n sim.isDeprecated \n sim.moduleEntry \n sim.getGenesisEvents \n sim.pushUserEvent \n \n \n \n simAddLog \n simAnnounceSceneContentChange \n simGetNavigationMode \n simSetNavigationMode \n simGetPage \n simSetPage \n simGetLastError \n simSetLastError \n simGetModuleName \n simGetNavigationMode \n simRefreshDialogs \n simGetExplicitHandling \n simSetExplicitHandling \n simQuitSimulator \n simGetExtensionString \n simOpenTextEditor \n simCreateBuffer \n simReleaseBuffer \n simIsDeprecated \n simModuleEntry \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'apiFunctions.html'}, {'title': 'apiConstants', 'text': '\n \n \n \n \n regular API constants \n General object types \n \n sim.appobj_object_type \n sim.appobj_collision_type \n sim.appobj_distance_type \n sim.appobj_simulation_type \n sim.appobj_collection_type \n sim.appobj_script_type \n sim.appobj_texture_type \n \nSee also the  sim.isHandle  function.\n \n \n \n Scene object types \n \n sim.object_shape_type \n sim.object_joint_type \n sim.object_graph_type \n sim.object_camera_type sim.object_light_type \n sim.object_dummy_type \n sim.object_proximitysensor_type \n sim.object_octree_type \n sim.object_pointcloud_type \n sim.object_visionsensor_type \n sim.object_forcesensor_type \n \nSee also the  sim.getObjectType  and  sim.getObjectsInTree  functions.\n \n \n \n Scene object sub-types \n \n sim.light_omnidirectional_subtype \n sim.light_spot_subtype \n sim.light_directional_subtype \n sim.joint_revolute_subtype \n sim.joint_prismatic_subtype \n sim.joint_spherical_subtype \n sim.shape_simpleshape_subtype \n sim.shape_multishape_subtype \n sim.proximitysensor_ray_subtype \n sim.proximitysensor_pyramid_subtype \n sim.proximitysensor_cylinder_subtype \n sim.proximitysensor_disc_subtype \n sim.proximitysensor_cone_subtype \n \n<div class="sim.mill_pyramid_subtype">sim.mill_pyramid_subtype</div\n><div class="sim.mill_cylinder_subtype">sim.mill_cylinder_subtype</div\n><div class="sim.mill_disc_subtype">sim.mill_disc_subtype</div\n><div class="sim.mill_cone_subtype">sim.mill_cone_subtype</div>\n \n \n \n \n Scene object properties \n \n sim.objectproperty_ignoreviewfitting sim.objectproperty_collapsed sim.objectproperty_selectable sim.objectproperty_selectinvisible with this flag, an object will be ignored during the selection process \n sim.objectproperty_depthinvisible with this flag, an object will be ignored during the depth rendering pass \n sim.objectproperty_selectmodelbaseinstead sim.objectproperty_dontshowasinsidemodel sim.objectproperty_cannotdelete \n sim.objectproperty_cannotdeleteduringsim \n \nSee also the  sim.getObjectProperty  and  sim.setObjectProperty  functions.\n \n \n \n Scene object special properties (can be combined with the OR operator) \n \n sim.objectspecialproperty_collidable \n sim.objectspecialproperty_measurable \n sim.objectspecialproperty_detectable \n \nSee also the  sim.getObjectSpecialProperty  and  sim.setObjectSpecialProperty  functions.\n \n \n \n Model properties \n \n sim.modelproperty_not_collidable sim.modelproperty_not_measurable sim.modelproperty_not_detectable \n sim.modelproperty_not_dynamic sim.modelproperty_not_respondable sim.modelproperty_not_visible model is not visible, independently from local visibility settings \n sim.modelproperty_scripts_inactive all child- and customization scripts will be disabled for the given model \n sim.modelproperty_not_showasinsidemodel model will be invisible to other model\'s bounding boxes \n sim.modelproperty_not_model specified object is not a model. Use with care when setting this value \n \nSee also the  sim.getModelProperty  and  sim.setModelProperty  functions.\n \n \n \n Simulator messages \n \n Following messages can be queried from a script, by calling the  sim.getSimulatorMessage  function: \n \n sim.message_model_loaded \n sim.message_scene_loaded \n sim.message_keypress \n auxiliaryData[0]=key, auxiliaryData[1]=ctrl and shift key state \n sim.message_bannerclicked \n auxiliaryData[0]=banner ID \n sim.message_prox_sensor_select_down \n a "geometric" click select (mouse down) was registered. Not generated if the ctrl or shift key is down. A geometric click is generated in a non-delayed manner. See also sim.message_pick_select_down hereafter. Enable with  sim.intparam_prox_sensor_select_down . \n auxiliaryData[0]=objectID \n auxiliaryData2[0]-auxiliaryData2[2]=coordinates of clicked point \n auxiliaryData2[3]-auxiliaryData2[5]=normal vector of clicked surface \n sim.message_prox_sensor_select_up \n a "geometric" click select (mouse up) was registered. Not generated if the ctrl or shift key is down. A geometric click is generated in a non-delayed manner. Enable with  sim.intparam_prox_sensor_select_up . \n auxiliaryData[0]=objectID \n auxiliaryData2[0]-auxiliaryData2[2]=coordinates of clicked point \n auxiliaryData2[3]-auxiliaryData2[5]=normal vector of clicked surface \n sim.message_pick_select_down \n a "pick" click select (mouse down) was registered. Not generated if the ctrl or shift key is down. A pick click is generated in a delayed manner. See also sim.message_prox_sensor_select_down here above. \n auxiliaryData[0]=objectID or base object ID (if part of a model and  select model base instead  is checked) \n \n \n Following messages can be queried from the CoppeliaSim client application (and only from the client application!), by calling the  simGetSimulatorMessage  function: \n \n sim_message_simulation_start_resume_request \n The user wishes to start/resume a simulation. See also the  simStartSimulation  function \n sim_message_simulation_pause_request \n The user wishes to pause a simulation. See also the  simPauseSimulation  function \n sim_message_simulation_stop_request \n The user wishes to stop a simulation. See also the  simStopSimulation  function \n \n \n Following messages are dispatched to the  plugins  (refer to the plugin  simMessage entry point ): \n \n sim_message_eventcallback_instancepass \n Called once every main client application loop pass. auxiliaryData[0] contains event flags of events that happened since last time. If you react to some of below event flags, make sure you do not react to their equivalent event callback message (e.g. sim_message_eventcallback_sceneloaded is similar to below\'s bit3 set) \n bit0 set: object(s) erased \n bit1 set: object(s) created \n bit2 set: model loaded \n bit3 set: scene loaded \n bit4 set: undo called \n bit5 set: redo called \n bit6 set: scene switched (react to this message in a similar way as you would react to a full scene content change) \n bit7 set: edit mode active. This is not an event flag, but a state flag \n bit8 set: object(s) scaled \n bit9 set: selection state changed. (different objects are selected now) \n bit10 set: key pressed \n bit11 set: simulation started \n bit12 set: simulation ended \n sim_message_eventcallback_uipass \n Called just after sim_message_eventcallback_instancepass, but from the UI thread \n sim_message_eventcallback_lastinstancepass \n Last call from the simulation thread to the plugin, that is unloading \n sim_message_eventcallback_instanceswitch \n scene was switched (react to this message in a similar way as you would react to a full scene content change) \n auxiliaryData[0]: do not use \n auxiliaryData[1]=current scene unique ID \n sim_message_eventcallback_instanceabouttoswitch \n we are about to switch to a different scene \n auxiliaryData[0]: do not use \n auxiliaryData[1]=next scene unique ID \n sim_message_eventcallback_scriptstatedestroyed \n The specified script state is destroyed \n auxiliaryData[0]: script handle \n sim_message_eventcallback_scriptdestroyed \n The specified script is destroyed \n auxiliaryData[0]: script handle \n sim_message_eventcallback_menuitemselected (called from the UI thread \n auxiliaryData[0]=handle of the item \n auxiliaryData[1]=state of the item \n sim_message_eventcallback_scenesave \n about to save a scene \n sim_message_eventcallback_modelsave \n about to save a model (current selection will be saved) \n sim_message_eventcallback_abouttoundo \n the undo button was hit and a previous state is about to be restored \n sim_message_eventcallback_undoperformed \n the undo button was hit and a previous state was restored \n sim_message_eventcallback_abouttoredo \n the redo button was hit and a future state is about to be restored \n sim_message_eventcallback_redoperformed \n the redo button was hit and a future state was restored \n sim_message_eventcallback_scripticondblclick (called from the UI thread) \n a script icon in the hierarchy view was double-clicked \n auxiliaryData[0]=object handle of the object associated with the  script \n replyData[0]: set to 1 if you do not want the double-click action to open the script editor \n sim_message_eventcallback_simulationabouttostart \n simulation will start \n sim_message_eventcallback_simulationabouttoend \n simulation will end \n sim_message_eventcallback_simulationended \n simulation has ended \n sim_message_eventcallback_simulationinit \n Called just before/after the main script\'s corresponding init section. \n auxiliaryData[0]: 0 if called before, 1 if called after \n sim_message_eventcallback_simulationactuation \n Called just before/after the main script\'s corresponding actuation section. \n auxiliaryData[0]: 0 if called before, 1 if called after \n auxiliaryData[1]: simulation time in ms \n sim_message_eventcallback_simulationsensing \n Called just before/after the main script\'s corresponding sensing section. \n auxiliaryData[0]: 0 if called before, 1 if called after \n auxiliaryData[1]: simulation time in ms \n sim_message_eventcallback_simulationcleanup \n Called just before/after the main script\'s corresponding cleanup section. \n auxiliaryData[0]: 0 if called before, 1 if called after \n sim_message_eventcallback_keypress (called from the UI thread) \n auxiliaryData[0]=key, auxiliaryData[1]=ctrl and shift key state \n sim_message_eventcallback_bannerclicked (called from the UI thread) \n called when a banner was clicked (auxiliaryData[0]=banner ID) \n sim_message_eventcallback_refreshdialogs (called from the UI thread) \n called just before dialogs are refreshed in CoppeliaSim. \n auxiliaryData[0]=refresh degree (0=light, 1=medium, 2=full) \n sim_message_eventcallback_sceneloaded \n called after a scene was loaded \n sim_message_eventcallback_modelloaded \n called after a model was loaded \n sim_message_eventcallback_mainscriptabouttobecalled \n Called just before the main script is called. If a plugin intercepts this message and writes a value different from -1 into replyData[0], the main script will not be called. \n \n \n Types of argument (input and output) for exchanging simple data between scripts and plugins \n \n sim_script_arg_null \n can be combined with sim_script_arg_table \n sim_script_arg_bool \n can be combined with sim_script_arg_table \n sim_script_arg_int32 \n can be combined with sim_script_arg_table \n sim_script_arg_float \n can be combined with sim_script_arg_table \n sim_script_arg_double \n can be combined with sim_script_arg_table \n sim_script_arg_string \n can be combined with sim_script_arg_table \n sim_script_arg_charbuff \n CANNOT be combined with sim_script_arg_table \n sim_script_arg_invalid \n sim_script_arg_table \n \nSee also the  simRegisterScriptCallbackFunction  function.\n \n \n \n Rendering attributes \n \n sim.displayattribute_renderpass sim.displayattribute_depthpass sim.displayattribute_pickpass sim.displayattribute_selected sim.displayattribute_groupselection sim.displayattribute_mainselection sim.displayattribute_forcewireframe sim.displayattribute_forbidwireframe sim.displayattribute_forbidedges sim.displayattribute_originalcolors sim.displayattribute_ignorelayer sim.displayattribute_forvisionsensor sim.displayattribute_trianglewireframe sim.displayattribute_simplifyasboundingbox \n sim.displayattribute_thickedges sim.displayattribute_dynamiccontentonly \n \n<div class="sim.displayattribute_mirror">sim.displayattribute_mirror</div>\n \n sim.displayattribute_useauxcomponent sim.displayattribute_ignorerenderableflag sim.displayattribute_noopenglcallbacks sim.displayattribute_nopointclouds sim.displayattribute_nodrawingobjects sim.displayattribute_noparticles sim.displayattribute_colorcodedtriangles \n \n \n \n Simulation status \n \n sim.simulation_stopped \n sim.simulation_paused \n sim.simulation_advancing_firstafterstop \n sim.simulation_advancing_running \n sim.simulation_advancing_lastbeforepause \n sim.simulation_advancing_firstafterpause \n sim.simulation_advancing_abouttostop \n sim.simulation_advancing_lastbeforestop \n \nSee also the  sim.getSimulationState  function.\n \n \n \n Main script execution result (might change in the future) \n \n sim_script_no_error \n sim_script_main_script_nonexistent \n sim_script_main_script_not_called \n sim_script_reentrance_error \n sim_script_lua_error \n \nSee also the  simHandleMainScript  function.\n \n \n \n Script types \n \n sim.scripttype_mainscript (0) sim.scripttype_childscript (1) sim.scripttype_addonscript (2) sim.scripttype_customizationscript (6) sim.scripttype_sandboxscript (8) \nSee also the  sim.getScriptProperty  function.\n \n \n \n Script parameters \n \n sim.scriptintparam_execorder   Integer attribute, see the  script execution priorities \n sim.scriptintparam_execcount   Integer attribute, cannot be written \n sim.scriptintparam_type   Integer attribute, cannot be written \n sim.scriptintparam_handle   Integer attribute, cannot be written \n sim.scriptintparam_objecthandle   Integer attribute, cannot be written \n sim.scriptintparam_enabled   Integer attribute \n sim.scriptstringparam_description   String attribute, describes the script \n sim.scriptstringparam_name   String attribute \n sim.scriptstringparam_text   String attribute \n \nSee also the  functions related to script parameters .\n \n \n \n Script execution priority \n \n sim.scriptexecorder_first sim.scriptexecorder_normal sim.scriptexecorder_last \nSee also the  script attributes . \n \n \n \n Special argument values \n \n sim.handle_absolute \n sim.handle_all \n sim.handle_all_except_explicit sim.handle_self sim.handle_main_script sim.handle_tree sim.handle_chain sim.handle_single sim.handle_default sim.handle_all_except_self sim.handle_parent sim.handle_scene sim.handle_app \n sim.handle_inverse \n \n \n \n Special handle flags \n \n sim.handleflag_assembly sim.handleflag_model sim.handleflag_rawvalue sim.handleflag_togglevisibility sim.handleflag_greyscale sim.handleflag_depthbuffermeters sim.handleflag_depthbuffer sim.handleflag_abscoords sim.handleflag_codedstring sim.handleflag_keeporiginal sim.handleflag_camera sim.handleflag_axis sim.handleflag_silenterror \n sim.handleflag_resetforce \n sim.handleflag_resettorque \n sim.handleflag_absolutecoords \n sim.handleflag_relativecoords \n sim.handleflag_wxyzquaternion \n sim.handleflag_reljointbaseframe \n sim.handleflag_setmultiple \n \n \n \n Generic dialog styles \n \n sim.dlgstyle_message sim.dlgstyle_input sim.dlgstyle_ok sim.dlgstyle_ok_cancel sim.dlgstyle_yes_no\n \n \n \n \n Generic dialog return values \n \n sim.dlgret_still_open sim.dlgret_ok sim.dlgret_cancel sim.dlgret_yes sim.dlgret_no \n \n \n \n Path object properties (can be combined with the OR operator) \n \n sim.pathproperty_show_line sim.pathproperty_show_orientation sim.pathproperty_closed_path sim.pathproperty_automatic_orientation sim.pathproperty_flat_path sim.pathproperty_show_position sim.pathproperty_keep_x_up \n \n \n \n Custom drawing objects \n \n Drawing object type (combine with drawing object attributes): \n \n sim.drawing_points items are pixel-sized points (3 values per item (x;y;z)) \n sim.drawing_lines items are pixel-sized lines (6 values per item (x0;y0;z0;x1;y1;z1)) \n sim.drawing_linestrip items are pixel-sized lines (3 values per line strip corner or end-point) \n sim.drawing_triangles items are triangles (9 values per item (x0;y0;z0;x1;y1;z1;x2;y2;z2)) \n sim.drawing_trianglepts \n items are "triangle points" (7 values per item (x;y;z;Qx;Qy;Qz;Qw) (Q=quaternion))) \n sim.drawing_quadpts \n items are "rectangle points" (7 values per item (x;y;z;Qx;Qy;Qz;Qw) (Q=quaternion))) \n sim.drawing_discpts \n items are "disc points" (7 values per item (x;y;z;Qx;Qy;Qz;Qw) (Q=quaternion))) \n sim.drawing_cubepts \n items are "cube points" (7 values per item (x;y;z;Qx;Qy;Qz;Qw) (Q=quaternion))) \n sim.drawing_spherepts items are "sphere points" (3 values per item (x;y;z)) \n \n Drawing object attributes: \n \n sim.drawing_cyclic if the drawing object is full, then the first items are overwritten \n \nSee also the  sim.addDrawingObject  function.\n \n \n \n Particle objects \n \n Particle object type (combine with particle object attributes). Each item (particle) requires 6 values + auxiliary values, where the 6 values are: pt1x, pt1y, pt1z, pt2x, pt2y, pt2z (Pt1 is start position, pt2-pt1 is the initial velocity vector) \n \n sim.particle_points1 \n items are displayed as 1 pixel-sized points (internally handled as a perfect sphere) \n sim.particle_points2 \n items are displayed as 2 pixel-sized points (internally handled as a perfect sphere) \n sim.particle_points4 \n items are displayed as 4 pixel-sized points (internally handled as a perfect sphere) \n sim.particle_roughspheres \n items are displayed as rough spheres (internally handled as a perfect sphere) \n sim.particle_spheres \n items are displayed as spheres \n \n Particle object attributes: \n \n sim.particle_respondable1to4 \n the particles are respondable against shapes that have at least one bit 1-4 activated in the global respondable mask \n sim.particle_respondable5to8 \n the particles are respondable against shapes that have at least one bit 5-8 activated in the global respondable mask \n sim.particle_particlerespondable \n the particles are respondable against each other \n sim.particle_ignoresgravity \n the particles ignore the effect of gravity \n sim.particle_invisible \n the particles are invisible \n sim.particle_painttag \n the particles are visible when seen from vision sensors. sim.particle_invisible must not be set \n sim.particle_cyclic \n if the max particle count was reached, then the first particles are overwritten \n sim.particle_itemsizes \n +1 auxiliary value per particle (each particle can have a different size) \n sim.particle_itemdensities \n +1 auxiliary value per particle (each particle can have a different density) \n sim.particle_itemcolors \n +3 auxiliary values per particle (each particle can have a different ambient_diffuse color) \n sim.particle_emissioncolor \n when used in combination with sim.particle_itemcolors, then the specified colors will be for the emissive component \n sim.particle_water \n particles are water particles (no weight in the water (i.e. when z<0)). In addition to that, particles can have drag coefficients for the water and the air. Not compatible with sim.particle_ignoresgravity \n \nSee also the  sim.addParticleObject  function.\n \n \n \n bool parameters \n \n sim.boolparam_hierarchy_visible \n sim.boolparam_hierarchy_toolbarbutton_enabled \n sim.boolparam_browser_visible \n sim.boolparam_browser_toolbarbutton_enabled \n sim.boolparam_objproperties_toolbarbutton_enabled \n sim.boolparam_calcmodules_toolbarbutton_enabled \n sim.boolparam_objectshift_toolbarbutton_enabled \n sim.boolparam_objectrotate_toolbarbutton_enabled \n sim.boolparam_play_toolbarbutton_enabled \n sim.boolparam_pause_toolbarbutton_enabled \n sim.boolparam_stop_toolbarbutton_enabled \n sim.boolparam_console_visible \n sim.boolparam_dynamics_handling_enabled \n sim.boolparam_scene_and_model_load_messages \n displays warning/error messages when loading a scene/model/UI from the API \n sim.boolparam_shape_textures_are_visible \n sim.boolparam_display_enabled \n setting this to false allows you to enter the fast simulation mode. This value can be set back to true at any time by the system \n sim.boolparam_infotext_visible \n sim.boolparam_statustext_open \n sim.boolparam_fog_enabled \n sim.boolparam_aux_clip_planes_enabled \n sim.boolparam_use_glfinish_cmd \n sim.boolparam_video_recording_triggered \n sim.boolparam_fullscreen \n can only be read/written during simulation. \n sim.boolparam_headless \n whether the simulator runs without GUI. Can only be read. \n sim.boolparam_force_calcstruct_all_visible \n Will trigger the calculation of all visible shapes\' calculation structures (needed for collision detection, distance calculation or proximity sensor operation). Might take some time. \n sim.boolparam_force_calcstruct_all \n Will trigger the calculation of all shapes\' calculation structures (needed for collision detection, distance calculation or proximity sensor operation). Might take some time. \n sim.boolparam_exit_request \n Posts the exit command. Can only be written, and has only an effect when simulation is not running and no edit mode is enabled. See also  sim.quitSimulator . \n sim.boolparam_realtime_simulation \n sim.boolparam_scene_closing \n Indicates that the current scene is closing. Can only be read. \n sim.boolparam_rayvalid \n Indicates that the ray data is valid. Can only be read. \n \nSee also the  sim.getBoolParam  and  sim.setBoolParam  functions.\n \n \n \n Integer parameters \n \n sim.intparam_program_version \n e.g Version 2.1.4 --> 20104. Can only be read. See also sim.intparam_program_revision and sim.intparam_program_full_version. \n sim.intparam_program_revision \n Can only be read. See also sim_intparam_program_version. \n sim.intparam_program_full_version \n e.g Version 2.1.4 rev5 --> 2010405. Can only be read. \n sim_intparam_custom_cmd_start_id \n start of custom command IDs. Can only be read \n sim.intparam_compilation_version \n 0=CoppeliaSim Edu version, 1=CoppeliaSim Pro version, 2=CoppeliaSim Player version. Can only be read \n sim.intparam_current_page \n Can only be read \n sim.intparam_dynamic_step_divider \n Represents the number of calculation passes of the dynamics module for each simulation pass. This might be not constant during a simulation. Can be 0 when  sim.handleDynamics  wasn\'t yet called. Can only be read \n sim.intparam_dynamic_engine \n 0= Bullet , 1= ODE , 2= Vortex , 3= Newton . \n sim.intparam_server_port_start \n together with sim.intparam_server_port_next and sim.intparam_server_port_range, indicates which local ports can be used. Can only be read \n sim.intparam_server_port_range \n together with sim.intparam_server_port_next and sim.intparam_server_port_start, indicates which local ports can be used. Can only be read \n sim.intparam_server_port_next \n Indicates which local ports can be used next. Once that port was used, update this value according to the values stored in sim.intparam_server_port_start and sim.intparam_server_port_range \n sim.intparam_visible_layers \n sim.intparam_infotext_style \n allowed values are 0-2 \n sim.intparam_settings \n Use with care, and always reset to initial values at simulation end \n bit1: edge antialiasing \n bit2: world reference display \n bit3: bounding box display \n bit4: don\'t use Frame Buffer Objects for vision sensors \n bit5: undo/redo enabled \n sim.intparam_edit_mode_type \n Can only be read: \n 0: no edit mode \n 1: triangle edit mode \n 2: vertex edit mode \n 3: edge edit mode \n 4: path edit mode \n 5: button edit mode \n 6: compound shapes edit mode \n sim.intparam_qt_version \n The Qt version. Can only be read \n sim.intparam_event_flags_read \n Some event flags. Can only be read: \n bit0 set: object(s) erased \n bit1 set: object(s) created \n bit2 set: model loaded \n bit3 set: scene loaded \n bit4 set: undo called \n bit5 set: redo called \n bit6 set: scene switched (react to this message in a similar way as you would react to a full scene content change) \n bit7 set: edit mode active. This is not an event flag, but a state flag \n bit8 set: object(s) scaled \n bit9 set: selection state changed. (different objects are selected now) \n bit10 set: key pressed \n bit11 set: simulation started \n bit12 set: simulation ended \n sim.intparam_event_flags_read_clear \n Some event flags. Reads the flags and clears them right after \n sim.intparam_platform \n 0=Windows, 1=Macintosh, 2=Linux. Can only be read \n sim.intparam_scene_unique_id \n A unique ID for the current scene. Different from one scene load to the next. Useful to identify scene switches. Can only be read. See also sim.stringparam_scene_unique_id \n sim.intparam_mouse_x \n sim.intparam_mouse_y \n sim.intparam_mouse_buttons \n Bit-coded: bit0 set=left button, bit1 set=middle wheel activity, bit2 set=right button, bit3 set=middle wheel down. \n sim.intparam_core_count \n The number of cores on this machine. Can only be read. \n sim.intparam_idle_fps \n sim.intparam_stop_request_counter \n a counter that is incremented each time a stop simulation request arrives (e.g. via the toolbar button, menu, etc.) \n sim.intparam_dynamic_warning_disabled_mask \n a bit-coded mask that allows to temporarily disable warning messages from the physics engine: \n bit 0 set (1): pure spheroids are not supported \n bit 1 set (2): pure cones are not supported \n bit 2 set (4): pure hollow shapes are not supported \n bit 3 set (8): physics engine is not supported supported \n bit 4 set (16): scene contains non-pure, non-convex shapes \n bit 5 set (32): scene contains static shapes on dynamic construction \n bit 6 set (64): non-default physics engine settings \n bit 7 set (128): Vortex plugin is demo version \n bit 8 set (256): dynamic non-convex meshes are not supported with the selected engine. \n sim.intparam_simulation_warning_disabled_mask \n a bit-coded mask that allows to temporarily disable warning messages related to simulation: \n bit 0 set (1): non-default parameters used \n sim.intparam_scene_index \n when written, will be executed in a delayed fashion. \n sim.intparam_motionplanning_seed \n Specify a value that initializes the random number generator for the motion planning functionality. Can only be written. \n sim.intparam_speedmodifier \n Can only be read/written when simulation is not stopped. \n sim.intparam_dynamic_iteration_count \n The number of calculation iterations of the currently selected physics engine. Can only be written when using a  customized configuration for the physics engine , and when simulation is stopped. \n sim.intparam_verbosity \n the console  verbosity level . \n sim.intparam_statusbarverbosity \n the status bar  verbosity level . \n sim.intparam_dlgverbosity \n the  verbosity level  of simple dialogs. \n sim.intparam_mouseclickcounterdown \n a simple mouse down counter, for mouse clicks. Cannot be written \n sim.intparam_mouseclickcounterup \n a simple mouse up counter, for mouse clicks. Cannot be written \n \nSee also the  sim.getInt32Param  and  sim.setInt32Param  functions.\n \n \n \n uint64 parameters \n \n sim_uint64param_simulation_time_step_ns \n The simulation time step in nanoseconds. (for versions prior to CoppeliaSim V4.1.0 rev2 this would be the time step in microseconds, due to a bug) \n sim_uint64param_simulation_time_ns \n The simulation time in nanoseconds. (for versions prior to CoppeliaSim V4.1.0 rev2 this would be the time in microseconds, due to a bug) \n \nSee also the  simGetUInt64Parameter  function.\n \n \n \n Floating point parameters \n \n sim.floatparam_rand \n Returns a random value in the range [0.0;1.0]. Useful when called from Lua since each script instance will initialize its random number generator in a same way, and thus, \'random\' values generated in different scripts will be relatively \'similar\'. This is not the case with this random value. Can only be read. See also  sim.getRandom ,  math.random2  and  math.randomseed2 . \n sim.floatparam_simulation_time_step \n The simulation time step (i.e. dt). Can only be written when using a custom dt value (which can be set in the  simulation settings dialog ), and when simulation is stopped. \n sim.floatparam_stereo_distance \n The camera intra occular distance when in 3D OpenGl stereo mode. \n sim.floatparam_dynamic_step_size \n The step size of the currently selected physics engine. Can only be written when using a  customized configuration for the physics engine , and when simulation is stopped. \n \nSee also the  sim.getFloatParam  and  sim.setFloatParam  functions.\n\n \n \n \n String parameters \n \n sim.stringparam_application_path \n can only be read \n sim.stringparam_scene_path_and_name \n can only be read \n sim.stringparam_scene_path \n can only be read \n sim.stringparam_scene_name \n can only be read \n sim.stringparam_video_filename \n path + filename without extension \n sim.stringparam_scene_unique_id \n A unique ID for the current scene. The id will be same if the scene if opened several times. Can only be read. See also sim.intparam_scene_unique_id \n sim.stringparam_app_arg1 \n the 1st argument specified via command line option -g \n sim.stringparam_app_arg2 \n the 2nd argument specified via command line option -g \n sim.stringparam_app_arg3 \n the 3rd argument specified via command line option -g \n sim.stringparam_app_arg4 \n the 4th argument specified via command line option -g \n sim.stringparam_app_arg5 \n the 5th argument specified via command line option -g \n sim.stringparam_app_arg6 \n the 6th argument specified via command line option -g \n sim.stringparam_app_arg7 \n the 7th argument specified via command line option -g \n sim.stringparam_app_arg8 \n the 8th argument specified via command line option -g \n sim.stringparam_app_arg9 \n the 9th argument specified via command line option -g \n sim.stringparam_verbosity \n Can only be written. \n sim.stringparam_statusbarverbosity \n Can only be written. \n sim.stringparam_dlgverbosity \n Can only be written. \n sim.stringparam_consolelogfilter \n Format as: txta1&txta2&...&txtaN|txtb1&txtb2&...&txtbN|... \n sim.stringparam_tempdir \n Can only be read. \n sim.stringparam_tempscenedir \n Can only be read. \n sim.stringparam_datadir \n Can only be read. \n sim.stringparam_luadir \n Can only be read. \n sim.stringparam_pythondir \n Can only be read. \n sim.stringparam_addonpath \n Can only be read. \n\nsim_stringparam_addonpath\n\n \nSee also the  sim.getStringParam  function.\n \n \n Verbosity \n \n sim.verbosity_useglobal \n Use global verbosity (can be used to reset a plugin\'s verbosity to the global verbosity again) \n sim.verbosity_none \n No verbosity \n sim.verbosity_errors \n System and plugin error messages \n sim.verbosity_warnings \n System and plugin warning messages \n sim.verbosity_loadinfos \n Messages related to CoppeliaSim start-up and shut-down. Default console verbosity. \n sim.verbosity_questions \n Messages related to question dialogs. \n sim.verbosity_scripterrors \n Script error messages \n sim.verbosity_scriptwarnings \n Script warning messages \n sim.verbosity_scriptinfos \n Information messages mainly related to scripts. Default status bar verbosity. \n sim.verbosity_infos \n General information messages \n sim.verbosity_debug \n Debug messages \n sim.verbosity_trace \n Plugin trace messages \n sim.verbosity_tracelua \n Script calls to API functions \n sim.verbosity_traceall \n Full verbosity \n sim.verbosity_default \n Default verbosity (normally sim.verbosity_loadinfos) \n \nSee also  sim.getInt32Param (sim.intparam_verbosity),  sim.setInt32Param (sim.intparam_verbosity,verbosity) and  sim.setModuleInfo (pluginName,sim.moduleinfo_verbosity,verbosity). For statusbar verbosity, use sim.intparam_statusbarverbosity or sim.moduleinfo_statusbarverbosity.\n \n \n \n Module infos \n \n sim.moduleinfo_extversionstr \n Extended version string \n sim.moduleinfo_builddatestr \n Build date string \n sim.moduleinfo_extversionint \n Extended version integer \n sim.moduleinfo_verbosity \n Console verbosity. see the various  verbosity levels \n sim.moduleinfo_statusbarverbosity \n Status bar verbosity. see the various  verbosity levels \n \nSee also  sim.getModuleInfo  and  sim.setModuleInfo .\n \n \n \n Array parameters \n \n sim.arrayparam_gravity \n 3 floats \n sim.arrayparam_fog \n 3 floats: fog start, fog end, fog density \n sim.arrayparam_fog_color \n 3 floats \n sim.arrayparam_background_color1 \n 3 floats \n sim.arrayparam_background_color2 \n 3 floats \n sim.arrayparam_ambient_light \n 3 floats \n sim.arrayparam_random_euler \n 3 floats. Can only be read. \n sim.arrayparam_rayorigin \n 3 floats indicating the origin of the current camera-mouse ray. Can only be read \n sim.arrayparam_raydirection \n 3 floats indicating the direction of the current camera-mouse ray. Can only be read \n \nSee also the  sim.getArrayParam  and  sim.setArrayParam  functions.\n \n \n \n Mouse navigation and selection modes \n \n sim.navigation_passive \n sim.navigation_camerashift \n sim.navigation_camerarotate \n sim.navigation_camerazoom \n sim.navigation_cameratilt \n sim.navigation_cameraangle \n sim.navigation_objectshift \n sim.navigation_objectrotate \n \n Bit-combine following values and add them to one of above\'s values for a valid navigation mode:  \n \n sim.navigation_clickselection \n sim.navigation_ctrlselection \n sim.navigation_shiftselection \n sim.navigation_camerazoomwheel \n sim.navigation_camerarotatemiddlebutton \n \nSee also the  sim.getNavigationMode  and  sim.setNavigationMode  functions.\n \n \n \n Bit-coded start-up options \n \n sim_gui_menubar (1) \n sim_gui_popups (2) \n sim_gui_toolbar1 (4) \n sim_gui_toolbar2 (8) \n sim_gui_hierarchy (16) \n sim_gui_infobar (32) \n sim_gui_statusbar (64) \n sim_gui_scripteditor (128) \n sim_gui_scriptsimulationparameters (256) \n sim_gui_dialogs (512) \n sim_gui_browser (1024) \n sim_gui_all (0x0ffff) \n sim_gui_headless (will override all other GUI flags) (65536) \n sim_autostart (0x20000) (automatically starts the simulation) \n sim_autoquit (0x40000) (automatically quits at end of first simulation) \n \nSee also the  simRunSimulator  function.\n \n \n \n Joint modes \n \n sim.jointmode_kinematic \n sim.jointmode_dependent \n sim.jointmode_dynamic \n \nSee also the  sim.setJointMode  function.\n \n \n \n Dynamic joint control modes \n \n sim.jointdynctrl_free \n sim.jointdynctrl_force \n sim.jointdynctrl_velocity \n sim.jointdynctrl_position \n sim.jointdynctrl_spring \n sim.jointdynctrl_callback \n \nSee also the  sim.setObjectInt32Param  function.\n \n \n \n Ruckig Online Trajectory Generator constants \n \n select exactly one of following: \n sim.ruckig_phasesync (default) \n sim.ruckig_timesync \n sim.ruckig_nosync \n and optionally combine with any of following: \n sim.ruckig_minvel: for situation where minVel!=-maxVel, i.e. for an asymmetric behaviour \n sim.ruckig_minaccel: for situation where minAccel!=-maxAccel, i.e. for an asymmetric behaviour \n \n \n Primitive shape types \n \n sim.primitiveshape_none \n sim.primitiveshape_plane \n sim.primitiveshape_disc \n sim.primitiveshape_cuboid \n sim.primitiveshape_spheroid \n sim.primitiveshape_cylinder \n sim.primitiveshape_cone \n sim.primitiveshape_capsule \n sim.primitiveshape_heightfield \n \nSee also the  sim.getShapeGeomInfo  and  sim.createPrimitiveShape  functions  \n \n Dummy link types \n \n sim.dummy_linktype_dynamics_loop_closure \n \n \n Physics engine types \n \n sim.physics_bullet \n sim.physics_ode \n sim.physics_newton \n sim.physics_vortex \n \n \n Texture mapping modes \n \n sim.texturemap_plane \n sim.texturemap_cylinder \n sim.texturemap_sphere \n sim.texturemap_cube \n \nSee also the  sim.setShapeTexture  function.\n \n \n Color components \n \n sim.colorcomponent_ambient_diffuse (only for objects) \n sim.colorcomponent_diffuse (only for lights) \n sim.colorcomponent_specular \n sim.colorcomponent_emission (only for objects) \n sim.colorcomponent_transparency (only for objects) \n sim.colorcomponent_auxiliary (only for objects) \n \nSee also the  sim.setShapeColor  function.\n \n \n Proximity sensor volume types \n \n sim.volume_pyramid \n sim.volume_cylinder \n sim.volume_disc \n sim.volume_cone \n sim.volume_ray \n sim.volume_randomizedray \n \n \n Buffer types with allowed transformations \n \n sim.buffer_uint8 \n --> sim.buffer_uint8,sim.buffer_uint8rgb,sim.buffer_base64 (multiplier and offset are ignored),sim.buffer_split (multiplier is ignored, offset is the split size) \n sim.buffer_uint8rgb \n --> sim.buffer_uint8rgb,sim.buffer_uint8bgr,sim.buffer_uint8 \n sim.buffer_uint8bgr \n --> sim.buffer_uint8bgr,sim.buffer_uint8rgb,sim.buffer_uint8 \n sim.buffer_uint8rgba \n --> sim.buffer_uint8rgba,sim.buffer_uint8rgb \n sim.buffer_uint8argb \n --> sim.buffer_uint8argb,sim.buffer_uint8rgb \n sim.buffer_float \n --> sim.buffer_uint8, sim.buffer_int8, sim.buffer_uint16, sim.buffer_int16, sim.buffer_uint32, \n sim.buffer_int32,sim.buffer_float,sim.buffer_double,sim.buffer_uint8rgb \n sim.buffer_double \n --> sim.buffer_uint8, sim.buffer_int8, sim.buffer_uint16, sim.buffer_int16, sim.buffer_uint32, \n sim.buffer_int32,sim.buffer_float,sim.buffer_double,sim.buffer_uint8rgb \n sim.buffer_base64 (multiplier and offset are ignored) \n --> sim.buffer_uint8 \n \nSee also the  sim.transformBuffer  function.\n \n \n Image combination operations \n \n sim.imgcomb_vertical: vertical concatenation \n sim.imgcomb_horizontal: horizontal concatenation \n \nSee also the  sim.combineRgbImages  function.\n \n \n Graph stream transformations \n \n sim.stream_transf_raw \n sim.stream_transf_derivative \n sim.stream_transf_integral \n sim.stream_transf_cumulative \n \nSee also the  sim.setGraphStreamTransformation  function.\n \n \n Predefined dynamic material types \n \n sim.dynmat_default \n sim.dynmat_highfriction \n sim.dynmat_lowfriction \n sim.dynmat_nofriction \n sim.dynmat_reststackgrasp \n sim.dynmat_foot \n sim.dynmat_wheel \n sim.dynmat_gripper \n sim.dynmat_floor \n \n \n Physics engine properties \n \n sim.bullet_global_stepsize (float parameter) \n sim.bullet_global_internalscalingfactor (float parameter) \n sim.bullet_global_collisionmarginfactor (float parameter) \n sim.bullet_global_constraintsolvingiterations (int parameter) \n sim.bullet_global_constraintsolvertype (int parameter) \n See also  the Bullet solver types . \n sim.bullet_global_fullinternalscaling (bool parameter) \n \n sim.bullet_joint_stoperp (float parameter) \n sim.bullet_joint_stopcfm (float parameter) \n sim.bullet_joint_normalcfm (float parameter) \n \n sim.bullet_body_restitution (float parameter) \n sim.bullet_body_oldfriction (float parameter) \n sim.bullet_body_friction (float parameter) \n sim.bullet_body_lineardamping (float parameter) \n sim.bullet_body_angulardamping (float parameter) \n sim.bullet_body_nondefaultcollisionmargingfactor (float parameter) \n sim.bullet_body_nondefaultcollisionmargingfactorconvex (float parameter) \n sim.bullet_body_sticky (bool parameter) \n sim.bullet_body_usenondefaultcollisionmargin (bool parameter) \n sim.bullet_body_usenondefaultcollisionmarginconvex (bool parameter) \n sim.bullet_body_autoshrinkconvex (bool parameter) \n \n \n sim.ode_global_stepsize (float parameter) \n sim.ode_global_internalscalingfactor (float parameter) \n sim.ode_global_cfm (float parameter) \n sim.ode_global_erp (float parameter) \n sim.ode_global_constraintsolvingiterations (int parameter) \n sim.ode_global_randomseed (int parameter) \n sim.ode_global_fullinternalscaling (bool parameter) \n sim.ode_global_quickstep (bool parameter) \n \n sim.ode_joint_stoperp (float parameter) \n sim.ode_joint_stopcfm (float parameter) \n sim.ode_joint_bounce (float parameter) \n sim.ode_joint_fudgefactor (float parameter) \n sim.ode_joint_normalcfm (float parameter) \n \n sim.ode_body_friction (float parameter) \n sim.ode_body_softerp (float parameter) \n sim.ode_body_softcfm (float parameter) \n sim.ode_body_lineardamping (float parameter) \n sim.ode_body_angulardamping (float parameter) \n sim.ode_body_maxcontacts (int parameter) \n \n \n sim.vortex_global_stepsize (float parameter) \n sim.vortex_global_internalscalingfactor (float parameter) \n sim.vortex_global_contacttolerance (float parameter) \n sim.vortex_global_constraintlinearcompliance (float parameter) \n sim.vortex_global_constraintlineardamping (float parameter) \n sim.vortex_global_constraintlinearkineticloss (float parameter) \n sim.vortex_global_constraintangularcompliance (float parameter) \n sim.vortex_global_constraintangulardamping (float parameter) \n sim.vortex_global_constraintangularkineticloss (float parameter) \n sim.vortex_global_autosleep (bool parameter) \n sim.vortex_global_multithreading (bool parameter) \n \n sim.vortex_joint_lowerlimitdamping (float parameter) \n sim.vortex_joint_upperlimitdamping (float parameter) \n sim.vortex_joint_lowerlimitstiffness (float parameter) \n sim.vortex_joint_upperlimitstiffness (float parameter) \n sim.vortex_joint_lowerlimitrestitution (float parameter) \n sim.vortex_joint_upperlimitrestitution (float parameter) \n sim.vortex_joint_lowerlimitmaxforce (float parameter) \n sim.vortex_joint_upperlimitmaxforce (float parameter) \n sim.vortex_joint_motorconstraintfrictioncoeff (float parameter) \n sim.vortex_joint_motorconstraintfrictionmaxforce (float parameter) \n sim.vortex_joint_motorconstraintfrictionloss (float parameter) \n sim.vortex_joint_p0loss (float parameter) \n sim.vortex_joint_p0stiffness (float parameter) \n sim.vortex_joint_p0damping (float parameter) \n sim.vortex_joint_p0frictioncoeff (float parameter) \n sim.vortex_joint_p0frictionmaxforce (float parameter) \n sim.vortex_joint_p0frictionloss (float parameter) \n sim.vortex_joint_p1loss (float parameter) \n sim.vortex_joint_p1stiffness (float parameter) \n sim.vortex_joint_p1damping (float parameter) \n sim.vortex_joint_p1frictioncoeff (float parameter) \n sim.vortex_joint_p1frictionmaxforce (float parameter) \n sim.vortex_joint_p1frictionloss (float parameter) \n sim.vortex_joint_p2loss (float parameter) \n sim.vortex_joint_p2stiffness (float parameter) \n sim.vortex_joint_p2damping (float parameter) \n sim.vortex_joint_p2frictioncoeff (float parameter) \n sim.vortex_joint_p2frictionmaxforce (float parameter) \n sim.vortex_joint_p2frictionloss (float parameter) \n sim.vortex_joint_a0loss (float parameter) \n sim.vortex_joint_a0stiffness (float parameter) \n sim.vortex_joint_a0damping (float parameter) \n sim.vortex_joint_a0frictioncoeff (float parameter) \n sim.vortex_joint_a0frictionmaxforce (float parameter) \n sim.vortex_joint_a0frictionloss (float parameter) \n sim.vortex_joint_a1loss (float parameter) \n sim.vortex_joint_a1stiffness (float parameter) \n sim.vortex_joint_a1damping (float parameter) \n sim.vortex_joint_a1frictioncoeff (float parameter) \n sim.vortex_joint_a1frictionmaxforce (float parameter) \n sim.vortex_joint_a1frictionloss (float parameter) \n sim.vortex_joint_a2loss (float parameter) \n sim.vortex_joint_a2stiffness (float parameter) \n sim.vortex_joint_a2damping (float parameter) \n sim.vortex_joint_a2frictioncoeff (float parameter) \n sim.vortex_joint_a2frictionmaxforce (float parameter) \n sim.vortex_joint_a2frictionloss (float parameter) \n sim.vortex_joint_dependencyfactor (float parameter) \n sim.vortex_joint_dependencyoffset (float parameter) \n sim.vortex_joint_relaxationenabledbc (int parameter) \n Bit-coded, 3 bits for the linear x/y/z, 3 bits for the angular x/y/z. \n sim.vortex_joint_frictionenabledbc (int parameter) \n Bit-coded, 3 bits for the linear x/y/z, 3 bits for the angular x/y/z. \n sim.vortex_joint_frictionproportionalbc (int parameter) \n Bit-coded, 3 bits for the linear x/y/z, 3 bits for the angular x/y/z. \n sim.vortex_joint_objectid (int parameter) \n sim.vortex_joint_dependentobjectid (int parameter) \n sim.vortex_joint_motorfrictionenabled (bool parameter) \n sim.vortex_joint_proportionalmotorfriction (bool parameter) \n \n sim.vortex_body_primlinearaxisfriction (float parameter) \n sim.vortex_body_seclinearaxisfriction (float parameter) \n sim.vortex_body_primangularaxisfriction (float parameter) \n sim.vortex_body_secangularaxisfriction (float parameter) \n sim.vortex_body_normalangularaxisfriction (float parameter) \n sim.vortex_body_primlinearaxisstaticfrictionscale (float parameter) \n sim.vortex_body_seclinearaxisstaticfrictionscale (float parameter) \n sim.vortex_body_primangularaxisstaticfrictionscale (float parameter) \n sim.vortex_body_secangularaxisstaticfrictionscale (float parameter) \n sim.vortex_body_normalangularaxisstaticfrictionscale (float parameter) \n sim.vortex_body_compliance (float parameter) \n sim.vortex_body_damping (float parameter) \n sim.vortex_body_restitution (float parameter) \n sim.vortex_body_restitutionthreshold (float parameter) \n sim.vortex_body_adhesiveforce (float parameter) \n sim.vortex_body_linearvelocitydamping (float parameter) \n sim.vortex_body_angularvelocitydamping (float parameter) \n sim.vortex_body_primlinearaxisslide (float parameter) \n sim.vortex_body_seclinearaxisslide (float parameter) \n sim.vortex_body_primangularaxisslide (float parameter) \n sim.vortex_body_secangularaxisslide (float parameter) \n sim.vortex_body_normalangularaxisslide (float parameter) \n sim.vortex_body_primlinearaxisslip (float parameter) \n sim.vortex_body_seclinearaxisslip (float parameter) \n sim.vortex_body_primangularaxisslip (float parameter) \n sim.vortex_body_secangularaxisslip (float parameter) \n sim.vortex_body_normalangularaxisslip (float parameter) \n sim.vortex_body_autosleeplinearspeedthreshold (float parameter) \n sim.vortex_body_autosleeplinearaccelthreshold (float parameter) \n sim.vortex_body_autosleepangularspeedthreshold (float parameter) \n sim.vortex_body_autosleepangularaccelthreshold (float parameter) \n sim.vortex_body_skinthickness (float parameter) \n sim.vortex_body_autoangulardampingtensionratio (float parameter) \n sim.vortex_body_primaxisvectorx (float parameter) \n sim.vortex_body_primaxisvectory (float parameter) \n sim.vortex_body_primaxisvectorz (float parameter) \n sim.vortex_body_primlinearaxisfrictionmodel (int parameter) \n See also  the Vortex friction models . \n sim.vortex_body_seclinearaxisfrictionmodel (int parameter) \n See also  the Vortex friction models . \n sim.vortex_body_primangulararaxisfrictionmodel (int parameter) \n See also  the Vortex friction models . \n sim.vortex_body_secmangulararaxisfrictionmodel (int parameter) \n See also  the Vortex friction models . \n sim.vortex_body_normalmangulararaxisfrictionmodel (int parameter) \n See also  the Vortex friction models . \n sim.vortex_body_autosleepsteplivethreshold (int parameter) \n sim.vortex_body_materialuniqueid (int parameter) \n sim.vortex_body_pureshapesasconvex (bool parameter) \n sim.vortex_body_convexshapesasrandom (bool parameter) \n sim.vortex_body_randomshapesasterrain (bool parameter) \n sim.vortex_body_fastmoving (bool parameter) \n sim.vortex_body_autoslip (bool parameter) \n sim.vortex_body_seclinaxissameasprimlinaxis (bool parameter) \n sim.vortex_body_secangaxissameasprimangaxis (bool parameter) \n sim.vortex_body_normangaxissameasprimangaxis (bool parameter) \n sim.vortex_body_autoangulardamping (bool parameter) \n \n \n sim.newton_global_stepsize (float parameter) \n sim.newton_global_contactmergetolerance (float parameter) \n sim.newton_global_constraintsolvingiterations (int parameter) \n sim.newton_global_multithreading (bool parameter) \n sim.newton_global_exactsolver (bool parameter) \n sim.newton_global_highjointaccuracy (bool parameter) \n \n sim.newton_joint_dependencyfactor (float parameter) \n sim.newton_joint_dependencyoffset (float parameter) \n sim.newton_joint_objectid (int parameter) \n sim.newton_joint_dependentobjectid (int parameter) \n \n sim.newton_body_staticfriction (float parameter) \n sim.newton_body_kineticfriction (float parameter) \n sim.newton_body_restitution (float parameter) \n sim.newton_body_lineardrag (float parameter) \n sim.newton_body_angulardrag (float parameter) \n sim.newton_body_fastmoving (bool parameter) \n \n \nSee also  the related setter and getter API functions .\n \n \n Bullet solver types \n \n sim.bullet_constraintsolvertype_sequentialimpulse \n sim.bullet_constraintsolvertype_nncg \n sim.bullet_constraintsolvertype_dantzig \n sim.bullet_constraintsolvertype_projectedgaussseidel \n \nSee also the  physics engine properties .\n \n \n Vortex friction models \n \n sim.vortex_bodyfrictionmodel_box \n sim.vortex_bodyfrictionmodel_scaledbox \n sim.vortex_bodyfrictionmodel_proplow \n sim.vortex_bodyfrictionmodel_prophigh \n sim.vortex_bodyfrictionmodel_scaledboxfast \n sim.vortex_bodyfrictionmodel_neutral \n sim.vortex_bodyfrictionmodel_none \n \nSee also the  physics engine properties .\n \n \n \n \n \n \n \n', 'tags': '', 'url': 'apiConstants.html'}, {'title': 'objectParameterIDs', 'text': "\n \n \n \n \n Object Parameter IDs \n Refer to the API functions  sim.getObjectInt32Param ,  sim.setObjectInt32Param ,  sim.getObjectFloatParam ,  sim.setObjectFloatParam ,  sim.getObjectStringParam  and  sim.setObjectStringParam  for details on following values: \n \n Scene objects \n \n sim.objintparam_visibility_layer (10) \n int32 parameter : object visibility layer \n sim.objfloatparam_abs_x_velocity (11) float parameter (can only be read) : object absolute x velocity. This is a calculated value. Refer also to  sim.getObjectVelocity . \n sim.objfloatparam_abs_y_velocity (12) float parameter (can only be read) : object absolute y velocity. This is a calculated value. Refer also to  sim.getObjectVelocity . \n sim.objfloatparam_abs_z_velocity (13) float parameter (can only be read) : object absolute z velocity. This is a calculated value. Refer also to  sim.getObjectVelocity . \n sim.objfloatparam_abs_rot_velocity (14) float parameter (can only be read) : object absolute rotational velocity. This is a calculated value. Refer also to  sim.getObjectVelocity . \n sim.objfloatparam_objbbox_min_x (15) float parameter (can only be read) : object bounding box, min. x position (relative to the object reference frame) \n sim.objfloatparam_objbbox_min_y (16) float parameter (can only be read) : object bounding box, min. y position (relative to the object reference frame) \n sim.objfloatparam_objbbox_min_z (17) float parameter (can only be read) : object bounding box, min. z position (relative to the object reference frame) \n sim.objfloatparam_objbbox_max_x (18) float parameter (can only be read) : object bounding box, max. x position (relative to the object reference frame) \n sim.objfloatparam_objbbox_max_y (19) float parameter (can only be read) : object bounding box, max. y position (relative to the object reference frame) \n sim.objfloatparam_objbbox_max_z (20) float parameter (can only be read) : object bounding box, max. z position (relative to the object reference frame) \n sim.objfloatparam_modelbbox_min_x (21) float parameter (can only be read) : model bounding box, min. x position (relative to the object reference frame). Object needs to be flagged as model base. \n sim.objfloatparam_modelbbox_min_y (22) float parameter (can only be read) : model bounding box, min. y position (relative to the object reference frame). Object needs to be flagged as model base. \n sim.objfloatparam_modelbbox_min_z (23) float parameter (can only be read) : model bounding box, min. z position (relative to the object reference frame). Object needs to be flagged as model base. \n sim.objfloatparam_modelbbox_max_x (24) float parameter (can only be read) : model bounding box, max. x position (relative to the object reference frame). Object needs to be flagged as model base. \n sim.objfloatparam_modelbbox_max_y (25) float parameter (can only be read) : model bounding box, max. y position (relative to the object reference frame). Object needs to be flagged as model base. \n sim.objfloatparam_modelbbox_max_z (26) float parameter (can only be read) : model bounding box, max. z position (relative to the object reference frame). Object needs to be flagged as model base. \n sim.objintparam_collection_self_collision_indicator (27) int32 parameter : collection self-collision indicator. \n sim.objfloatparam_transparency_offset (28) float parameter : transparent object distance offset. When rendering transparent objects, they are ordered from back to front for rendering. With this value you can influence the ordering a bit. \n sim.objintparam_manipulation_permissions (31) int32 parameter : object manipulation permissions, bit-coded: bit0 set (1) --> object can be translated during non-simulation, bit1 set (2) --> object can be translated during simulation, bit2 set (4) --> object can be rotated during non-simulation, bit3 set (8) --> object can be rotated during simulation, bit4 set (16) --> object manual shift settings are locked, bit5 set (32) --> object nanual rotation settings are locked. \n sim.objintparam_illumination_handle (32) int32 parameter : -1 if object should be illuminated by all light objects, otherwise a light handle (or collection handle) for the light object(s) that should illuminate the object. \n sim.objfloatparam_size_factor (34) float parameter : a size factor that will be automatically scaled when the object gets scaled. \n sim.objstringparam_unique_id (35) string parameter : a string that uniquely and persistently identifies an object. Can only be read. \n sim.objintparam_visible (36) int32 parameter : 0 if the shape is not visible. Can only be read. \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Vision sensors \n \n sim.visionfloatparam_near_clipping (1000) float parameter : near clipping plane \n sim.visionfloatparam_far_clipping (1001) float parameter : far clipping plane \n sim.visionintparam_resolution_x (1002) int32 parameter : resolution x \n sim.visionintparam_resolution_y (1003) int32 parameter : resolution y \n sim.visionfloatparam_perspective_angle (1004) float parameter : perspective projection angle \n sim.visionfloatparam_ortho_size (1005) float parameter : orthographic projection size \n sim.visionintparam_disabled_light_components (1006) int32 parameter : mask of disabled light components (ambient, diffuse, specular) \n sim.visionintparam_rendering_attributes (1007) int32 parameter : a combination of  rendering attributes . Use with care. \n sim.visionintparam_entity_to_render (1008) int32 parameter : entity handle of the entity to render, or -1 to render all renderable objects. \n sim.visionintparam_windowed_size_x (1009) int32 parameter : size X of external windowed rendering. 0 for full-screen. \n sim.visionintparam_windowed_size_y (1010) int32 parameter : size Y of external windowed rendering. 0 for full-screen. \n sim.visionintparam_windowed_pos_x (1011) int32 parameter : pos X of external windowed rendering. \n sim.visionintparam_windowed_pos_y (1012) int32 parameter : pos Y of external windowed rendering. \n sim.visionintparam_pov_focal_blur (1013) int32 parameter : POV-Ray focal blur enabled flag. \n sim.visionfloatparam_pov_blur_distance (1014) float parameter : POV-Ray focal blur distance. \n sim.visionfloatparam_pov_aperture (1015) float parameter : POV-Ray aperture. \n sim.visionintparam_pov_blur_sampled (1016) int32 parameter : POV-Ray blur samples. \n sim.visionintparam_render_mode (1017) int32 parameter : Render mode. Use with care. 0=normal, 1=aux. channels, 2=object handles, 3=POV-Ray. \n sim.visionintparam_perspective_operation (1018) int32 parameter : whether the vision sensor is operated in perspective mode (1) or orthogonal mode (0). \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Joints \n \n sim.jointfloatparam_pid_p (2002) float parameter : dynamic motor position control P parameter \n sim.jointfloatparam_pid_i (2003) float parameter : dynamic motor position control I parameter \n sim.jointfloatparam_pid_d (2004) float parameter : dynamic motor position control D parameter \n sim.jointfloatparam_intrinsic_x (2005) float parameter (can only be read) : joint transformation, position X \n sim.jointfloatparam_intrinsic_y (2006) float parameter (can only be read) : joint transformation, position Y \n sim.jointfloatparam_intrinsic_z (2007) float parameter (can only be read) : joint transformation, position Z \n sim.jointfloatparam_intrinsic_qx (2008) float parameter (can only be read) : joint transformation, quaternion X \n sim.jointfloatparam_intrinsic_qy (2009) float parameter (can only be read) : joint transformation, quaternion Y \n sim.jointfloatparam_intrinsic_qz (2010) float parameter (can only be read) : joint transformation, quaternion Z \n sim.jointfloatparam_intrinsic_qw (2011) float parameter (can only be read) : joint transformation, quaternion W \n sim.jointfloatparam_velocity (2012) float parameter (can only be read) : joint velocity. This is a calculated value. \n sim.jointfloatparam_spherical_qx (2013) float parameter (can only be written) : spherical joint quaternion (X part). Value is buffered (quaternion will only be written when float parameter 2016 is written) \n sim.jointfloatparam_spherical_qy (2014) float parameter (can only be written) : spherical joint quaternion (Y part). Value is buffered (quaternion will only be written when float parameter 2016 is written) \n sim.jointfloatparam_spherical_qz (2015) float parameter (can only be written) : spherical joint quaternion (Z part). Value is buffered (quaternion will only be written when float parameter 2016 is written) \n sim.jointfloatparam_spherical_qw (2016) float parameter (can only be written) : spherical joint quaternion (W part). Writes a quaternion using also buffered values (see parameters 2013-2015) \n sim.jointfloatparam_upper_limit (2017) float parameter : joint upper velocity limit. May only have an effect after simulation restart, or after resetting the joint with  sim.resetDynamicObject \n sim.jointfloatparam_kc_k (2018) float parameter : dynamic motor spring control K parameter \n sim.jointfloatparam_kc_c (2019) float parameter : dynamic motor spring control C parameter \n sim.jointfloatparam_error_x (2022) float parameter : joint internal position error X (when joint is dynamically enabled). Can only be read. \n sim.jointfloatparam_error_y (2023) float parameter : joint internal position error Y (when joint is dynamically enabled). Can only be read. \n sim.jointfloatparam_error_z (2024) float parameter : joint internal position error Z (when joint is dynamically enabled). Can only be read. \n sim.jointfloatparam_error_a (2025) float parameter : joint internal orientation error alpha (euler(0)) (when joint is dynamically enabled). Can only be read. \n sim.jointfloatparam_error_b (2026) float parameter : joint internal orientation error beta (euler(1)) (when joint is dynamically enabled). Can only be read. \n sim.jointfloatparam_error_g (2027) float parameter : joint internal orientation error gamma (euler(2)) (when joint is dynamically enabled). Can only be read. \n sim.jointfloatparam_error_pos (2028) float parameter : joint internal position error (when joint is dynamically enabled). Can only be read. \n sim.jointfloatparam_error_angle (2029) float parameter : joint internal angular error (when joint is dynamically enabled). Can only be read. \n sim.jointintparam_velocity_lock (2030) int32 parameter : joint velocity lock mode enable state (when enabled and joint is in velocity mode and its target velocity is zero, then the joint is locked in place). \n sim.jointintparam_vortex_dep_handle (2031) int32 parameter : Vortex joint dependency, dependent joint handle. When written, the joint might have to be reset with  sim.resetDynamicObject  for the change to take effect. \n sim.jointfloatparam_vortex_dep_multiplication (2032) float parameter : Vortex joint dependency, multiplication factor. When written, the joint might have to be reset with  sim.resetDynamicObject  for the change to take effect. \n sim.jointfloatparam_vortex_dep_offset (2033) float parameter : Vortex joint dependency, offset. When written, the joint might have to be reset with  sim.resetDynamicObject  for the change to take effect. \n sim.jointfloatparam_screw_pitch (2034) float parameter : the joint screw pitch, if the joint is a revolute joint. \n sim.jointfloatparam_maxvel float parameter: the maximum allowed velocity, when motion controlled \n sim.jointfloatparam_maxaccel float parameter: the maximum allowed acceleration, when motion controlled \n sim.jointfloatparam_maxjerk float parameter: the maximum allowed jerk, when motion controlled \n sim.jointintparam_dynctrlmode \n int32 parameter: the  dynamic control mode of the join t \n sim.jointintparam_dynvelctrltype \n int32 parameter: the dynamic velocity control type of the joint: 0=none, 1=motion profile \n sim.jointintparam_dynposctrltype \n int32 parameter: the dynamic position control type of the joint: 0=PID, 1=motion profile \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Shapes \n \n sim.shapefloatparam_init_velocity_x (3000) float parameter : x-component of the initial dynamic linear velocity of a dynamically enabled shape (static or non-static). The shape might have to be reset with  sim.resetDynamicObject \n sim.shapefloatparam_init_velocity_y (3001) float parameter : y-component of the initial dynamic linear velocity of a dynamically enabled shape (static or non-static). The shape might have to be reset with  sim.resetDynamicObject \n sim.shapefloatparam_init_velocity_z (3002) float parameter : z-component of the initial dynamic linear velocity of a dynamically enabled shape (static or non-static). The shape might have to be reset with  sim.resetDynamicObject \n sim.shapeintparam_static (3003) int32 parameter : static state (0 or !=0). Use with care when setting this parameter during simulation (the shape might have to be reset with  sim.resetDynamicObject ) \n sim.shapeintparam_respondable (3004) int32 parameter : respondable state (0 or !=0). Use with care when setting this parameter during simulation (the shape might have to be reset with  sim.resetDynamicObject ) \n sim.shapefloatparam_mass (3005) float parameter : mass of the shape. Use with care when setting this parameter during simulation (the shape might have to be reset with  sim.resetDynamicObject ) \n sim.shapefloatparam_texture_x (3006) float parameter : texture x-coordinate. Has no effect when imported texture coordinates are used \n sim.shapefloatparam_texture_y (3007) float parameter : texture y-coordinate. Has no effect when imported texture coordinates are used \n sim.shapefloatparam_texture_z (3008) float parameter : texture z-coordinate. Has no effect when imported texture coordinates are used \n sim.shapefloatparam_texture_a (3009) float parameter : texture alpha-coordinate ( Euler angle ). Has no effect when imported texture coordinates are used \n sim.shapefloatparam_texture_b (3010) float parameter : texture beta-coordinate ( Euler angle ). Has no effect when imported texture coordinates are used \n sim.shapefloatparam_texture_g (3011) float parameter : texture gamma-coordinate ( Euler angle ). Has no effect when imported texture coordinates are used \n sim.shapefloatparam_texture_scaling_x (3012) float parameter : texture scaling along x. Has no effect when imported texture coordinates are used \n sim.shapefloatparam_texture_scaling_y (3013) float parameter : texture scaling along y. Has no effect when imported texture coordinates are used \n sim.shapeintparam_culling (3014) int32 parameter : culling state (0 or !=0) \n sim.shapeintparam_wireframe (3015) int32 parameter : wireframe state (0 or !=0) \n sim.shapeintparam_compound (3016) int32 parameter : shape compound state (0 if shape is a simple shape, !=0 if shape is a compound shape) \n sim.shapeintparam_convex (3017) int32 parameter : shape convex state (!=0 if shape mesh(es) is/are convex). This is just a flag. Very careful when setting this value (make sure the mesh(es) is/are closed and perfectly convex). The flag is used to select special and faster collision calculation routines for the physics engines. See also next item \n sim.shapeintparam_convex_check (3018) int32 parameter : triggers a convectivity check for the given shape. Can only be set (parameter can be any value). The shape's convex state will be set. Normally not needed because done automatically. \n sim.shapeintparam_respondable_mask (3019) int32 parameter : respondable mask. When setting this parameter during simulation (the shape might have to be reset with  sim.resetDynamicObject ) \n sim.shapefloatparam_init_velocity_a (3020) float parameter : alpha-component of the initial dynamic angular velocity of a dynamically enabled shape (static or non-static). The shape might have to be reset with  sim.resetDynamicObject \n sim.shapefloatparam_init_velocity_b (3021) float parameter : beta-component of the initial dynamic angular velocity of a dynamically enabled shape (static or non-static). The shape might have to be reset with  sim.resetDynamicObject \n sim.shapefloatparam_init_velocity_g (3022) float parameter : gamma-component of the initial dynamic angular velocity of a dynamically enabled shape (static or non-static). The shape might have to be reset with  sim.resetDynamicObject \n sim.shapestringparam_color_name (3023) string parameter : the color name(s) contained in the shape. If several color strings are contained, they are separated by a space character. You can use those strings to modify the color of a simple shape contained in a compound shape with  sim.setShapeColor . This parameter can only be written for shapes that are not compound shapes. \n sim.shapeintparam_edge_visibility (3024) int32 parameter : edge visibility state (0 or !=0). \n sim.shapefloatparam_shading_angle (3025) float parameter : shading angle. \n sim.shapefloatparam_edge_angle (3026) float parameter : edge threshold angle. \n sim.shapeintparam_edge_borders_hidden (3027) int32 parameter : hide edge borders (0 or !=0). \n sim.shapeintparam_component_cnt (3028) int32 parameter : the number of items in a compound shape, or 1 otherwise. \n sim.shapeintparam_sleepmodestart (3029) int32 parameter : 1 if the dynamic shape starts in sleep mode. \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Proximity sensors \n \n sim.proxintparam_ray_invisibility (4000) int32 parameter : detection ray invisibility state (0 or !=0) \n sim.proxintparam_volume_type (4001) int32 parameter : the  volume type  of the proximity sensor. Can only be read. \n sim.proxintparam_entity_to_detect (4002) int32 parameter : entity handle of the entity to detect, or -1 to detect all detectable objects. \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Force sensors \n \n sim.forcefloatparam_error_x (5000) float parameter : force sensor internal position error X. Can only be read. \n sim.forcefloatparam_error_y (5001) float parameter : force sensor internal position error Y. Can only be read. \n sim.forcefloatparam_error_z (5002) float parameter : force sensor internal position error Z. Can only be read. \n sim.forcefloatparam_error_a (5003) float parameter : force sensor internal orientation error alpha (euler(0)). Can only be read. \n sim.forcefloatparam_error_b (5004) float parameter : force sensor internal orientation error beta (euler(1)). Can only be read. \n sim.forcefloatparam_error_g (5005) float parameter : force sensor internal orientation error gamma (euler(2)). Can only be read. \n sim.forcefloatparam_error_pos (5006) float parameter : force sensor internal position error. Can only be read. \n sim.forcefloatparam_error_angle (5007) float parameter : force sensor internal angular error. Can only be read. \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Graphs \n \n sim.graphintparam_needs_refresh (10500) int32 parameter : reads and clears the refresh flag. \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Lights \n \n sim.lightintparam_pov_casts_shadows (8000) int32 parameter : POV-Ray light casts shadows. \n sim.lightfloatparam_spot_exponent (8001) float parameter : light spot exponent. \n sim.lightfloatparam_spot_cutoff (8002) float parameter : light spot cutoff. \n sim.lightfloatparam_const_attenuation (8003) float parameter : light constant attenuation factor. \n sim.lightfloatparam_lin_attenuation (8004) float parameter : light linear attenuation factor. \n sim.lightfloatparam_quad_attenuation (8005) float parameter : light quadratic attenuation factor. \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Cameras \n \n sim.cameraintparam_disabled_light_components (9000) int32 parameter : mask of disabled light components (ambient, diffuse, specular) \n sim.camerafloatparam_perspective_angle (9001) float parameter : camera perspective angle. \n sim.camerafloatparam_ortho_size (9002) float parameter : camera orthographic size. \n sim.cameraintparam_rendering_attributes (9003) int32 parameter : a combination of  rendering attributes . Use with care. \n sim.cameraintparam_pov_focal_blur (9004) int32 parameter : POV-Ray focal blur enabled flag. \n sim.camerafloatparam_pov_blur_distance (9005) float parameter : POV-Ray focal blur distance. \n sim.camerafloatparam_pov_aperture (9006) float parameter : POV-Ray aperture. \n sim.cameraintparam_pov_blur_samples (9007) int32 parameter : POV-Ray blur samples. \n sim.camerafloatparam_near_clipping (9008) float parameter : near clipping plane \n sim.camerafloatparam_far_clipping (9009) float parameter : far clipping plane \n sim.cameraintparam_perspective_operation (9010) int32 parameter : whether the camera is operated in perspective mode (1) or orthogonal mode (0). \n sim.cameraintparam_remotecameramode (9012) int32 parameter : the remote camera mode. Remote camera can be free (0), slave (1) or master (2). \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Dummies \n \n sim.dummyintparam_link_type (10000) int32 parameter :  dummy link type . If you set this value for a dummy that is dynamically enabled or that will be come dynamically enabled, you might have to call  sim.resetDynamicObject  on the two dummies for the effect to become active. \n sim.dummyfloatparam_size (10003) float parameter : the size of the dummy. \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n OC trees \n \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n Point clouds \n \n \n More parameters you wish to adjust from the API? Ask us to add them for a future release! \n \n \n \n \n \n \n \n", 'tags': '', 'url': 'objectParameterIDs.html'}, {'title': 'simulation', 'text': "\n \n \n \n \n Simulation \n A simulation in CoppeliaSim can be started, paused and stopped with [Menu bar --> Simulation --> Start/Pause/Stop simulation] or through the related toolbar buttons: \n \n \n [Simulation start/pause/stop toolbar buttons] \n Internally, the simulator will use additional intermediate states in order to correctly inform  scripts  or programs about what will happen next. Following state diagram illustrates the simulator's internal states: \n \n \n [Simulation state diagram] \n \n \n \n Simulation loop\n \n The simulator operates by advancing the simulation time at constant time steps. Following figure illustrates the main simulation loop: \n \n \n [Main simulation loop] \n \n \nReal-time simulation is supported by trying to keep the simulation time synchronized with the real time:\n \n \n [Real-time simulation loop] \n \n \n Simulation speed\n \n In non real-time simulations, the simulation speed (i.e. the perceived speed) is mainly dependent on two factors: the simulation time step and the number of simulation passes for one rendering pass (see the  simulation dialog  for more details). In the case of a real-time simulation, the simulation speed mainly depends on the real-time multiplication coefficient, but also to a certain degree of the simulation time step (a too small simulation time step might not be compatible with the real-time character of a simulation because of the limited calculation power of the computer). During simulation, the simulation speed can be adjusted with following toolbar buttons: \n \n \n [Simulation speed adjustment toolbar buttons] \n The simulation speed is adjusted in a way so that the initial simulation time step is never increased (because this might have as consequence the breaking of a mechanism for example). Following two figures illustrate the simulation speed adjustment mechanisms: \n \n \n [Simulation speed adjustment mechanism for  non real-time simulations ] \n \n \n [Simulation speed adjustment mechanism for  real-time simulations ] \n By default, each simulation cycle is composed by following  sequential  operations: \n Executing the  main script \n Rendering the scene \n \n \n Stepped mode \n By default, CoppeliaSim executes a simulation by running one simulation step after another, automatically. There are however many situations where it is important to be able to manually trigger each simulation step, e.g. in order to inspect each simulation step individually, or in order to synchronize CoppeliaSim with an external application. There is such a mechanism, which is the stepped mode (or synchronous mode): \n \n [Stepped simulation mode] \n \n From within CoppeliaSim, a stepped simulation can easily be implemented via the  sysCall_beforeMainScript   callback function . From an external application, there is usually a dedicated function to enable the stepped mode, and then to trigger each individual step. Following illustrates the stepped mode from a Python ZeroMQ remote API client: \n import time\nfrom zmqRemoteApi import RemoteAPIClient\n\nclient = RemoteAPIClient()\nsim = client.getObject('sim')\n\nclient.setStepping(True)\n\nsim.startSimulation()\nwhile (t := sim.getSimulationTime()) < 3:\n    s = f'Simulation time: {t:.2f} [s]'\n    print(s)\n    client.step()\nsim.stopSimulation() \n \n \n \n \n", 'tags': '', 'url': 'simulation.html'}, {'title': 'simulationPropertiesDialog', 'text': "\n \n \n \n \n Simulation dialog \n The simulation dialog can be accessed with [Menu bar --> Simulation --> Simulation settings] or by clicking following toolbar button: \n \n \n [Simulation toolbar button] \n \n \n [Simulation settings dialog] \n \n Time step : the  simulation  time step. Each time the  main script  was executed, the simulation time is incremented by the simulation time step. Using large time steps results in fast but inaccurate/unstable simulations. Small time steps on the other hand will (generally) lead to more precise simulations, but will take more time. It is highly recommended to keep a default time step. \n \n Simulation passes per frame (ppf) : the number of simulation passes for one rendering pass. A value of 10 would mean that the main script is executed 10 times (10 simulation steps) before the screen is refreshed. If you have a slow graphic card, you can choose to display only one frame out of two for instance. \n \n Pause when simulation time higher than : allows specifying a simulation time at which the simulation will be paused (e.g. to be able to analyze some results at a specific simulation time). \n \n Pause on  script error : if enabled, then a simulation will be paused when a  script  error occurs in an embedded script. \n \n Full screen at simulation start : if enabled, then simulation starts in full screen mode. Be aware that in full screen mode, dialogs and messages won't appear or won't be visible, and only the left mouse button will be active. For that reason that mode is only recommended once a scene is properly configured and final. Full screen mode can be left with the esc-key, and toggled via the   bool parameter   sim.booparam_fullscreen  during simulation. Unler Linux and MacOS the full-screen mode might only partially be supported, and switching back to normal mode might fail on certain systems. \n Real-time simulation, multiplication factor : if selected, then the simulation time will try to follow the real-time. A multiplication factor of X would try to run a simulation X times faster than real-time. \n \n Try catching up when behind : during real-time simulation, it can happen that the simulation time is not able to follow the real-time (e.g. because of some momentarily heavy calculations). In that case, if this check-box is selected, then the simulation time will try catching up the lost time (e.g. when the calculation load is again reduced), which results in an apparent speed-up. \n \n Reset scene to initial state : when selected, then all  objects  will be reset to their initial state: this includes the object local position, local  orientation and  its parent (as long as the object wasn't modified otherwise (e.g. scaled)),  joint  linear/angular positions, floating  view  positions and sizes, etc. This means that the next simulation run will execute in a same way as previous one, unless heavy changes were undertaken ( shape  scaling, object removal, etc.). Some minor settings are ignored by this item. \n \n Remove new objects : when selected, then scene objects added during a simulation run will be removed at the end of the simulation. \n \n \n \n \n \n", 'tags': '', 'url': 'simulationPropertiesDialog.html'}, {'title': 'tutorials', 'text': '\n \n \n \n \n Tutorials \n BubbleRob tutorial \n Building a clean model tutorial \n Line following BubbleRob tutorial \n Inverse kinematics tutorial \n External controller tutorial \n Plugin tutorial \n Robot language interpreter integration tutorial \n ROS tutorial \n \n \n \n \n', 'tags': '', 'url': 'tutorials.html'}, {'title': 'bubbleRobTutorial', 'text': '\n \n \n \n \n BubbleRob tutorial \n This tutorial will introduce quite many CoppeliaSim functionalities while designing the simple mobile robot  BubbleRob . The CoppeliaSim scene file related to this tutorial is located in  scenes/tutorials/BubbleRob . Following figure illustrates the simulation scene that we will design: \n \n \n \n Since this tutorial will fly over many different aspects, make sure to also have a look at the  other tutorials , mainly the  tutorial about building a simulation model . First of all, freshly start CoppeliaSim. The simulator displays a default  scene . We will start with the body of  BubbleRob . \n We add a primitive sphere of diameter 0.2 to the scene with [Menu bar --> Add --> Primitive shape --> Sphere]. We adjust the  X-size  item to 0.2, then click  OK . The created sphere will appear in the  visibility layer  1 by default, and be  dynamic and respondable  (since we kept the item  Create dynamic and respondable shape  enabled). This means that  BubbleRob\'s  body will be falling and able to react to collisions with other respondable shapes (i.e. simulated by the physics engine). We can see this is the  shape dynamics properties : items  Body is respondable  and  Body is dynamic  are enabled. We start the simulation (via the toolbar button, or by pressing <control-space> in the scene window), and copy-and-paste the created sphere (with [Menu bar --> Edit --> Copy selected objects] then [Menu bar --> Edit -> Paste buffer], or with <control-c> then <control-v>): the two spheres will react to collision and roll away. We stop the simulation: the duplicated sphere will automatically be removed. This default behaviour can be modified in the  simulation dialog . \n We also want the  BubbleRob\'s  body to by usable by the other calculation modules (e.g.  distance calculation ). For that reason, we enable  Collidable ,  Measurable  and  Detectable  in the  object common properties  for that shape, if not already enabled. If we wanted, we could now also change the visual appearance of our sphere in the  shape properties . \n Now we open the  position dialog  on the  translation  tab, select the sphere representing  BubbleRob\'s  body, and  enter 0.02 for  Along Z . We make sure that the  Relative to -item is set to  World . Then we click  Translate selection . This translates all selected objects by 2 cm along the absolute Z-axis, and effectively lifted our sphere a little bit. In the  scene hierarchy , we double-click the sphere\'s alias, so that we can edit it. We enter  bubbleRob  and press enter. \n Next we will add a  proximity sensor  so that  BubbleRob  knows when it is approaching obstacles: we select [Menu bar --> Add --> Proximity sensor --> Cone type]. In the  orientation dialog  on the  orientation  tab, we enter 90 for  Around Y  and for  Around Z , then click  Rotate selection . In the  position dialog , on the  position  tab, we enter 0.1 for  X-coord.  and 0.12 for  Z-coord.  The proximity sensor is now correctly positioned relative to  BubbleRob\'s  body. We double-click the proximity sensor\'s icon in the  scene hierarchy  to open  its properties  dialog. We click  Show volume parameter   to open the  proximity sensor volume dialog . We adjust items  Offset  to 0.005,  Angle  to 30 and  Range  to 0.15. Then, in the  proximity sensor properties , we click  Show detection parameters . This opens the  proximity sensor detection parameter dialog . We uncheck item  Don\'t allow detections if distance smaller than  then close that dialog again. In the scene hierarchy, we double-click the proximity sensor\'s alias in order to edit it. We enter  sensingNose  and press enter. \n \n We select  sensingNose , then control-select  bubbleRob , then click [Menu bar --> Edit --> Make last selected object parent]. This attaches the sensor to the body of the robot. We could also have dragged  sensingNose  onto  bubbleRob  in the scene hierarchy. This is what we now have: \n \n \n [Proximity sensor attached to  bubbleRob\'s  body] \n \n Next we will take care of  BubbleRob\'s  wheels. We create a new scene with [Menu bar --> File --> New scene]. It is often very convenient to work across several scenes, in order to visualize and work only on specific elements. We add a pure primitive cylinder with dimensions (0.08,0.08,0.02). As for the body of  BubbleRob , we enable   Collidable ,  Measurable  and  Detectable  in the  object common properties  for that cylinder, if not already enabled. Then we set the cylinder\'s absolute position to (0.05,0.1,0.04) and its absolute orientation to (-90,0,0).  We change the alias to  leftWheel . We copy and paste the wheel, and set the absolute Y coordinate of the copy to -0.1. We rename the copy to  rightWheel . We select the two wheels, copy them, then switch back to scene 1, then paste the wheels. \n We now need to add  joints  (or motors) for the wheels. We click [Menu bar --> Add --> Joint --> Revolute] to add a revolute joint to the scene. Most of the time, when adding a new object to the scene, the object will appear at the origin of the world. We Keep the joint selected, then control-select  leftWheel . In the  position dialog , on the  position  tab, we click the  Apply to selection  button: this positioned the joint at the center of the left wheel. Then, in the  orientation dialog , on the  orientation  tab, we do the same: this oriented the joint in the same way as the left wheel. We rename the joint to  leftMotor . We now double-click the joint\'s icon in the scene hierarchy to open the  joint properties  dialog. Then we click  Show dynamic parameters  to open the  joint dynamics properties  dialog. We  enable the motor , and check item  Lock motor when target velocity is zero . We now repeat the same procedure for the right motor and rename it to  rightMotor . Now we attach the left wheel to the left motor, the right wheel to the right motor, then attach the two motors to  bubbleRob . This is what we have: \n \n [Proximity sensor, motors and wheels] \n \n We run the simulation and notice that the robot is falling backwards. We are still missing a third contact point to the floor. We now add a small slider (or caster). In a new scene we and add a pure primitive sphere with diameter 0.05 and make the sphere  Collidable ,  Measurable  and  Detectable  (if not already enabled), then rename it to  slider . We set the  Material  to  noFrictionMaterial  in the  shape dynamics properties . To rigidly link the slider with the rest of the robot, we add a  force sensor object  with [Menu bar --> Add --> Force sensor]. We rename it to  connection  and shift it up by 0.05. We attach the slider to the force sensor, then copy both objects, switch back to scene 1 and paste them. We then shift the force sensor by -0.07 along the absolute X-axis, then attach it to the robot body. If we run the simulation now, we can notice that the slider is slightly moving in relation to the robot body: this is because both objects (i.e.  slider  and  bubbleRob ) are colliding with each other. To avoid strange effects during dynamics simulation, we have to inform CoppeliaSim that both objects do not mutually collide, and we do this in following way: in the  shape dynamics properties , for  slider  we set the  local respondable mask  to 00001111, and for  bubbleRob , we set the  local respondable mask  to 11110000. If we run the simulation again, we can notice that both objects do not interfere anymore. This is what we now have: \n \n [Proximity sensor, motors, wheels and slider] \n \n We run the simulation again and notice that  BubbleRob  slightly moves, even with locked motor. We also try to run the simulation with different physics engines: the result will be different. Stability of dynamic simulations is tightly linked to masses and inertias of the involved non-static shapes. For an explanation of this effect, make sure to carefully read  this  and  that  sections. We now try to correct for that undesired effect. We select the two wheels and the slider, and in the shape dynamics dialog we click three times  M=M*2 (for selection) . The effect is that all selected shapes will have their masses multiplied by 8. We do the same with the inertias of the 3 selected shapes, then run the simulation again: stability has improved. In the joint dynamics dialog, we set the  Target velocity  to 50 for both motors. We run the simulation:  BubbleRob  now moves forward and eventually falls off the floor. We reset the  Target velocity  item to zero for both motors. \n \n The object  bubbleRob  is at the base of all  objects  that will later form the  BubbleRob   model . We will define the model a little bit later. Next we are going to add a  graph object  to  BubbleRob  in order to display its clearance distance. We click [Menu bar --> Add --> Graph] and rename it to  graph . We attach the graph to  bubbleRob , and set the graph\'s absolute coordinates to (0,0,0.005). \n Now we set one motor  target velocity  to 50, run the simulation, and will see  BubbleRob\'s  trajectory displayed in the scene. We then stop the simulation and reset the motor target velocity to zero. \n \n We add a pure primitive cylinder with following dimensions: (0.1, 0.1, 0.2). We want this cylinder to be static (i.e. not influenced by gravity or collisions) but still exerting some collision responses on non-static respondable shapes. For this, we disable  Body is dynamic  in the  shape dynamics properties . We also want our cylinder to be  Collidable ,  Measurable  and  Detectable . We do this in the  object common properties . Now, while the cylinder is still selected, we click the object translation toolbar button: \n \n \n \n Now we can drag any point in the scene: the cylinder will follow the movement while always being constrained to keep the same Z-coordinate. We copy and paste the cylinder a few times, and move them to positions around  BubbleRob  (it is most convenient to perform that while looking at the scene from the top). During object shifting, holding down the shift key allows to perform smaller shift steps. Holding down the ctrl key allows to move in an orthogonal direction to the  regular  direction(s). When done, select the camera pan toolbar button again: \n \n \n \n We set a  target velocity  of 50 for the left motor and run the simulation: the graph view now displays the distance to the closest obstacle and the distance segment is visible in the scene too. We stop the simulation and reset the target velocity to zero. \n \n We now need to finish  BubbleRob  as a  model  definition. We select the model base (i.e. object  bubbleRob ) then check  Object is model base  in the  object common properties : there is now a stippled bounding box that encompasses all objects in the model hierarchy. We select the two joints, the proximity sensor and the graph, then enable item  Ignored by model bounding box  and click  Apply to selection , in the same dialog: the model bounding box now ignores the two joints and the proximity sensor. Still in the same dialog, we disable  camera visibility layer  2, and enable  camera visibility layer  10 for the two joints and the force sensor: this effectively hides the two joints and the force sensor, since layers 9-16 are disabled by default. At any time we can  modify the visibility layers for the whole scene . To finish the model definition, we select the vision sensor, the two wheels, the slider, and the graph, then enable item  Select base of model instead : if we now try to select an object in our model in the scene, the whole model will be selected instead, which is a convenient way to handle and manipulate the whole model as a single object. Additionally, this protects the model against inadvertant modification. Individual objects in the model can still be selected in the scene by click-selecting them with control-shift, or normally selecting them in the scene hierarchy. We finally collapse the model tree in the scene hierarchy. \n Next we will add a  vision sensor , at the same position and orientation as  BubbleRob\'s  proximity sensor. We open the model hierarchy again, then click [Menu bar --> Add --> Vision sensor --> Perspective type], then attach the vision sensor to the proximity sensor, and set the local position and orientation of the vision sensor to (0,0,0). We also make sure the vision sensor is not not visible, not part of the model bounding box, and that if clicked, the model will be selected instead. In order to customize the vision sensor, we open  its properties  dialog. We set the  Far clipping plane  item to 1, and the  Resolution x  and  Resolution y  items to 256 and 256.  We add a floating view to the scene, and over the newly added floating view, right-click [Popup menu --> View --> Associate view with selected vision sensor] (we make sure the vision sensor is selected during that process). \n\n\n We attach a child script to the vision sensor by clicking [Menu bar --> Add --> Associated child script --> Non threaded]. We double-click the icon that appeared next to the vision sensor in the scene hierarchy: this opens the child script that we just added. We copy and paste following code into the  script editor , then close it: \n \n \nfunction sysCall_vision(inData)\n    simVision.sensorImgToWorkImg(inData.handle) -- copy the vision sensor image to the work image\n    simVision.edgeDetectionOnWorkImg(inData.handle,0.2) -- perform edge detection on the work image\n    simVision.workImgToSensorImg(inData.handle) -- copy the work image to the vision sensor image buffer\nend\n\nfunction sysCall_init()\nend\n \n \nTo be able to see the vision sensor\'s image, we start the simulation, then stop it again. \n \n The last thing that we need for our scene is a small  child script  that will control  BubbleRob\'s  behavior. We select  bubbleRob  and click [Menu bar --> Add --> Associated child script --> Non threaded]. We double-click the script icon that appeared next to  bubbleRob\'s  alias in the scene hierarchy and copy and paste following code into the  script editor , then close it: \n \n \nfunction speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_init()\n    -- This is executed exactly once, the first time this script is executed\n    bubbleRobBase=sim.getObject(\'.\') -- this is bubbleRob\'s handle\n    leftMotor=sim.getObject("./leftMotor") -- Handle of the left motor\n    rightMotor=sim.getObject("./rightMotor") -- Handle of the right motor\n    noseSensor=sim.getObject("./sensingNose") -- Handle of the proximity sensor\n    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    robotCollection=sim.createCollection(0)\n    sim.addItemToCollection(robotCollection,sim.handle_tree,bubbleRobBase,0)\n    distanceSegment=sim.addDrawingObject(sim.drawing_lines,4,0,-1,1,{0,1,0})\n    robotTrace=sim.addDrawingObject(sim.drawing_linestrip+sim.drawing_cyclic,2,0,-1,200,{1,1,0})\n    graph=sim.getObject(\'./graph\')\n    distStream=sim.addGraphStream(graph,\'bubbleRob clearance\',\'m\',0,{1,0,0})\n    -- Create the custom UI:\n        xml = \'<ui title="\'..sim.getObjectAlias(bubbleRobBase,1)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n        <hslider minimum="0" maximum="100" onchange="speedChange_callback" id="1"/>\n        <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\nend\n\nfunction sysCall_sensing()\n    local result,distData=sim.checkDistance(robotCollection,sim.handle_all)\n    if result>0 then\n        sim.addDrawingObjectItem(distanceSegment,nil)\n        sim.addDrawingObjectItem(distanceSegment,distData)\n        sim.setGraphStreamValue(graph,distStream,distData[7])\n    end\n    local p=sim.getObjectPosition(bubbleRobBase,-1)\n    sim.addDrawingObjectItem(robotTrace,p)\nend\n\nfunction sysCall_actuation()\n    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor\n    -- If we detected something, we set the backward mode:\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end \n\n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,speed)\n        sim.setJointTargetVelocity(rightMotor,speed)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend\n\nfunction sysCall_cleanup()\n    simUI.destroy(ui)\nend \n We run the simulation.  BubbleRob  now moves forward while trying to avoid obstacles (in a very basic fashion). While the simulation is still running, change  BubbleRob\'s  velocity, and copy/paste it a few times. Also try to scale a few of them while the simulation is still running. Be aware that the minimum distance calculation functionality might be heavily slowing down the simulation, depending on the environment. \n Using a script to control a robot or model is only one way of doing. CoppeliaSim offers many different ways (also combined), have a look at the  external controller tutorial . \n \n \n \n \n', 'tags': '', 'url': 'bubbleRobTutorial.html'}, {'title': 'buildingAModelTutorial', 'text': "\n \n \n \n \n Building a clean model tutorial \n This tutorial will guide you step-by-step into building a clean simulation model, of a robot, or any other item. This is a very important topic, maybe the most important aspect, in order to have a nice looking, fast displaying, fast simulating and stable simulation model. \n To illustrate the model building process, we will be building following manipulator: \n \n [Model of robotic manipulator] \n \n \n \n Building the visible shapes\n \n When building a new model, first, we handle only the visual aspect of it: the dynamic aspect (its undelying even more simplified/optimized model), joints, sensors, etc. will be handled at a later stage. \n We could now directly create primitive shapes in CoppeliaSim with [Menu bar --> Add --> Primitive shape --> ...]. When doing this, we have the option to create  pure shapes, or regular shapes . Pure shape will be optimized for dynamic interaction, and also directly be dynamically enabled (i.e. fall, collide, but this can be disabled at a later stage). Primitive shapes will be simple meshes, which might not contain enough details or geometric accuracy for our application. Our other option in that case would be to import a mesh from an external application. \n When importing CAD data from an external application, the most important is to make sure that the CAD model is not too heavy, i.e. doesn't contain too many triangles. This requirement is important since a heavy model will be slow in display, and also slow down various calculation modules that might be used at a later stage (e.g.  minimum distance calculation , or  dynamics ). Following example is typically a no-go (even if, as we will see later, there are means to simplify the data within CoppeliaSim): \n \xa0 \n \n [Complex CAD data (in solid and wireframe)] \n \n Above CAD data is very heavy: it contains many triangles (more than 47'000), which would be ok if we would just use a single instance of it in an empty scene. But most of the time you will want to simulate several instances of a same robot, attach various types of grippers, and maybe have those robots interact with other robots, devices, or the environment. In that case, a simulation scene can quickly become too slow. Generally, we recommend to model a robot with no more than a total of 20'000 triangles, but most of the time 5'000-10'000 triangles would just do fine as well. Remember: less is better, in almost every aspect. \n What makes above model so heavy? First, models that contain holes and small details will require much more triangular faces for a correct representation. So, if possible, try to remove all the holes, screws, the inside of objects, etc. from your original model data. If you have the original model data represented as parametric surfaces/objects, then it is most of the time a simple matter of selecting the items and deleting them (e.g. in Solidworks). The second important step is to export the original data with a limited precision: most CAD applications let you specify the level of details of exported meshes. It might also be important to export the objects in several steps, when the drawing consists of large and small objects; this is to avoid having large objects too precisely defined (too many triangles) and small objects too roughly defined (too few triangles): simply export large objects first (by adjusting the desired precision settings), then small objects (by adjusting up precision settings). \n Now suppose that we have applied all possible simplifications as described in previous section. We might still end-up with a too heavy mesh after import: \n \n [Imported CAD data] \n \n You can notice that the whole robot was imported as a single mesh. We will see later how to divide it appropriately. Notice also the wrong orientation of the imported mesh: best is to keep the orientation as it is, until the whole model was built, since, if at a later stage we want to import other items that are related to that same robot, they will automatically have the correct position/orientation relative to the original mesh. \n At this stage, we have several functions at our disposal, to simplify the mesh: \n Automatic mesh division:  allows to generate a new shape for all elements that are not linked together via a common edge. This does not always work for the selected mesh, but is always worth a try, since working on mesh elements gives us more control than if we had to work on all elements at the same time. The function can be accessed with [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Sometimes, a mesh will be divided more than expected. In that case, simply merge elements that logically belong together (i.e. that will have the same visual attributes and that are part of the same link) back into one single shape ([Menu bar --> Edit -> Grouping/Merging --> Merge selected shapes]). \n Extract the convex hull:  allows to simplify the mesh by transforming it into a convex hull. The function can be accessed with [Menu bar --> Edit --> Morph selection into convex shapes]. \n Decimate the mesh:  allows to reduce the number of triangles contained in the mesh. The function can be accessed with [Menu bar --> Edit --> Decimate selected shape...]. \n There is no predefined order in which above functions can/should be applied (except for the first item in the list, which should always be tried first), it heavily depends on the geometry of the mesh we are trying to simplify. Following image illustrates above functions applied to the imported mesh (let's suppose the first item in the list didn't work for us): \n \n [Convex hull, and decimated mesh] \n \n Notice how the convex hull doesn't help us at this stage. We decide to use the mesh decimation function first, and run the function twice in order to divide the number of triangles by a total of 50. We end-up with a mesh containing a total of 2'660 triangles (the original imported mesh contained more than 136'000 triangles!). The number of triangles/vertices a shape contains can be seen in the  shape geometry dialog . 2'660 triangles are extremely few triangles for a whole robot model, and the visual appearance might suffer a little bit from it.  \n At this stage we can start to divide the robot into separate links (remember, we currently have only a single shape for the whole robot). You can do this in two different ways: \n Automatic mesh division:  this function, which was already described in previous section,  will inspect the shape and generate a new shape for all elements that are not linked together via a common edge. This does not always work, but is always worth a try. The function can be accessed with [Menu bar --> Edit --> Grouping/merging --> Divide selected shapes]. \n Manual mesh division:  via the the  triangle edit mode , you can manually select the triangles than logically belong together, then click  Extract shape . This will generate a new shape in the scene. Delete the selected triangles after that operation. \n In the case of our mesh, method 1 worked fine: \n \n [Divided mesh] \n \n Now, we could further refine/simplify individual shapes. Sometimes also, a shape might look better if its convex hull is used instead. Othertimes, you will have to use several of above's described techniques iteratively, in order to obtain the desired result. Take for instance following mesh: \n \n [Imported mesh] \n \n The problem with above's shape is that we cannot simplify it nicely, because of the holes it contains. So we have to go the more complicated way via the  shape edit mode , where we can extract individual elements that logically belong to the same convex sub-entity. This process can take several iterations: we first extract 3 approximate convex elements. For now, we ignore the triangles that are part of the two holes. While editing a shape in the shape edit mode, it can be convenient to switch the  visibility layers , in order to see what is covered by other scene items. \n \n [Step 1] \n \n We end up with a toal of three shapes, but two of them will need further improvement. Now we can erase the triangles that are part of the holes. Finally, we extract the convex hull individually for the 3 shapes, then merge them back together with [Menu bar --> Edit --> Grouping/Merging --> merge selected shapes]: \n \n [Step 2] \n \n In CoppeliaSim, we can specify a  shading angle  that dictates how facetted the shape will display. That parameter, and a few others such as the shape  color , can be adjusted in the  shape properties . Remember that  shapes come in various flavours . In this tutorial we have only dealt with simple shapes up to now: a simple shape has a single set of visual attributes (i.e. one color, one shading angle, etc.). If you merge two shapes, then the result will be a simple shape. You can also group shapes, in which case, each shape will retain its visual attributes. \n In next step, we can merge elements that logically belong together (if they are part of the same rigid element, and if they have the same visual attributes). Then we change the visual attributes of the various elements. The easiest ist to adjust a few shapes that have different colors and visual attributes, and if we name the color with a specific string, we can later easily programmatically change that color, also if the shape is part of a compound shape. Then, we select all the shapes that have the same visual attributes, then control-select the shape that was already adjusted, then click  Apply to selection , once for the  Colors , once for the  other properties , in the  shape properties : this transfers all visual attributes to the selected shapes (including the color name if you provided one). We end up with 17 individual shapes: \n \n [Adjusted visual attributes] \n \n Now we can group the shapes that are part of the same link with [Menu bar --> Edit --> Grouping/merging -> Group selected shapes]. We end up with 7 shapes: the base of the robot (or base of the robot's hierarchy tree), and 6 mobile links. It is also important to correctly name your objects: you we do this with a double-click on the object alias in the  scene hierarchy . By defaut, shapes will be assigned to visibility layer 1, but can be changed in the  object common properties . By default, only  visibility layers 1-8 are activated for the scene . We now have following: \n \n [Individual elements compositn the robot] \n \n When a shape is created or modified, CoppeliaSim will automatically set its reference frame position and orientation. A shape's reference frame will always be positioned at the shape's geometric center. The frame orientation will be selected so that the shape's bounding box remains as small as possible. This does not always look nice, but we can always reorient a shape's reference frame at any time. We now reorient the reference frames of all our created shapes with [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. You have more options to reorient a reference frame in the  shape geometry dialog . \n \n \n \n Building the joints\n \n Now we will take care of the joints/motors. Most of the time, we know the exact position and orientation of each of the joints. In that case, we simply add the joints with [Menu bar --> Add --> Joints --> ...], then we can change their position and orientation with the  position dialog  and  orientation dialog . In other situations, we only have the Denavit-Hartenberg (i.e. D-H) parameters. In that case, we can build our joints via the tool model located in  Models/tools/Denavit-Hartenberg joint creator.ttm , in the model browser. Othertimes, we have no information about the joint locations and orientations. Then, we need to extract them from the imported mesh. Let's suppose this is our case. Instead of working on the modified, more approximate mesh, we open a new scene, and import the original CAD data again. Most of the time, we can extract meshes or primitive shapes from the original mesh. The first step is to subdivide the original mesh. If that does not work, we do it via the  triangle edit mode . Let's suppose that we could divide the original mesh. We now have smaller objects that we can inspect. We are looking for revolute shapes, that could be used as reference to create joints at their locations, with the same orientation. First, remove all objects that are not needed. It is sometimes also useful to work across several opened scenes, for easier visualization/manipulation. In our case, we focus first on the base of the robot: it contains a cylinder that has the correct position for the first joint. In the triangle edit mode, we have: \n \n [Robot base: normal and triangle edit mode visualization] \n \n We change the camera view via the  page selector   toolbar button , in order to look at the object from the side. The  fit-to-view toolbar button  can come in handy to correctly frame the object in edition. Then we switch to the  vertex edit mode  and select all vertices that belong to the upper disc. Remember that by switching some  layers  on/off, we can hide other objects in the scene. Then we switch back to the triangle edit mode: \n \n [Selected upper disc, vertex edit mode (1 & 2), triangle edit mode (3)] \n \n Now we click  Extract cylinder  ( Extract shape  would also work in that case), this just created a cylinder shape in the scene, based on the selected triangles. We leave the edit mode and discard the changes. Now we add a revolute joint with [Menu bar --> Add --> Joint --> Revolute], keep it selected, then control-select the extracted cylinder shape. In the  position dialog , on the  position  tab, we click  Apply to selection : this basically copies the x/y/z position of the cylinder to the joint. Both positions are now identical. In the  orientation dialog , on the  orientation  tab, we also click  Apply to selection : the orientation of our selected objects is now also the same. Sometimes, we will need to additionally rotate the joint about 90/180 degrees around its own reference frame in order to obtain the correct orientation or rotation direction. We could do that on the  rotation  tab of that dialog if needed (in that case, do not forget to click the  Own frame  button). In a similar way we could also shift the joint along its axis, or even do more complex operations. This is what we have: \n \n [Joint in correct location, with the correct orientation] \n \n Now we copy the joint back into our original scene, and save it (do not forget to save your work on a regular basis! The undo/redo function is useful, but doesn't protect you against other mishaps). We repeat above procedure for all the joints in our robot, then rename them. We also make all joints a little bit longer in the  joint properties , in order to see them all. By defaut, joints will be assigned to visibility layer 2, but can be changed in the  object common properties . We assign now all joints to visibility layer 10, then temporarily  enable visibility layer 10 for the scene  to also visualize those joints (by default, only visibility layers 1-8 are activated for the scene). This is what we have: \n \n [Joints in correct configuration] \n \n At this point, we could start to build the model hierarchy and finish the model definition. But if we want opur robot to be  dynamically enabled , then there is an additional intermediate step: \n \n \n \n Building the dynamic shapes\n \n If we want our robot to be  dynamically enabled , i.e. react to collisions, fall, etc., then we need to create/configure the shapes appropriately: a shape can be: \n dynamic or static:  a dynamic (or non-static) shape will fall and be influences by external forces/torques. A static (or non-dynamic) shape on the other hand, will stay in place, or follow the movement of its parent in the scene hierarchy. \n respondable or non-respondable : a respondable shape will cause a collision reaction with other respondable shapes. They (and/or) their collider, will be influenced in their movement if they are dynamic. On the other hand, non-respondable shapes will not compute a collision response if they collide with other shapes. \n Above two points are illustrated  here . Respondable shapes should be as simple as possible, in order to allow for a fast and stable simulation. A physics engine will be able to simulate following 5 types of shapes with various degrees of speed and stability: \n Pure shapes :  a pure shape will be stable and handled very efficiently by the physics engine. The draw-back is that pure shapes are limited in geometry: mostly cuboids, cylinders and spheres. If possible, use those for items that are in contact with other items for a longer time (e.g. the feet of a humanoid robot, the base of a serial manipulator, the fingers of a gripper, etc.). Pure shapes can be created with [Menu bar --> Add --> Primitive shape]. \n Pure compound shapes :  a pure compound shape is a grouping of several pure shapes. It performs almost as well as pure shapes and shares similar properties. Pure compound shapes can be generated by grouping several pure shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n Convex shapes : a convex shape will be a little bit less stable and take a little bit more computation time when handled by the physics engine. It allows for a more general geometry (only requirement: it need to be convex) than pure shapes. If possible, use convex shapes for items that are sporadically in contact with other items (e.g. the various links of a robot). Convex shapes can be generated with [Menu bar --> Add --> Convex hull of selection] or with [Menu bar --> Edit --> Morph selection into convex shapes]. \n Compound convex shapes, or convex decomposed shapes : a convex decomposed shape is a grouping of several convex shapes. It performs almost as well as convex shapes and shares similar properties. Convex decomposed shapes can be generated by grouping several convex shapes [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes], with [Menu bar --> Add --> Convex decomposition of selection...], or with [Menu bar --> Edit --> Morph selection into its convex decomposition...]. \n Random shapes : a random shape is a shape that is not convex nor pure. It generally has poor performance (calculation speed and stability). Avoid using random shapes as much as possible. \n So the order of preference would be: pure shapes, pure compound shapes, convex shapes, compound convex shapes, and finally random shapes. Make sure to also read  this page . In case of the robot we want to build, we will make the base of the robot as a pure cylinder, and the other links as convex or convex decomposed shapes. \n We could use the dynamically enabled shapes also as the visible parts of the robot, but that would probably not look good enough. So instead, we will build for each visible shape we have created in  the first part of the tutorial  a dynamically enabled counterpart, which we will keep hidden: the hidden part will represent the dynamic model and be exclusively used by the physics engine, while the visible part will be used for visualization, but also for  minimum distance calculations ,  proximity sensor detections , etc. \n We select object  robot , copy-and-paste it into a new scene (in order to keep the original model intact) and start the  triangle edit mode . If object  robot  was a compound shape, we  would first have had to ungroup it ([Menu bar --> Edit --> Grouping/Merging --> Ungroup selected shapes]) then merge the individual shapes ([Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]) before being able to start the triangle edit mode. Now we select the few triangles that represent the power cable, and erase them. Then we select all triangles in that shape, and click Extract cylinder. We can now leave the edit mode and we have our base object represented as a pure cylinder: \n \n [Pure cylinder generation procedure, in the triangle edit mode] \n \n We rename the new shape (with a double-click on its alias in the  scene hierarchy ) as  robot_dyn , assign it to visibility layer 9, then copy it to the original scene. The rest of the links will be modelled as convex shapes, or compound convex shapes. We now select the first mobile link (i.e. object  robot_link1 ) and generate a convex shape from it with [Menu bar --> Add --> Convex hull of selection]. We rename it to  robot_link_dyn1  and assign it to visibility layer 9. When extracting the convex hull doesn't retain enough details of the original shape, then you could still manually extract several convex hulls from its composing elements, then group all the convex hulls with [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. If that appears to be problematic or time consuming, then you can automatically extract a convex decomposed shape with [Menu bar --> Add --> Convex decomposition of selection...]: \n \n [Original shape, and convex shape pendant] \n \n \n [Original shape, and convex decomposed shape pendant] \n \n We now repeat the same procedure for all remaining robot links. Once that is done, we attach each visible shape to its corresponding invisible dynamic pendant. We do this by selecting first the visible shape, then via control-click selecting its dynamic pendant then [Menu bar --> Edit --> Make last selected object parent]. The same result can be achieved by dragging the visible shape onto its dynamic pendant in the  scene hierarchy : \n \n [Visible shapes attached to their dynamic pendants] \n \n We still need to take care of a few things: first, since we want the dynamic shapes only visible to the physics engine, but not to the other calculation modules, we uncheck all  object special properties  for the dynamic shapes, in the  object common properties . \n Then, we still have to configure the dynamic shapes as  dynamic  and  respondable . We do this in the  shape dynamics properties . Select first the base dynamic shape (i.e.  robot_dyn ), then check the  Body is respondable  item. Enable the first 4  Local respondable mask  flags, and disable the last 4  Local respondable mask  flags: it is important for consecutive respondable links not to collide with each other. For the first mobile dynamic link in our robot (i.e.  robot_link_dyn1 ), we also enable the  Body is respondable  item, but this time we disable the first 4  Local respondable mask  flags, and enable the last 4  Local respondable mask  flags. We repeat the above procedure with all other dynamic links, while always alternating the  Local respondable mask  flags: once the model will be defined, consecutive dynamic shapes of the robot will not generate any collision response when interacting with each other. Try to always end up with a construction where the dynamic base of the robot, and the dynamic last link of the robot have only the first 4  Local respondable mask  flags enabled, so that we can attach the robot to a mobile platform, or attach a gripper to the last dynamic link of the robot without dynamic collision interferences. \n Finally, we still need to tag our dynamic shapes as  Body is dynamic . We do this also in the  shape dynamics properties . We can then enter the mass and inertia tensor properties manually, or have those values automatically computed (recommended) by clicking  Compute mass & inertia properties for selected convex shapes . Remember also  this  and  that  dynamic design considerations. This dynamic base of the robot is a special case: most of the time we want the base of the robot (i.e.  robot_dyn ) to be non-dynamic (i.e. static), otherwise, if used alone, the robot might fall during movement. But as soon as we attach the base of the robot to a mobile platform, we want the base to become dynamic (i.e. non-static). We do this by enabling the  Set to dynamic if gets parent  item, then disabling the  Body is dynamic item . Now run the simulation: all dynamic shapes, except for the base of the robot, should fall. That attached visual shapes will follow their dynamic pendants. \n \n \n \n Model definition\n \n Now we are ready to define our model. We start by building the model herarchy: we attach the last dynamic robot link ( robot_link_dyn6 ) to its corresponding joint ( robot_joint6 ) by selecting  robot_link_dyn6 , then control-selecting  robot_joint6 , then [Menu bar --> Edit --> Make last selected object parent]. We could also have done this step by simply dragging object  robot_link_dyn6  onto  robot_link6  in the  scene hierarchy . We go on by now attaching  robot_joint6  to  robot_link_dyn5 , and so on, until arrived at the base of the robot. We now have following scene hierarchy: \n \n [Robot model hierarchy] \n \n It is nice and more logical to have a simple alias for the model base, since the model base will also represent the model itself. So we rename  robot_dyn  to  robot . Now we select the base of the hierarchy tree (i.e. object  robot ) and in the  object common properties  we enable  Object is model base . A model bounding box appeared, encompassing the whole robot. The bounding box however appears to be too large: this is because the bounding box also encompasses the invisible items, such as the joints. We now exclude the joints from the model bounding box by enabling the  Don't show as inside model selection  item for all joints. We could do the same procedure for all invisible items in our model. This is also a useful option in order to also exclude large sensors or other items from the model bounding box. We now have following situation: \n \n [Robot model bounding box] \n \n We now protect our model from accidental modification. We select all visible objects in the robot, then enable  Select base of model instead : if we now click a visible link in the scene, the base of the robot will be selected instead. This allows us to manipulate the model as if it was a single object. We can still select visible objects in the robot via control-shift-clicking in the scene, or by selecting the object in the scene hierarchy. We now put the robot into a correct default position/orientation. First, we save current scene as a reference (e.g. if at a later stage we need to import CAD data that have the same orientation at the curent robot). Then we select the model and  modify its position/orientation  appropriately. It is considered good practice to position the model (i.e. its base object) at X=0 and Y=0.  \n \n [Robot model in default configuration] \n \n We now run the simulation: the robot will collapse, since the joints are not controlled by default.  When we added the joints in the previous stage , we created joints in dynamic mode, but their motor or controller was disabled (by default). We can now adjust our joints to our requirements. In our case, we want a simple PID controller for each one of them. In the joint dynamic properties, we click  Motor enabled  and adjust the  maximum torque . We then click  Control loop enabled  and select  Position control (PID) . We now run the simulation again: the robot should hold its position. Try to switch the current physics engine to see if the behaviour is consistent across all supported physics engines. You can do this via the appropriate  toolbar button , or in the  general dynamics properties . \n During simulation, we now verify the scene dynamic content via the  Dynamic content visualization & verification toolbar button . Now, only items that are taken into account by the physics engine will be display, and the display is  color-coded . It is  very important  to always do this, and specially when your dynamic model doesn't behave as expected, in order to quickly debug the model. Similarly, always look at the scene hierarchy during simulation: dynamically enabled objects should display a ball-bounding icon on the right-hand side of their alias. \n \n [Dynamic content visualization & verification] \n \n Finally, we need to prepare the robot so that we can easily attach a gripper to it, or easily attach the robot to a mobile platform (for instance). Two dynamically enabled shapes can be rigidly attached to each other in two different ways: \n by grouping them : select the shapes, then [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. \n by attaching them via a force/torque sensor : a  force torque sensor  can also act as a rigid link between two separate dynamically enabled shapes. \n In our case, only option 2 is of interest. We create a force/torque sensor with [Menu bar --> Add --> Force sensor], then move it to the tip of the robot, then attach it to object  robot_link_dyn6 . We change its size and visual appearance appropriately (a red force/torque sensor is often perceived as an optional attachment point, check the various robot models available). We also change its alias to  robot_attachment : \n \n [Attachment force/torque sensor] \n \n Now we drag a gripper model into the scene, keep it selected, then control-click the attachment force sensor, then click the  Assembling/disassembling toolbar button . The gripper goes into place: \n \n [Attached gripper] \n \n The gripper knew how to attach itself because it was appropriately configured during its model definition. We now also need to properly configure the robot model, so that it will know how to attach itself to a mobile base for instance. We select the robot model, then click  Assembling  in the  object common properties . Set an empty string for  'Parent' match values , then click  Set matrix . This will memorize the current base object's local transformation matrix, and use it to position/orient itself relative to the mobile robot's attachment point. To verify that we did things right, we drag the model  Models/robots/mobile/KUKA Omnirob.ttm  into the scene. Then we select our robot model, then control-click one of the attachment points on the mobile platform, then click the  Assembling/disassembling toolbar button . Our robot should correctly place itself on top of the mobile robot: \n \n [Attached robot] \n \n Now we could add additional items to our robot, such as sensors for instance. At some point we might also want to attach  embedded scripts  to our model, in order to control its behaviour or configure it for various purposes. In that case, make sure to understand  how object handles are accessed from embedded scripts . We can also control/access/interface our model from a  plugin , from a  remote API  client, from a  ROS  node, or from an  add-on . \n Now we make sure we have reverted the changes done during robot and gripper attachment, we collapse the hierarchy tree of our robot model, select the base of our model, then save it with [Menu bar --> File --> Save model as...]. If we saved it in the  model  folder, then the model will be available in the  model brower . \n \n \n \n \n", 'tags': '', 'url': 'buildingAModelTutorial.html'}, {'title': 'lineFollowingBubbleRobTutorial', 'text': '\n \n \n \n \n Line following BubbleRob tutorial \n In this tutorial we aim at extending the functionality of BubbleRob to let it follow a line on the ground. Make sure you have fully read and understood the  first BubbleRob tutorial . This tutorial is courtesy of Eric Rohmer. \n Load the scene of the first BubbleRob tutorial located in  scenes/tutorials/BubbleRob . The scene file related to this tutorial is located in  scenes/tutorials/LineFollowingBubbleRob . Following figure illustrates the simulation scene that we will design: \n \n \n \n We first create the  first of 3  vision sensors  that we will attach to the  bubbleRob  object. Select [Menu bar --> Add --> Vision sensor --> Orthographic type]. Edit its properties, by double-clicking on the newly created vision sensor icon in the  scene hierarchy , and change the parameters to reflect following dialog: \n \n \n The vision sensor has to be facing the ground, so select it, and in the  orientation dialog , on the  orientation  tab,  set [180;0;0] for the  Alpha - Beta - Gamma  items. \n We have several possibilities to read a vision sensor. Since our vision sensor has just one pixel and operates in an easy way, we will simply query the average intensity value of the image read by our vision sensor. For more complex cases, we could have set-up a  vision callback function . Now copy and paste the vision sensor twice, and adjust its aliases to  eftSensor ,  middleSensor  and  rightSensor . Make  bubbleRob  their parent (i.e. attach them to the  bubbleRob  object). Your sensors should now look like this in the scene hierarchy: \n \n \n Let\'s position the sensors correctly. For that use the  position dialog , on the  position  tab, and set following absolute coordinates: \n left sensor: [0.2;0.042;0.018] \n middle sensor: [0.2;0;0.018] \n right sensor: [0.2;-0.042;0.018] \n Now let\'s modify the environment. We can remove a few cylinders in front of BubbleRob. Next, we will build the  path  that the robot will try to follow: click [Menu bar --> Add --> Path --> Closed]. You have several possibilities to adjust the shape of the path, by manipulating its control points: you can delete or duplicate them, and you can shift/reorient them.  Enable the  object movement with the mouse , and adjust the path to your liking. \n Once you are satisfied with the geometry of the path (you can always modify it at a later stage), open the  customization script  attached to it and replace its content with: \n \npath=require(\'path_customization\')\n\nfunction path.shaping(path,pathIsClosed,upVector)\n    local section={-0.02,0.001,0.02,0.001}\n    local color={0.3,0.3,0.3}\n    local options=0\n    if pathIsClosed then\n        options=options|4\n    end\n    local shape=sim.generateShapeFromPath(path,section,options,upVector)\n    sim.setShapeColor(shape,nil,sim.colorcomponent_ambient_diffuse,color)\n    return shape\nend \n  Restart the customization script for the changes to take effect, then open the path\'s  user configuration dialog  and check the  Generate extruded shape  checkbox. \n \n The last step is to adjust the controller of BubbleRob, so that it will also follow the black path. Open the  child script  attached to  bubbleRob , and replace it with following code: \n \nfunction sysCall_init()\n    bubbleRobBase=sim.getObject(\'.\')\n    leftMotor=sim.getObject("./leftMotor")\n    rightMotor=sim.getObject("./rightMotor")\n    noseSensor=sim.getObject("./sensingNose")\n    minMaxSpeed={50*math.pi/180,300*math.pi/180}\n    backUntilTime=-1 -- Tells whether bubbleRob is in forward or backward mode\n    floorSensorHandles={-1,-1,-1}\n    floorSensorHandles[1]=sim.getObject("./leftSensor")\n    floorSensorHandles[2]=sim.getObject("./middleSensor")\n    floorSensorHandles[3]=sim.getObject("./rightSensor")\n    robotTrace=sim.addDrawingObject(sim.drawing_linestrip+sim.drawing_cyclic,2,0,-1,200,{1,1,0})\n    -- Create the custom UI:\n    xml = \'<ui title="\'..sim.getObjectAlias(bubbleRobBase,1)..\' speed" closeable="false" resizeable="false" activate="false">\'..[[\n                <hslider minimum="0" maximum="100" on-change="speedChange_callback" id="1"/>\n            <label text="" style="* {margin-left: 300px;}"/>\n        </ui>\n        ]]\n    ui=simUI.create(xml)\n    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.5\n    simUI.setSliderValue(ui,1,100*(speed-minMaxSpeed[1])/(minMaxSpeed[2]-minMaxSpeed[1]))\n    \nend\n\nfunction sysCall_sensing()\n    local p=sim.getObjectPosition(bubbleRobBase,-1)\n    sim.addDrawingObjectItem(robotTrace,p)\nend \n\nfunction speedChange_callback(ui,id,newVal)\n    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100\nend\n\nfunction sysCall_actuation() \n    result=sim.readProximitySensor(noseSensor)\n    if (result>0) then backUntilTime=sim.getSimulationTime()+4 end\n    \n    -- read the line detection sensors:\n    sensorReading={false,false,false}\n    for i=1,3,1 do\n        result,data=sim.readVisionSensor(floorSensorHandles[i])\n        if (result>=0) then\n            sensorReading[i]=(data[11]<0.5) -- data[11] is the average of intensity of the image\n        end\n    end\n    \n    -- compute left and right velocities to follow the detected line:\n    rightV=speed\n    leftV=speed\n    if sensorReading[1] then\n        leftV=0.03*speed\n    end\n    if sensorReading[3] then\n        rightV=0.03*speed\n    end\n    if sensorReading[1] and sensorReading[3] then\n        backUntilTime=sim.getSimulationTime()+2\n    end\n    \n    if (backUntilTime<sim.getSimulationTime()) then\n        -- When in forward mode, we simply move forward at the desired speed\n        sim.setJointTargetVelocity(leftMotor,leftV)\n        sim.setJointTargetVelocity(rightMotor,rightV)\n    else\n        -- When in backward mode, we simply backup in a curve at reduced speed\n        sim.setJointTargetVelocity(leftMotor,-speed/2)\n        sim.setJointTargetVelocity(rightMotor,-speed/8)\n    end\nend \n\nfunction sysCall_cleanup() \n    simUI.destroy(ui)\nend \n\n \n You can easily debug your line following vision sensors: select one, then in the scene view select [Right-click --> Add --> Floating view], then in the newly added floating view select [Right click --> View --> Associate view with selected vision sensor].\n \n \n \n \n \n', 'tags': '', 'url': 'lineFollowingBubbleRobTutorial.html'}, {'title': 'inverseKinematicsTutorial', 'text': '\n \n \n \n \n Inverse kinematics tutorial \n This tutorial explains how to use CoppeliaSim\'s  kinematics functionality , while building a 7 DoF redundant manipulator. But before that, make sure  to have a look at the various example scenes related to IK and FK in folder  scenes/kinematics .  \n This tutorial is segmented into 3 parts: \n Building  the simple simulation model of a redundant manipulator \n Setting up  an inverse kinematics task \n Testing  the inverse kinematics \n \n \n \n Simple simulation model\n \n For this tutorial, we will build a non-dynamic manipulator, that just uses inverse kinematics without using any physics engine functionality. The CoppeliaSim CAD data related to this tutorial ( redundantManipulator.stl ) is located in CoppeliaSim\'s installation folder  cadFiles . A CoppeliaSim scene related to this tutorial can be found in  scenes/tutorials/InverseKinematics . Click [Menu bar --> File --> Import --> Mesh...] then select the file to import. Also refer to the section on how to  import/export shapes . A dialog pops open with various import options. Click  Import . A single  simple shape  was imported and is located in the middle of the scene. The shape also appears in the  scene hierarchy  on the left hand side of the main window. Depending on how the original CAD data was exported, the imported CAD data could be at a different scale, different location, or even subdivided into several shapes. Following figure shows the imported shape: \n \n \n \n As you can see, the import operation has left us with a single shape, where we expected several shapes. This means that we will have to divide the manipulator object ourselves: select the object (just click on it in the scene or the scene hierarchy), then click [Menu bar --> Edit --> Grouping/Merging --> Divide selected shapes]. Following is what you should have: \n \n \n \n The original shape was divided into several sub-shapes (see also the scene hierarchy). The shape division algorithm operates by grouping all triangles that are linked by common edges. Depending on how the original mesh was created or exported, such a division procedure cannot be performed. In that case you will have to manually extract shapes in the  triangle edit mode  or in an external editor. \n \n Next, we will change colors of the various objects so as to have a nice visual appearance. First double-click a shape icon in the scene hierarchy. The  shape properties  dialog opens. While a shape is selected, click on  Adjust  color  in the dialog: this will allow you to adjust the various color components of the  selected shape. For now, just adjust the ambient/diffuse color component of your shapes. To transfer the color of one shape to another shape, select both shapes and make sure the last selected shape (indicated with a white bounding box) is the one you want to take the color from, then simply click the  Apply to selection  button in the  Colors  section of the shape dialog. Once you finished coloring, you might have following situation: \n \n \n \n In next step, we will add the 7  joints  of the manipulator. One way of doing this is to add the joints into the scene, then specify their appropriate position and orientation (through the  position dialog  and the  orientation dialog ). This is however not possible, when you don\'t know the exact joint linear/angular positions as in our case, and so we will have to  extract  them from the shapes that we have: \n \n Select all imported shapes and click [Menu bar --> Edit --> Reorient bounding box --> with reference frame of world]. This operation guarantees that our  bounding boxes  are aligned with the absolute reference frame, and given the current manipulator configuration, represents the smallest bounding boxes. Click [Menu bar --> Add --> Joint --> Revolute] to insert a revolute joint into the scene. The default position is at (0;0;0) and its default orientation is vertical, and so the joint is hidden by the manipulator\'s base cylinder. While the joint is still selected, ctrl-select the base cylinder, then open the  position dialog  on the  position  tab and click the  Apply to selection . This just positioned the joint at the exact same coordinates as the base cylinder (this operation however only slightly adjusted the joint\'s vertical position since it was already almost in position). Now repeat the procedure for all other joints in the manipulator (remember there should be a total of 7). All joints are in position now, however, some of them have the wrong orientation. Select all joints that should be aligned with the world\'s Y-axis, then enter (90,0,0) for the  Alpha ,  Beta  and  Gamma  items in the  orientation dialog , on the  orientation  tab,  then click the  Apply to selection  button. Next, select the joint that should be aligned with the world\'s X-axis, then enter (0,90,0) for   Alpha ,  Beta  and  Gamma . All joints have the right position and orientation now.  \n \n You can now adjust the joint sizes (check the  Length  and  Diameter  items) in the  joint properties  dialog (that you can open by double-clicking a joint icon in the scene hierarchy). Make sure that all joints are clearly visible. This is what you should have: \n \n \n \n The next step in this tutorial is to group shapes that belong to the same rigid entity. Select the 5 shapes that are part of link 1 (the base cylinder being link 0), then click [Menu bar --> Edit --> Grouping/Merging --> Group selected shapes]. Once the shapes are grouped in a compound shape, you could re-align its bounding box with the world, but this step is not required (and has only a visual effect). Repeat the same procedure with all shapes that logically belong together. In this tutorial we will not actuate the gripper\'s fingers, and so simply rigidly group them with the last link. When all shapes that are meant to be grouped share the same visual attributes, try merging them together instead: [Menu bar --> Edit --> Grouping/Merging --> Merge selected shapes]. \n \n At this point you can rename all objects in the scene in following way, when going from base to tip:  redundantRobot  -   redundantRob_joint1   -  redundantRob_link1  -  redundantRob_joint2 , etc. Just double-click an object\'s alias in the scene hierarchy to edit it. \n \n Now we can build the kinematic chain, going from tip to base: select object  redundantRob_link7 , then ctrl-select object  redundantRob_joint7  and click [Menu bar --> Edit --> Make last selected object parent]. Alternatively you can drag an object onto another one in the scene hierarchy to achieve a similar operation. Next do the same for object  redundantRob_joint7  and object  redundantRob_link6 . Continue in a same way until the whole kinematic chain of the manipulator was built. This is what you should have (notice the scene hierarchy structure): \n \n \n \n Select all joints, then in the joint dialog, select  kinematic mode , then click  Apply to selection . Keep the joints selected, then open the  object common properties  and in the  Visibility layers  section, disable layer 2 and enable layer 10, then click the related  Apply to selection  button. This just sent all joints to the visibility layer 10, effectively making them invisible. Have a look at the  layer selection dialog  if you wish to temporarily enable/disable some layers. \n In CoppeliaSim, an IK task requires specifying at least following elements: \n a kinematic chain described with a  tip  dummy and a  base  object.  \n a  target  dummy that the  tip  dummy will be constrained to follow.  \n We already have the base object (object  redundantRobot ). Let\'s add a  dummy object , rename it to  redundantRob_tip  and set its position to (0.324,0,0.62) using the coordinate and transformation dialog. Next, attach the dummy to  redundantRob_link7  (select  redundantRob_tip , then  redundantRob_link7 , then [Menu bar --> Edit --> Make last selected object parent]. The  tip  dummy is ready! \n \n Now let\'s prepare the  target  dummy: copy and paste  redundantRob_tip  and rename the copy to  redundantRob_target . The  target  dummy is ready. \n Now we will  add a way to easily manipulate the robot, without having to worry about breaking it by shifting the wrong objects around. We will therefore define it as a  model . First, move  redundantRob_tip  and  redundantRob_target  to layer 11 to make both dummies invisible. Then shift-select all visible objects in the scene view, ctrl-click the object  redundantRobot  in the scene hierarchy to remove it from the selection, then open the  object common properties  dialog. Check the  Select base of model instead  item, then the related  Apply to selection  button. Clear the selection with <ESC>, then select  redundantRobot . In the same dialog, check the  Object is model base  item, then close the dialogs. Notice how a stippled bounding box now encompasses the whole manipulator: \n \n \n \n Click any object on the manipulator and notice how the base object  redundantRobot  always gets selected instead. \n \n Next, we add a  manipulation sphere  that we will use to manipulate the robot\'s gripper position/orientation. Click [Menu bar --> Add --> Primitive shape --> Sphere] to open the  primitive shape dialog , indicate 0.05 for the  X-Size ,  Y-Size  and  Z-Size , then uncheck the  Create dynamic and respondable shape  item and click  OK . Adjust the newly added sphere\'s position to be the same as  redundantRob_target  (using the coordinate and transformation dialog). The sphere now appears at the tip of the manipulator. Rename the sphere to  redundantRob_manipSphere , then make it parent of  redundantRob_target . Make   redundantRobot  parent of  rendundantRob_manipSphere : the target dummy and the manipulation sphere are now also part of the robot model. Collapse the  redundantRobot  tree in the scene hierarchy. The redundant manipulator model is ready! \n \n \n \n Setting up the inverse kinematics task\n \n Inverse kinematics is entirely set up by having a script calling appropriate API commands: the idea is to build an equivalent kinematic model via the  functions provided by the  kinematics plugin . The approach uses the concept and terminology of  IK groups and IK elements . \n Select object  redundantRobot , then [Menu bar --> Add --> Associated child script --> Non-threaded] to attach a  child script  to that object. Double-click the script icon that appeared next to the object alias, and replace the script content with following code: \n \nfunction sysCall_init()\n    -- Build a kinematic chain and 2 IK groups (undamped and damped) inside of the IK plugin environment,\n    -- based on the kinematics of the robot in the scene:\n    -- There is a simple way, and a more elaborate way (but which gives you more options/flexibility):\n\n    -- Simple way:\n    local simBase=sim.getObject(\'.\')\n    local simTip=sim.getObject(\'./redundantRob_tip\')\n    local simTarget=sim.getObject(\'./redundantRob_target\')\n    -- create an IK environment:\n    ikEnv=simIK.createEnvironment()\n    -- create an IK group: \n    ikGroup_undamped=simIK.createIkGroup(ikEnv)\n    -- set its resolution method to undamped: \n    simIK.setIkGroupCalculation(ikEnv,ikGroup_undamped,simIK.method_pseudo_inverse,0,6)\n    -- create an IK element based on the scene content: \n    simIK.addIkElementFromScene(ikEnv,ikGroup_undamped,simBase,simTip,simTarget,simIK.constraint_pose)\n    -- create another IK group: \n    ikGroup_damped=simIK.createIkGroup(ikEnv)\n    -- set its resolution method to damped: \n    simIK.setIkGroupCalculation(ikEnv,ikGroup_damped,simIK.method_damped_least_squares,1,99)\n    -- create an IK element based on the scene content: \n    simIK.addIkElementFromScene(ikEnv,ikGroup_damped,simBase,simTip,simTarget,simIK.constraint_pose) \n    \n    -- Elaborate way:\n    --[[\n    simBase=sim.getObject(\'.\')\n    simTip=sim.getObject(\'./redundantRob_tip\')\n    simTarget=sim.getObject(\'./redundantRob_target\')\n    simJoints={}\n    for i=1,7,1 do\n        simJoints[i]=sim.getObject(\'./redundantRob_joint\'..i)\n    end\n    ikJoints={}\n    -- create an IK environment:\n    ikEnv=simIK.createEnvironment()\n    -- create a dummy in the IK environment: \n    ikBase=simIK.createDummy(ikEnv)\n    -- set that dummy into the same pose as its CoppeliaSim counterpart: \n    simIK.setObjectMatrix(ikEnv,ikBase,-1,sim.getObjectMatrix(simBase,-1)) \n    local parent=ikBase\n    for i=1,#simJoints,1 do -- loop through all joints\n        -- create a joint in the IK environment:\n        ikJoints[i]=simIK.createJoint(ikEnv,simIK.jointtype_revolute)\n        -- set it into IK mode: \n        simIK.setJointMode(ikEnv,ikJoints[i],simIK.jointmode_ik)\n        -- set the same joint limits as its CoppeliaSim counterpart joint: \n        local cyclic,interv=sim.getJointInterval(simJoints[i])\n        simIK.setJointInterval(ikEnv,ikJoints[i],cyclic,interv)\n        -- set the same joint lin./ang. position as its CoppeliaSim counterpart joint: \n        simIK.setJointPosition(ikEnv,ikJoints[i],sim.getJointPosition(simJoints[i]))\n        -- set the same object pose as its CoppeliaSim counterpart joint: \n        simIK.setObjectMatrix(ikEnv,ikJoints[i],-1,sim.getObjectMatrix(simJoints[i],-1))\n        -- set its corresponding parent: \n        simIK.setObjectParent(ikEnv,ikJoints[i],parent,true) \n        parent=ikJoints[i]\n    end\n    -- create the tip dummy in the IK environment:\n    ikTip=simIK.createDummy(ikEnv)\n    -- set that dummy into the same pose as its CoppeliaSim counterpart: \n    simIK.setObjectMatrix(ikEnv,ikTip,-1,sim.getObjectMatrix(simTip,-1))\n    -- attach it to the kinematic chain: \n    simIK.setObjectParent(ikEnv,ikTip,parent,true)\n    -- create the target dummy in the IK environment: \n    ikTarget=simIK.createDummy(ikEnv)\n    -- set that dummy into the same pose as its CoppeliaSim counterpart: \n    simIK.setObjectMatrix(ikEnv,ikTarget,-1,sim.getObjectMatrix(simTarget,-1))\n    -- link the two dummies: \n    simIK.setLinkedDummy(ikEnv,ikTip,ikTarget)\n    -- create an IK group: \n    ikGroup_undamped=simIK.createIkGroup(ikEnv)\n    -- set its resolution method to undamped: \n    simIK.setIkGroupCalculation(ikEnv,ikGroup_undamped,simIK.method_pseudo_inverse,0,6)\n    -- make sure the robot doesn\'t shake if the target position/orientation wasn\'t reached: \n    simIK.setIkGroupFlags(ikEnv,ikGroup_undamped,1+2+4+8)\n    -- add an IK element to that IK group: \n    local ikElementHandle=simIK.addIkElement(ikEnv,ikGroup_undamped,ikTip)\n    -- specify the base of that IK element: \n    simIK.setIkElementBase(ikEnv,ikGroup_undamped,ikElementHandle,ikBase)\n    -- specify the constraints of that IK element: \n    simIK.setIkElementConstraints(ikEnv,ikGroup_undamped,ikElementHandle,simIK.constraint_pose)\n    -- create another IK group: \n    ikGroup_damped=simIK.createIkGroup(ikEnv)\n    -- set its resolution method to damped: \n    simIK.setIkGroupCalculation(ikEnv,ikGroup_damped,simIK.method_damped_least_squares,1,99)\n    -- add an IK element to that IK group: \n    local ikElementHandle=simIK.addIkElement(ikEnv,ikGroup_damped,ikTip)\n    -- specify the base of that IK element: \n    simIK.setIkElementBase(ikEnv,ikGroup_damped,ikElementHandle,ikBase)\n    -- specify the constraints of that IK element: \n    simIK.setIkElementConstraints(ikEnv,ikGroup_damped,ikElementHandle,simIK.constraint_pose) \n    --]]\nend\n\nfunction sysCall_actuation()\n    -- There is a simple way, and a more elaborate way (but which gives you more options/flexibility):\n    \n    -- Simple way:\n    -- try to solve with the undamped method:\n    if simIK.applyIkEnvironmentToScene(ikEnv,ikGroup_undamped,true)==simIK.result_fail then \n        -- the position/orientation could not be reached.\n        -- try to solve with the damped method:\n        simIK.applyIkEnvironmentToScene(ikEnv,ikGroup_damped)\n        -- We display a IK failure report message:\n        sim.addLog(sim.verbosity_scriptwarnings,"IK solver failed.") \n    end\n    \n    -- Elaborate way:\n    --[[\n    -- reflect the pose of the target dummy to its counterpart in the IK environment:\n    simIK.setObjectMatrix(ikEnv,ikTarget,ikBase,sim.getObjectMatrix(simTarget,simBase)) \n    -- try to solve with the undamped method:\n    if simIK.handleIkGroup(ikEnv,ikGroup_undamped)==simIK.result_fail then \n        -- the position/orientation could not be reached.\n        -- try to solve with the damped method:\n        simIK.handleIkGroup(ikEnv,ikGroup_damped)\n        -- We display a IK failure report message: \n        sim.addLog(sim.verbosity_scriptwarnings,"IK solver failed.") \n    end\n    -- apply the joint values computed in the IK environment to their CoppeliaSim joint counterparts:\n    for i=1,#simJoints,1 do\n        sim.setJointPosition(simJoints[i],simIK.getJointPosition(ikEnv,ikJoints[i])) \n    end\n    --]]\nend \n\nfunction sysCall_cleanup()\n    -- erase the IK environment: \n    simIK.eraseEnvironment(ikEnv) \nend  \n Above script creates an equivalent kinematic model from the CoppeliaSim model, then in each simulation step, reads the position/orientation of the CoppeliaSim target, applies it to the target of the equivalent kinematic model, runs the IK solver, and finally reads the joint angles of the equivalent kinematic model, and applies them to the joints of the CoppeliaSim model. To handle singular configurations and situations where the target is out of reach, we first try with a non-damped solver, and if it fails, we revert to a damped solver (with a damped solver, when damping is large, resolution becomes more stable but convergence slower). \n \n Running the simulation\n \n Our inverse kinematics task is ready! Let\'s test it. Run the simulation, then select the green manipulation sphere. Next,  select the  object translation  toolbar button: \n \n \n \n Now drag the object with the mouse: the manipulator should follow. Also try the  object rotation  toolbar button: \n \n \n \n Try also holding down the ctr- or shift-keys during manipulation. Switch back to the object translation toolbar button, and try to drag the object as far as possible, and notice how the inverse kinematics task is quite robust, thanks to the damped component. Stop the simulation, then disable the damped IK group and try again. Try also to disable individual constraints in the corresponding IK element and notice how the manipulator behaves during simulation. \n \n Run the simulation, and copy-paste a few times the manipulator and shift/rotate the copies around, also changing their configurations by dragging their manipulation spheres. Notice how every manipulator instance is fully functional regarding IK. \n \n \n \n', 'tags': '', 'url': 'inverseKinematicsTutorial.html'}, {'title': 'externalControllerTutorial', 'text': "\n \n \n \n \n External controller tutorial \n There are several ways one can control a robot or simulation in CoppeliaSim:  \n The most convenient way is to write a  child script  (in Lua or Python) that will handle the behaviour of a given robot or  model . It is the most convenient way, because child scripts are directly attached to  scene objects , they will be duplicated together with their associated scene objects, they do not need any compilation with an external tool, they can run in  threaded or non-threaded mode , they can be extended via  custom script functions  or via Lua/Python language extension mechanisms. Another major advantage in using child scripts: there is no communication lag as with the last 3 methods mentioned in this section (i.e. the  regular API  is used), and child scripts are part of the application main thread (inherent synchronous operation). There are however  small differences between Lua and Python . \n \n  Another way one can control a robot or a simulation is by writing a  plugin . The plugin mechanism allows for callback mechanisms,  custom script function registration , and of course access to external function libraries. A plugin is often used in conjunction with child scripts (e.g. the plugin registers custom script functions, that, when called from a child script, will call back a specific plugin function). A major advantage in using plugins is also that  there is no communication lag as with the last 3 methods mentioned in this section (i.e. the  regular API  is used), and that a plugin is part of the application main thread (inherent synchronous operation). The drawbacks with plugins are: they are more complicated to program, and they need to be compiled with an external too. Refer also to the  plugin tutorial . \n \n  A third way one can control a robot or a simulation is by writing an external client application that relies on the  remote API . This is a very convenient and easy way, if you need to run the control code from an external application, from a robot or from another computer. This also allows you to control a simulation or a  model  (e.g. a virtual robot) with the exact same code as the one that runs the real robot. \n \n A forth way to control a robot or a simulation is via a  ROS  node. In a similar way as the  remote API , ROS is a convenient way to have several distributed processes communicate with each other. While the remote API is very lightweight and fast, it allows only communication with CoppeliaSim. ROS on the other hand allows connecting virtually any number of processes with each other, and a large amount of compatible libraries are available. It is however heavier and more complicated than the remote API. Refer to the  ROS interfaces  for details. \n \n A fifth way to control a robot or a simulation is by writing an external application that communicates via various means (e.g. pipes,  ZeroMQ ,  sockets ,  serial port , etc.) with a CoppeliaSim plugin or CoppeliaSim script. Two major advantages are the choice of programming language, which can be just any language, and the flexibility. Here also, the control code can run on a robot, or a different computer. This way of controlling a simulation or a model is however more tedious that the methods with the  remote API . \n \n There are 7 scene files related to this tutorial: \n scenes/controlTypeExamples/controlledViaScript : three robots are controlled via their respective  child script : one runs Lua threaded code, one runs Lua non-threaded code, and the last one runs Python non-threaded code. \n scenes/controlTypeExamples/controlledViaPlugin : the robot is controlled via a  plugin . \n scenes/controlTypeExamples/controlledViaRemoteApi : the robot is controlled via an  external application  and the   ZeroMQ remote API . \n scenes/controlTypeExamples/controlledViaRos : the robot is controlled via an  external application  and the  ROS interface . \n scenes/controlTypeExamples/controlledViaRos2 : the robot is controlled via an  external application  and the  ROS 2 interface . \n scenes/controlTypeExamples/controlledViaZmq : the robot is controlled via and  external application  and  ZeroMQ . \n scenes/controlTypeExamples/controlledViaTcp : the robot is controlled via an  external application  and  LuaSocket  and TCP. \n \n \n In all 7 cases,  child scripts  are used, mainly to make the link with the outside world (e.g. launch the correct client application, and pass the correct object handles to it). There are two other ways one can control a robot, a simulation, or the simulator itself: by using  customization scripts , or  add-ons . They are however not recommended for control and should be rather used to handle functionality while simulation is not running. \n As an example, the child script linked to the robot in scene  controlledViaRos.ttt  has following main tasks: \n Check if the  ROS Interface / ROS 2 Interface  for CoppeliaSim was loaded \n Launch the controller application ( rosBubbleRob  /  ros2BubbleRob ) with some topic names or object handles as arguments \n As another example, the child script linked to the robot in scene  controlledViaZmq.ttt  has following main tasks: \n Search for a free socket connection port \n Launch the controller application ( bubbleRobZmqServer ) with the chosen connection port as argument \n Locally connect to the controller application \n At each simulation pass, send the sensor values to the controller, and read the desired motor values from the controller \n At each simulation pass, apply the desired motor values to the robot's joints \n Run the simulations, and copy-and-paste the robot: you will see that the duplicated robots will directly be operational, since their attached child scripts are in charge of launching new instances of their respective external applications, or calling the appropriate plugin functions. \n \n \n \n \n \n \n", 'tags': '', 'url': 'externalControllerTutorial.html'}, {'title': 'pluginTutorial', 'text': '\n \n \n \n \n Plugin tutorial \n This tutorial describes how to write a  plugin  for CoppeliaSim. The CoppeliaSim scene file related to this tutorial is located in  scenes/tutorials/BubbleRobExt . The plugin project files of this tutorial can be found  here . \n \n CoppeliaSim automatically loads all plugins that it can find in its folder (i.e. the installation folder, or the same folder as the one that contains  coppeliaSim.exe ) at program start-up. CoppeliaSim recognizes plugin files with following mask: "simExt*.dll" on Windows, "libsimExt*.dylib" on Mac OS and "libsimExt*.so" on Linux. Additionally a plugin\'s filename should not contain any underscore. The plugin file of this tutorial is  simExtBubbleRob.dll . When testing it, make sure it was properly loaded at CoppeliaSim start-up: switch the  console window  to visible by unchecking the  Hide console window  item in the  user settings dialog  ([Menu bar --> Tools --> Settings]). This option is only available in the Windows version. On Mac, have a look at the system\'s console, and on Linux try to start CoppeliaSim from within a console. The console window should display something similar to this: \n \n \n \n As you already understood, this plugin was written for BubbleRob from the  BubbleRob tutorial . Load the related scene file ( scenes/tutorials/BubbleRobExt/BubbleRobExt.ttt ). The BubbleRob plugin adds 4 new script functions (custom script functions should follow the convention: "simXXX.YYY" for the name, e.g. simRob.start): \n \n simBubble.create \n \n \n \n            Description \n         \n \n            Creates an instance of a BubbleRob controller in the plugin. \n \n \n \n            Lua synopsis\n         \n int bubbleRobHandle=simBubble.create(table[2] motorJointHandles,int sensorHandle,table[2] backRelativeVelocities) \n \n \n Lua parameters \n \n motorJointHandles : a table containing the handles of the left and right motor joints of the BubbleRob you wish to control. \n sensorHandle : the handle of the proximity sensor or the BubbleRob you wish to control \n backRelativeVelocities : when BubbleRob detects an obstacle, it will move backwards for some time. relativeBackVelocities[1] is the relative velocity of the left wheel when moving back. relativeBackVelocities[2] is the relative velocity of the right wheel when moving back \n \n \n \n \n            Lua return values\n         \n result: -1 in case of an error, otherwise the handle of the plugin\'s BubbleRob controller. \n \n \n \n \n            Python synopsis\n         \n int bubbleRobHandle=simBubble.create(list motorJointHandles,int sensorHandle,list backRelativeVelocities) \n \n \n \n simBubble.destroy \n \n \n \n            Description \n         \n \n            Destroys an instance of a BubbleRob controller previously created with simBubble.create. \n \n \n \n            Lua synopsis\n         \n bool result=simBubble.destroy(int bubbleRobHandle) \n \n \n Lua parameters \n \n bubbleRobHandle : the handle of a BubbleRob instance previously returned from simBubble.create. \n \n \n \n \n            Lua return values\n         \n result: false in case of an error \n \n \n \n \n            Python synopsis\n         \n bool result=simBubble.destroy(int bubbleRobHandle) \n \n \n \n simBubble.start \n \n \n \n            Description \n         \n \n            Sets a BubbleRob into an automatic movement mode \n         \n \n \n \n            Lua synopsis\n         \n bool result=simBubble.start(int bubbleRobHandle) \n \n \n Lua parameters \n \n bubbleRobHandle : the handle of a BubbleRob instance previously returned from simBubble.create. \n \n \n \n \n            Lua return values\n         \n \n result : false in case of an error \n \n \n \n \n            Python synopsis\n         \n bool result=simBubble.start(int bubbleRobHandle) \n \n \n \n simBubble.stop \n \n \n \n            Description \n         \n \n            Stops the automatic movement of a BubbleRob \n \n \n \n            Lua synopsis\n         \n bool result=simBubble.stop(int bubbleRobHandle) \n \n \n Lua parameters \n \n bubbleRobHandle : the handle of a BubbleRob instance previously returned from simBubble.create. \n \n \n \n \n            Lua return values\n         \n result: false in case of an error \n \n \n \n \n            Python synopsis\n         \n bool result=simBubble.stop(int bubbleRobHandle) \n \n \n \n Now open the threaded  child script  attached to the BubbleRob model in the scene (e.g. double-click the script icon next to object  bubbleRob  in the scene hierarchy). Inspect the code: \n \n \nfunction sysCall_init()\n    corout=coroutine.create(coroutineMain)\nend\n\nfunction sysCall_actuation()\n    if coroutine.status(corout)~=\'dead\' then\n        local ok,errorMsg=coroutine.resume(corout)\n        if errorMsg then\n            error(debug.traceback(corout,errorMsg),2)\n        end\n    end\nend\n\nfunction coroutineMain()\n    -- Check if the required plugin is there:\n    moduleName=0\n    moduleVersion=0\n    index=0\n    bubbleRobModuleNotFound=true\n    while moduleName do\n        moduleName,moduleVersion=sim.getModuleName(index)\n        if (moduleName==\'BubbleRob\') then\n            bubbleRobModuleNotFound=false\n        end\n        index=index+1\n    end\n    if bubbleRobModuleNotFound then\n        sim.addLog(sim.verbosity_scripterrors,\'BubbleRob plugin was not found. Simulation will not run properly.\')\n    else\n        local jointHandles={sim.getObject(\'./leftMotor\'),sim.getObject(\'./rightMotor\')}\n        local sensorHandle=sim.getObject(\'./sensingNose\')\n        local robHandle=simBubble.create(jointHandles,sensorHandle,{0.5,0.25})\n        if robHandle>=0 then\n            simBubble.start(robHandle) -- start the robot\n            local st=sim.getSimulationTime()\n            sim.wait(20) -- run for 20 seconds\n            simBubble.stop(robHandle)\n            simBubble.destroy(robHandle)\n        end\n    end\nend \n The first part of the code is in charge of checking whether the plugin required to run this script (i.e.  simExtBubbleRob.dll ) is available (i.e. was found and successfully loaded). If not, an error message is displayed. Otherwise, joint and sensor handles are retrieved and given to the custom script function that creates a controller instance of our BubbleRob in the plugin. If the call was successfull, then we can call  simBubble.start . The function instructs the plugin to move the BubbleRob model while avoiding obstacles. Run the simulation: BubbleRob moves for 20 seconds then stops, as expected. Now leave CoppeliaSim. Temporarily rename the plugin to  TEMP_simExtBubbleRob.dll  so that CoppeliaSim won\'t load it anymore, then start CoppeliaSim again. Load the previous scene and run the simulation: an error message now appears, indicating that the required plugin could not be found. Leave CoppeliaSim again, rename back the plugin to  simExtBubbleRob.dll  and start CoppeliaSim again. \n \n Let\'s have a look at how the plugin registers and handles the above 4 custom Lua functions. Open the  BubbleRob plugin project , and have a look at file  simExtBubbleRob.cpp : \n Notice the 3 required plugin entry points:  simStart ,  simEnd , and  simMessage :  simStart  is called once when the plugin is loaded (initialization),  simEnd  is called once when the plugin is unloaded (clean-up), and  simMessage  is called on a regular basis with several type of messages. \n During the initialization phase, the plugin loads the CoppeliaSim library (in order to have access to all CoppeliaSim\'s API functions), then registers the 4 custom script functions. A custom script function is registered by specifying: \n  a function name \n  a calling tip string \n  a callback address \n When a script calls the specified function name, then CoppeliaSim calls the callback address. The most difficult task inside of a callback function is to correctly read the input arguments, and correctly write the output values. To ease the task, two helper classes are used, that will be in charge of that:  CScriptFunctionData  and  CScriptFunctionDataItem , located in  programming/common  and  programming/include . \n When writing your own custom script functions, try to use the same code layout/skeleton as was done in file  simExtBubbleRob.cpp . \n In general, callback routines should execute as fast as possible, and control should then be given back to CoppeliaSim, otherwise the whole simulator will halt.\n \n \n \n \n \n', 'tags': '', 'url': 'pluginTutorial.html'}, {'title': 'robotLanguageIntegrationTutorial', 'text': '\n \n \n \n \n Robot language interpreter integration tutorial \n This tutorial will try to explain how to integrate or embed a robot language interpreter into CoppeliaSim. The procedure is very similar in case you want to integrate an emulator (e.g. a specific microcontroller emulator) into CoppeliaSim. Extending CoppeliaSim\'s functionality requires most of the time the development of a  plugin . Make sure you have read the  tutorial on plugins  , and the  tutorial on external controllers  before proceeding with this tutorial. \n \n The CoppeliaSim  scene  file related to this tutorial is located in CoppeliaSim\'s installation folder   scenes\\robotLanguageControl.ttt . You can find the  plugin project files  here , and the server application project files  here . \n First, let\'s start by loading the related scene file  scenes\\robotLanguageControl.ttt : \n \n \n \n The  MTB  robot is an imaginary robot ( MTB  stands for  Machine Type B ), that will be controlled with an imaginary robot language. \n As previously stated, the used robot language is imaginary and very very simple. Following commands are supported (one command per line, input is case-sensitive): \n \n" REM " starts a comment line\n" SETLINVEL  v": sets the prismatic joint velocity for next movements (v is in m/s)\n" SETROTVEL  v": sets the revolute joint velocity for next movements (v is in degrees/s)\n" MOVE  p1 p2 p3 p4": moves to joint positions (p1;p2;p3;p4) (in degrees except for p3 in meters)\n" WAIT  x": waits x milliseconds\n" SETBIT  y": sets the bit at position y (1-32) in the robot output port\n" CLEARBIT  y": clears the bit at position y (1-32) in the robot output port\n" IFBITGOTO  y label": if bit at position y (1-32) in the robot input port is set, jump to "label"\n" IFNBITGOTO  y label": if bit at position y (1-32) in the robot input port is not set, jump to "label"\n" GOTO  label": jumps to "label" \n Any word different from " REM ", " SETLINVEL ", " SETROTVEL ", " MOVE ", " WAIT ", " SETBIT ", " CLEARBIT ", " IFBITGOTO ", " IFNBITGOTO " and " GOTO " is considered to be a label. Now run the simulation. If the related plugin was not found, following message displays (the display of the message is handled in the  child scripts  attached to  objects   MTB_Robot  and  MTB_Robot#0 ): \n \n \n \n If the related plugin was found, then the the MTB plugin will launch a server application (i.e.  mtbServer ) that basically represents the robot language interpreter and controller. There is no direct need for a server application, the mtbServer functionality could also be directly running inside of the MTB plugin. The main advantages of using that functionality inside of a server application are: \n The MTB plugin can act as intermediate for as many different languages as needed, also those that haven\'t been developed yet: the MTB plugin will simply launch the appropriate server depending on the used robot/language. \n If the robot language interpreter / controller crashes, CoppeliaSim won\'t crash, since the two are distinct and separate processes. \n Currently, the MTB server is in charge of two main tasks: \n receive the program code (i.e. a buffer) from the MTB plugin, compile it, and initialize the robot controller. \n apply input signals, step through the program code (the step duration can be different from step to step), and return output signals and joint angles.  \n If the MTB server detects an error during compilation of the program code, it will return an error message to the plugin, that will hand it over to the calling  child script  (i.e. in our case, the child scripts attached to objects  MTB_Robot  and  MTB_Robot#0 .), which will display (for example): \n \n \n \n If the compilation was successful, then the robots start executing their respective program. The simulation is a  maximum speed  simulation, but can  be switched to real-time simulation by toggling the related toolbar button: \n \n  The execution speed can be even more accelerated by pressing the appropriate toolbar button several times: \n \n Each  MTB robot  program can be individually paused, stopped or restarted at any time via their displayed custom dialog, which are  custom user interfaces : \n \n \n \n Above custom UI is the user-interface of the MTB robot and can be fully customized. Should the MTB robot be copied, then its custom UI will also be copied. Next to being able to controlling the program execution state, the custom UI also displays current program line ( Command ) and the MTB\'s current joint values. The user can also change the robot\'s input port bits, and read the robot\'s output port bits. Input and output ports can be read and respectively written by the robot language program. Input and output ports can also be written and read by external devices (e.g. the robot\'s gripper or suction pad) by using appropriate function calls (see further below). \n \n There are two  child scripts attached to the  MTB_Robot  and  MTB_Robot#0  objects. They are in charge of handling the custom dialogs and communicating with the MTB plugin. Most code in the child scripts could be handled by the plugin too. Open the child script attached to one of the two MTB robot (e.g. with a double-click on the script icon next to the robot model in the scene hierarchy). At the top of the script, you will see the robot language code. \n \n Try to modify an MTB robot\'s program to have it perform a different movement sequence. Experiment a little bit. \n The MTB robots are handled in following way: \n \nthe actual robot language program is compiled and executed by the "mtbServer" application. That application also holds the MTB robot\'s state variables. For each MTB robot in the simulation scene, there will be an instance of the  mtbServer  application launched by the  simExtMTB  plugin.\n \n \nthe  simExtMTB  plugin is in charge of providing custom script functions, and  also  launches the  mtbServer  application when needed, and communicates with it via socket communication. \n \nthe child scripts attached to  MTB_Robot  and  MTB_Robot#0  check whether the  simExtMTB  plugin is loaded and handle the communication with the plugin.  \n The MTB robot and its simple robot language is a simple prototype meant to demonstrate how to integrate a robot language interpreter into CoppeliaSim. It is very easy to extend current functionality for much more complex robots or robot languages. All what is needed is: \n \n Building the  model  of the robot. This includes  importing CAD data , adding  joints , etc. This step can be entirely done in CoppeliaSim. \n \n Writing a  plugin  to handle the new robot natively, i.e. to handle the new robot by interpreting its own robot language. Any language capable of accessing C-API functions and capable of being wrapped in a dll can be used to create the plugin (but c/c++ is preferred). The robot language interpreter could be directly embedded in the plugin, or launched as an external application ( mtbServer ) as is done in this tutorial. \n \n Writing a small  child script  responsible for handling  custom dialogs  and linking the robot with the plugin. This step can be entirely done in CoppeliaSim. \n \n Now let\'s have a look at the MTB\'s plugin project. There is one prerequisites to embedding a robot language interpreter (or other emulator) into CoppeliaSim: \n \n The robot language interpreter should be able to be executed several times in parallel. This means that several interpreter instances should be supported, in order to support several identical, in-parallel operating robots. This can be handled the easiest by launching a new interpreter for each new robot, as is done in this tutorial. \n \n When writing any plugin, make sure that the plugin accesses CoppeliaSim\'s  regular API  only from the main thread (or from a thread created by CoppeliaSim)! The plugin can launch new threads, but in that case those new threads should not be used to access CoppeliaSim (they can however be used to communicate with a server application, to communicate with some hardware, to execute background calculations, etc.). \n \n Now let\'s have a look at the child script that is attached to the MTB robot. The code might seem quite long or complicated. However most functionality handled in the child script could also be directly handled in the plugin, making the child script much smaller/cleaner. The advantage in handling most functionality in the child script is that modifications can be performed without having to recompile the plugin! \n \n Following is the MTB robot\'s child script main functionality: \n \n \nChecking whether the plugin was loaded. If not, an error message is output. \n Communicating with the plugin. This means that information is sent to and received from the MTB plugin with custom script functions. \n \n Applying the newly calculated joint values to the MTB robot model. This could also be handled in the MTB\'s plugin. \n \n Reacting to events on the custom dialogs, like button presses. \n Updating the state of the custom dialogs. \n \n Following 3 custom script functions are of main interest (others are exported by the plugin):  \n \n \nint mtbServerHandle,string message=simMTB.startServer(string mtbServerExecutable,\n    int portNumber,charBuffer program,table[4] jointPositions, table[2] velocities) \n \nint result,string message=simMTB.step(int mtbServerHandle,float timeStep) \n \ntable[4] jointValues=simMTB.getJoints(int mtbServerHandle) \n simMTB.startServer : launches the server application (e.g.  mtbServer ) on the specified port, connects to it, and sends it the robot language code, the initial linear/angular joint positions, and the initial velocities. In return, the function returns a server handle (if successful), and a message (usually a compilation error message). \n simMTB.step : steps through the robot language program with the specified timeStep, and returns a result value and a message (usually the code being currently executed). \n simMTB.getJoints : retrieves the current linear/angular joint positions. The linear/angular joint positions are automatically updated when  simMTB.step  is called. \n You could also imagine slightly modifying the step function, and add one additional function, in order to be able to handle intermediate events triggered by the robot language program execution. In that case, each simulation step would have to execute following script code (in a child script): \n \n \nlocal dt=sim.getSimulationTimeStep()\nwhile (dt>0) do\n    result,dt,cmdMessage=simMTB.step(mtbServerHandle,dt) -- where the returned dt is the remaining dt\n    local event=simMTB.getEvent()\n    while event~=-1 do\n        -- handle events here\n        event=simMTB.getEvent()\n    end\nend \n \n \n \n \n', 'tags': '', 'url': 'robotLanguageIntegrationTutorial.html'}, {'title': 'rosTutorial', 'text': '\n \n \n \n \n ROS Tutorials \n ROS tutorial \n ROS 2 tutorial \n \n \n \n \n', 'tags': '', 'url': 'rosTutorial.html'}, {'title': 'ros1Tutorial', 'text': '\n \n \n \n \n ROS tutorial \n This tutorial will try to explain in a simple way how you can manage to have CoppeliaSim  ROS enabled , based on  ROS Melodic  and  Catkin build . \n First of all you should make sure that you have gone through the  official ROS tutorials , at least the beginner section, and that you have installed the  Catkin tools . Then, we assume that you have the latest Ubuntu running, that ROS is installed, and that the workspace folders are set. Here also refer to the  official documentation regarding the ROS installation . \n The general ROS functionality in CoppeliaSim is supported via the  ROS Interface  ( libsimExtROS.so ). The Linux distribution should include that file already compiled in  CoppeliaSim/compiledROSPlugins , but it first needs to be copied to  CoppeliaSim/ , otherwise it won\'t be loaded. You might however experience plugin load problems, depending on your system specificities: make sure to always inspect the terminal window of CoppeliaSim for details about plugin load operations. Plugins are loaded when CoppeliaSim is launched. The ROS plugin will only successfully load and initialize if  roscore  is running at that time ( roscore  is the ROS master). Also make sure to source the ROS environment prior to running CoppeliaSim. \n If the plugin cannot be loaded, then you should recompile it by yourself. It is open source and can be modified as much as needed in order to support a specific feature or to extend its functionality. If specific messages/services/etc. need to be supported, make sure to edit files located in  simExtROS/meta/ , prior to recompilation. There are 2 packages: \n simExtROS : this package is the  ROS Interface  that will be compiled to a ".so" file, and that is used by CoppeliaSim. \n ros_bubble_rob : this is the package of a very simple robot controller that connects to CoppeliaSim via the  ROS Interface . This node will be in charge of controlling the  red robot in the demo scene  controlTypeExamples/controlledViaRos.ttt \n Above packages should be copied to your  catkin_ws/src   folder. Make sure that ROS is aware of those packages, i.e. that you can switch to above package folders with: \n \n$ roscd sim_ros_interface\n$ roscd ros_bubble_rob\n \n In order to build the packages, navigate to the  catkin_ws  folder and type: \n \n$ export COPPELIASIM_ROOT_DIR=~/path/to/coppeliaSim/folder\n$ catkin build --cmake-args -DCMAKE_BUILD_TYPE=Release\n \n Note for Ubuntu 20.04: due to a bug in python-catkin-tools you need to use catkin_make instead of catkin build. \n That\'s it! The packages should have been generated and compiled to a library. Copy the devel/lib/libsimExtROS.so file to the CoppeliaSim installation folder. The plugin is now ready to be used! \n Now open a terminal and start the ROS master with: \n \n$ roscore\n \n Open another terminal, move to the CoppeliaSim installation folder and start CoppeliaSim. This is what you should have (or similar): \n \n$ ./coppeliaSim.sh\n...\nPlugin \'ROSInterface\': loading...\nPlugin \'ROSInterface\': load succeeded.\n...\n \n Upon succesful ROS Interface load, checking the available nodes gives this: \n \n$ rosnode list\n/rosout\n/sim_ros_interface\n \n In an empty CoppeliaSim scene, select an object, then attach a non-threaded  child script  to it with [Menu bar --> Add --> Associated child script --> Non threaded]. Open the  script editor  for that script and replace the content with following: \n \nfunction subscriber_callback(msg)\n    -- This is the subscriber callback function\n    sim.addLog(sim.verbosity_scriptinfos,\'subscriber receiver following Float32: \'..msg.data)\nend\n\nfunction getTransformStamped(objHandle,name,relTo,relToName)\n    -- This function retrieves the stamped transform for a specific object\n    t=sim.getSystemTime()\n    p=sim.getObjectPosition(objHandle,relTo)\n    o=sim.getObjectQuaternion(objHandle,relTo)\n    return {\n        header={\n            stamp=t,\n            frame_id=relToName\n        },\n        child_frame_id=name,\n        transform={\n            translation={x=p[1],y=p[2],z=p[3]},\n            rotation={x=o[1],y=o[2],z=o[3],w=o[4]}\n        }\n    }\nend\n\nfunction sysCall_init()\n    -- The child script initialization\n    objectHandle=sim.getObject(\'.\')\n    objectAlias=sim.getObjectAlias(objectHandle,3)\n\n    -- Prepare the float32 publisher and subscriber (we subscribe to the topic we advertise):\n    if simROS then\n        publisher=simROS.advertise(\'/simulationTime\',\'std_msgs/Float32\')\n        subscriber=simROS.subscribe(\'/simulationTime\',\'std_msgs/Float32\',\'subscriber_callback\')\n    end\nend\n\nfunction sysCall_actuation()\n    -- Send an updated simulation time message, and send the transform of the object attached to this script:\n    if simROS then\n        simROS.publish(publisher,{data=sim.getSimulationTime()})\n        simROS.sendTransform(getTransformStamped(objectHandle,objectAlias,-1,\'world\'))\n        -- To send several transforms at once, use simROS.sendTransforms instead\n    end\nend\n\nfunction sysCall_cleanup()\n    -- Following not really needed in a simulation script (i.e. automatically shut down at simulation end):\n    if simROS then\n        simROS.shutdownPublisher(publisher)\n        simROS.shutdownSubscriber(subscriber)\n    end\nend \n Above script will publish the simulation time, and subscribe to it at the same time. It will also publish the transform of the object the script is attached to. You should be able to see the simulation time topic with: \n \n$ rostopic list\n \n To see the message content, you can type: \n \n$ rostopic echo /simulationTime\n \n Now load the demo scene  rosInterfaceTopicPublisherAndSubscriber.ttt , and run the simulation. The code in the  child script  attached to  Vision_sensor  will enable a publisher to stream the vision sensor\'s image, and also enable a subscriber to listen to that same stream. The subscriber applies the read data to the  passive vision sensor, that is only used as a data container. So CoppeliaSim is streaming data, while listening to the same data! This is what is happening: \n \n [Image publisher and image subscriber demo] \n \n Try experimenting a little bit with the code. You can also visualize the image that CoppeliaSim streams with following command: \n \n$ rosrun image_view image_view image:=/visionSensorData\n \n Had you been streaming simpler data, then you could also have visualized it with: \n \n$ rostopic echo /visionSensorData\n \n Now stop the simulation and load the demo scene  controlTypeExamples/controlledViaRos.ttt , and run the simulation. The robot is simplistic, and also behaving in a simplistic way for simplification purposes. It is controlled via the  ROS Interface : \n \n [External client application controlling the  robot via ROS] \n \n The child script attached to the  robot, and running in a non-threaded fashion, is in charge of following: \n determine some object handles (e.g. motor joint handles and proximity sensor handle) \n verify if the ROS Interface is loaded \n Launch motor speed subscribers \n Launch a sensor publisher and a simulation time publisher \n  and finally launch a client application. The application is called with some topic names as arguments, so that it will know which topics to listen to and to subscribe. The client application ( rosBubbleRob ) is then taking over the control of the  robot via ROS. \n While simulation is running, copy and paste a few times the   robot. Notice that every copy is directly operational and independent. This is one of the many strengths of CoppeliaSim. \n Now stop the simulation and open a new scene, then drag following model into it:  Models/tools/rosInterface helper tool.ttm . This model is constituted by a single  customization script  that offers following topic publishers and subscribers: \n startSimulation  topic: can be used to start a simulation by publishing on this topic a  std_msgs::Bool  message. \n pauseSimulation  topic: can be used to pause a simulation by publishing on this topic a  std_msgs::Bool  message. \n stopSimulation  topic: can be used to stop a simulation by publishing on this topic a  std_msgs::Bool  message. \n enableSyncMode  topic: by publishing a  std_msgs::Bool  message on this topic, you can enable/disable the  stepped mode . \n triggerNextStep  topic: by publishing a  std_msgs::Bool  message on this topic, you can trigger the next simulation step, while in the  stepped mode . \n simulationStepDone  topic: a message of type  std_msgs::Bool  will be published at the end of each simulation pass. \n simulationState  topic: messages of type  std_msgs::Int32  will be published on a regular basis.  0  indicates that the simulation is stopped,  1  that it is running and  2  that it is paused. \n simulationTime  topic: messages of type  std_msgs::Float32  will be published on a regular basis, indicating the current simulation time. \n Have a look at the content of the customization script, that can be fully customized for various purposes. Try generating topic messages from the command line, for instance: \n \n$ rostopic pub /startSimulation std_msgs/Bool true --once\n$ rostopic pub /pauseSimulation std_msgs/Bool true --once\n$ rostopic pub /stopSimulation std_msgs/Bool true --once\n$ rostopic pub /enableSyncMode std_msgs/Bool true --once\n$ rostopic pub /startSimulation std_msgs/Bool true --once\n$ rostopic pub /triggerNextStep std_msgs/Bool true --once\n$ rostopic pub /triggerNextStep std_msgs/Bool true --once\n$ rostopic pub /triggerNextStep std_msgs/Bool true --once\n$ rostopic pub /stopSimulation std_msgs/Bool true --once\n \n In order to display the current simulation time, you could type: \n \n$ rostopic echo /simulationTime\n \n Finally, make sure to have a look at the  remote API functionality  in CoppeliaSim: it allows for remote function execution, fast data streaming back and forth, is quite simple to use, leightweight and  cross-platform. The remote API functionality is available for 7 different languages and can be an interesting alternative to ROS in some cases. \n \n \n \n \n', 'tags': '', 'url': 'ros1Tutorial.html'}, {'title': 'ros2Tutorial', 'text': '\n \n \n \n \n ROS 2 tutorial \n This tutorial will try to explain in a simple way how you can manage to have CoppeliaSim  ROS 2 enabled , based on  ROS 2 Foxy . \n First of all you should make sure that you have gone through the  official ROS 2 tutorials , at least the beginner section. Then, we assume that you have the latest Ubuntu running, that ROS is installed, and that the workspace folders are set. Here also refer to the  official documentation regarding the ROS 2 installation . \n The general ROS 2 functionality in CoppeliaSim is supported via the  ROS 2 Interface  ( libsimExtROS2.so ). The Linux distribution should include that file already compiled in  CoppeliaSim/compiledROSPlugins , but it first needs to be copied to  CoppeliaSim/ , otherwise it won\'t be loaded. You might however experience plugin load problems, depending on your system specificities: make sure to always inspect the terminal window of CoppeliaSim for details about plugin load operations. Plugins are loaded when CoppeliaSim is launched. Also make sure to source the ROS 2 environment prior to running CoppeliaSim. \n If the plugin cannot be loaded, then you should recompile it by yourself. It is open source and can be modified as much as needed in order to support a specific feature or to extend its functionality. If specific messages/services/etc. need to be supported, make sure to edit files located in  simExtROS2/meta/ , prior to recompilation. There are   2 packages: \n simExtROS2 : this package is the  ROS 2 Interface  that will be compiled to a ".so" file, and that is used by CoppeliaSim. \n ros2_bubble_rob : this is the package of a very simple robot controller that connects to CoppeliaSim via the  ROS 2 Interface . This node will be in charge of controlling the  red robot in the demo scene  controlTypeExamples/controlledViaRos.ttt \n Above packages should be copied to your  ros2_ws/src   folder.  \n In order to build the packages, navigate to the  ros2_ws  folder and type: \n \n$ export COPPELIASIM_ROOT_DIR=~/path/to/coppeliaSim/folder\n$ ulimit -s unlimited #otherwise compilation might freeze/crash\n$ colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release\n \n That\'s it! The packages should have been generated and compiled to a library, which is automatically copied to the CoppeliaSim installation folder. The plugin is now ready to be used. \n Now open a terminal, move to the CoppeliaSim installation folder and start CoppeliaSim. This is what you should have (or similar): \n \n$ ./coppeliaSim.sh\n...\nPlugin \'ROS2Interface\': loading...\nPlugin \'ROS2Interface\': load succeeded.\n...\n \n Upon succesful ROS 2 Interface load, checking the available nodes gives this: \n \n$ ros2 node list\n/sim_ros2_interface\n \n In an empty CoppeliaSim scene, select an object, then attach a non-threaded  child script  to it with [Menu bar --> Add --> Associated child script --> Non threaded]. Open the  script editor  for that script and replace the content with following: \n \nfunction subscriber_callback(msg)\n    -- This is the subscriber callback function\n    sim.addLog(sim.verbosity_scriptinfos,\'subscriber receiver following Float32: \'..msg.data)\nend\n\nfunction getTransformStamped(objHandle,name,relTo,relToName)\n    -- This function retrieves the stamped transform for a specific object\n    t=simROS2.getSystemTime()\n    p=sim.getObjectPosition(objHandle,relTo)\n    o=sim.getObjectQuaternion(objHandle,relTo)\n    return {\n        header={\n            stamp=t,\n            frame_id=relToName\n        },\n        child_frame_id=name,\n        transform={\n            translation={x=p[1],y=p[2],z=p[3]},\n            rotation={x=o[1],y=o[2],z=o[3],w=o[4]}\n        }\n    }\nend\n\nfunction sysCall_init()\n    -- The child script initialization\n    objectHandle=sim.getObject(\'.\')\n    objectAlias=sim.getObjectAlias(objectHandle,3)\n\n    -- Prepare the float32 publisher and subscriber (we subscribe to the topic we publish):\n    if simROS2 then\n        publisher=simROS2.createPublisher(\'/simulationTime\',\'std_msgs/msg/Float32\')\n        subscriber=simROS2.createSubscription(\'/simulationTime\',\'std_msgs/msg/Float32\',\'subscriber_callback\')\n    end\nend\n\nfunction sysCall_actuation()\n    -- Send an updated simulation time message, and send the transform of the object attached to this script:\n    if simROS2 then\n        simROS2.publish(publisher,{data=sim.getSimulationTime()})\n        simROS2.sendTransform(getTransformStamped(objectHandle,objectAlias,-1,\'world\'))\n        -- To send several transforms at once, use simROS2.sendTransforms instead\n    end\nend\n\nfunction sysCall_cleanup()\n    -- Following not really needed in a simulation script (i.e. automatically shut down at simulation end):\n    if simROS2 then\n        simROS.shutdownPublisher(publisher)\n        simROS.shutdownSubscriber(subscriber)\n    end\nend \n Above script will publish the simulation time, and subscribe to it at the same time. It will also publish the transform of the object the script is attached to. You should be able to see the simulation time topic with: \n \n$ ros2 topic list\n \n To see the message content, you can type: \n \n$ ros2 topic echo /simulationTime\n \n Now load the demo scene  ros2InterfaceTopicPublisherAndSubscriber.ttt , and run the simulation. The code in the  child script  attached to  Vision_sensor  will enable a publisher to stream the vision sensor\'s image, and also enable a subscriber to listen to that same stream. The subscriber applies the read data to the  passive vision sensor, that is only used as a data container. So CoppeliaSim is streaming data, while listening to the same data! This is what is happening: \n \n [Image publisher and image subscriber demo] \n \n Try experimenting a little bit with the code. You can also visualize the image that CoppeliaSim streams with following command: \n \n$ ros2 run image_tools showimage --ros-args --remap image:=/visionSensorData\n \n Had you been streaming simpler data, then you could also have visualized it with: \n \n$ ros2 topic echo /visionSensorData\n \n Now stop the simulation and load the demo scene  controlTypeExamples/controlledViaRos2.ttt , and run the simulation. The robot is simplistic, and also behaving in a simplistic way for simplification purposes. It is controlled via the  ROS 2 Interface : \n \n [External client application controlling the  robot via ROS] \n \n The child script attached to the  robot, and running in a non-threaded fashion, is in charge of following: \n determine some object handles (e.g. motor joint handles and proximity sensor handle) \n verify if the ROS 2 Interface is loaded \n Launch motor speed subscribers \n Launch a sensor publisher and a simulation time publisher \n  and finally launch a client application. The application is called with some topic names as arguments, so that it will know which topics to listen to and to subscribe. The client application ( ros2BubbleRob ) is then taking over the control of the  robot via ROS 2. \n While simulation is running, copy and paste a few times the   robot. Notice that every copy is directly operational and independent. This is one of the many strengths of CoppeliaSim. \n Now stop the simulation and open a new scene, then drag following model into it:  Models/tools/ros2Interface helper tool.ttm . This model is constituted by a single  customization script  that offers following topic publishers and subscribers: \n startSimulation  topic: can be used to start a simulation by publishing on this topic a  std_msgs/msg/Bool  message. \n pauseSimulation  topic: can be used to pause a simulation by publishing on this topic a  std_msgs/msg/Bool  message. \n stopSimulation  topic: can be used to stop a simulation by publishing on this topic a  std_msgs/msg/Bool  message. \n enableSyncMode  topic: by publishing a  std_msgs/msg/Bool  message on this topic, you can enable/disable the  stepped mode . \n triggerNextStep  topic: by publishing a  std_msgs/msg/Bool  message on this topic, you can trigger the next simulation step, while in  stepped mode . \n simulationStepDone  topic: a message of type  std_msgs/msg/Bool  will be published at the end of each simulation pass. \n simulationState  topic: messages of type  std_msgs/msg/Int32  will be published on a regular basis.  0  indicates that the simulation is stopped,  1  that it is running and  2  that it is paused. \n simulationTime  topic: messages of type  std_msgs/msg/Float32  will be published on a regular basis, indicating the current simulation time. \n Have a look at the content of the customization script, that can be fully customized for various purposes. Try generating topic messages from the command line, for instance: \n \n$ ros2 topic pub /startSimulation std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /pauseSimulation std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /stopSimulation std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /enableSyncMode std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /startSimulation std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /triggerNextStep std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /triggerNextStep std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /triggerNextStep std_msgs/msg/Bool \'{data: true}\' --once\n$ ros2 topic pub /stopSimulation std_msgs/msg/Bool \'{data: true}\' --once\n \n In order to display the current simulation time, you could type: \n \n$ ros2 topic echo /simulationTime\n \n Finally, make sure to have a look at the  remote API functionality  in CoppeliaSim: it allows for remote function execution, fast data streaming back and forth, is quite simple to use, leightweight and  cross-platform. The remote API functionality is available for 7 different languages and can be an interesting alternative to ROS in some cases. \n \n \n \n \n', 'tags': '', 'url': 'ros2Tutorial.html'}, {'title': 'compilingCoppeliaSim', 'text': "\n \n \n \n \n \nCompiling CoppeliaSim and related items\n \n \nThe full source code of CoppeliaSim (including most plugin source codes and others) can be found  here .  While the CoppeliaSim library ( coppeliaSimLib ) is GNU GPL licensed, the geometric and kinematics plugins ( simExtGeom  and  simExtIK ) have a specific license attached. In short, only educational entities (students, teachers, professors, schools or Universities) may download and use that plugin without explicit permission. \n Other source code items (e.g. various projects, plugins, interfaces, etc.)  are not discussed here. \n CoppeliaSimLib and the geometric plugin are  Qt  projects, and will require you to have Qt installed on your computer.  Try to comply with following list of requirements in order to encounter least problems during compilation: \n if possible, try using the same Qt version as the one that was used to compile the binary CoppeliaSim Edu (click [Help --> About About CoppeliaSim Edu...] to display the Qt version) \n for Qt projects, make sure to use the same compiler as the one that was used to compile the binary CoppeliaSim Edu. \n Ubuntu is the preferred Linux distribution. \n you will need to download and compile  QScintilla2  (C++ editor control).  \n you will need to download and install the  Boost C++ library .  \n you will need to download the  Lua5.3  binaries and headers.  \n Download and install CoppeliaSim Edu. Then download the CoppeliaSimLib library source code (and optionally the plugin source codes) into the CoppeliaSim Edu installation folder. You should have following folder structure: \n \n \xa0 \n When using CoppeliaSim in conjunction with a plugin, make sure to use the source code / binaries that come from the same release (check the release tags), in order to avoid incompatibilities. Finally, before being able to compile the CoppeliaSim project, you will have to adjust various paths in the   config.pri  file. \n CoppeliaSimLib compiles to a shared library. The default client application that loads and runs the library is  coppeliaSim  or  coppeliaSim.exe . You can use the precompiled one, or recompile it yourself (refer to following project file:  coppeliaSimClientApplication ). The load operation of the library is successfull only if: \n the client application could find all needed functions in the shared library \n the shared library could find all shared libraries that it depends on (e.g. the Lua shared library, etc.)  \n The easiest for you is to copy the compiled libraries into the CoppeliaSim  folder, then you will be sure that CoppeliaSim should start and won't complain about missing dependencies. \n It is very important that you do not mix various Qt versions, or binaries from various compilers. If your main CoppeliaSimLib library was compiled with Qt X and compiler Y, then all plugins related to CoppeliaSim should also have been compiled with Qt X and compiler Y, otherwise, you can experience strange behaviours (library that cannot load, sudden crashes, etc.). This requirement can be relaxed if your plugin is not making use of any Qt function. \n \n \n \n \n \n", 'tags': '', 'url': 'compilingCoppeliaSim.html'}]};